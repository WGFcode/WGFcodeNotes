### 内存管理
#### 1.面试题
#### 1.1. 使用CADisplayLink、NSTimer有什么注意点
    #### CADisplayLink、NSTimer会对targe产生强引用，如果target又对它们产生强引用，那么就会发生循环引用
    @interface WGMainObjcVC()
    @property(nonatomic, strong) CADisplayLink *link;
    @property(nonatomic, strong) NSTimer *timer;
    @end

    @implementation WGMainObjcVC
    - (void)viewDidLoad {
        [super viewDidLoad];
        
        //CADisplayLink其实也是个定时器，区别就是不需要设置时间，保证调用频率和屏幕的刷帧频率一致，60FPS
        //self.link = [CADisplayLink displayLinkWithTarget:self selector:@selector(linkTest)];
        //[self.link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode];
        
        //开启定时器方式一
        //self.timer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(test) userInfo:nil repeats:YES];
        //[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSDefaultRunLoopMode];
        //开启定时器方式二
        self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(test) userInfo:nil repeats:YES];
    }

    -(void)test {
        NSLog(@"%s",__func__);
    }

    -(void)dealloc {
        //[self.link invalidate];
        [self.timer invalidate];
    }
    
    打印结果： -[WGMainObjcVC test]
             -[WGMainObjcVC test]
             ......
#### 即使页面销毁了，定时器中的任务仍然会调用，因为self强引用了CADisplayLink/NSTimer,而CADisplayLink/NSTimer又强引用了target:self,导致了循环引用。
#### 解决方案一： 利用Block的方式创建定时器，然后通过__weak弱引用来解决循环引用问题
        //这种创建定时器的方式利用__weak不能解决循环引用问题
        //因为无论target:的参数传递self还是weakSelf，都是传递个指针给target,
        //而NStimer/CADisplayLink内部都会对传递进来的target参数进行强引用的，__weak是用来解决Block循环引用的。
        __weak typeof(self) weakSelf = self;
        self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:weakSelf selector:@selector(test) userInfo:nil repeats:YES];
        
        //利用Block方式创建定时器，利用__weak是可以解决循环引用问题的
        __weak typeof(self) weakSelf = self;
        //NSTimer强引用者Block，而Block对self是弱引用的，所以可以解决循环引用问题
        self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 repeats:YES block:^(NSTimer * _Nonnull timer) {
            [weakSelf test];
        }];
#### 解决方案二：新建一个对象(让对象来弱引用self)，作为NSTimer/CADisplayLink的target参数，那么这个对象就要实现定时器的任务，为了让self实现定时器任务，在这个对象内部进行消息转发，将消息转发给self来解决循环引用问题
        //WGTargetProxy.h文件
        @interface WGTargetProxy : NSObject
        @property(nonatomic, weak) id target;
        +(instancetype)proxyWithTarget:(id)target;
        @end
        
        //WGTargetProxy.m文件
        @implementation WGTargetProxy
        +(instancetype)proxyWithTarget:(id)target {
            WGTargetProxy *proxy = [[WGTargetProxy alloc]init];
            proxy.target = target;
            return proxy;
        }
        //转发消息给target
        - (id)forwardingTargetForSelector:(SEL)aSelector {
            return self.target;
        }
        @end
        
        //利用添加的对象来作为target,target对self进行弱引用，然后在添加的对象中，对方法进行消息转发，转发给self
        self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:[WGTargetProxy proxyWithTarget:self] selector:@selector(test) userInfo:nil repeats:YES];
    
#### 解决方案三: 创建一个继承自NSProxy的类，然后直接进行消息转发.NSProxy类似于NSObject，是基类，主要用来做消息转发。效率高，因为它不是继承自NSObject的，所以当调用一个不存在的方法时，避免了去父类中查找的过程，而是直接进行消息转发
        //WGTargetProxy.h文件
        @interface WGTargetProxy : NSProxy
        @property(nonatomic, weak) id target;
        +(instancetype)proxyWithTarget:(id)target;
        @end
    
        //WGTargetProxy.m文件
        @implementation WGTargetProxy
        +(instancetype)proxyWithTarget:(id)target {
            //继承自NSProxy类的对象没有init方法
            WGTargetProxy *proxy = [WGTargetProxy alloc];
            proxy.target = target;
            return proxy;
        }
        - (void)forwardInvocation:(NSInvocation *)invocation {
            [invocation invokeWithTarget:self.target];
        }
        -(NSMethodSignature *)methodSignatureForSelector:(SEL)sel {
             return [self.target methodSignatureForSelector:sel];
        }
        @end
    
        self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:[WGTargetProxy proxyWithTarget:self] selector:@selector(test) userInfo:nil repeats:YES];
#### ⚠️知识点：如果是继承自NSProxy的对象，如果调用这个对象的isKindOfClass,那么就是会进入消息转发，会让这个对象的target去执行。例如：
        //继承自NSProxy
        WGTargetProxy *proxy1 = [WGTargetProxy1 proxyWithTarget:self];
        //继承自NSObject
        WGTargetProxy *proxy2 = [WGTargetProxy2 proxyWithTarget:self];
        NSLog(@"继承自NSProxy---%d\n 继承自NSObject---%d\n",[proxy1 isKindOfClass:[self class]],[proxy2 isKindOfClass:[self class]]);
    
        打印结果：继承自NSProxy---1
                继承自NSObject---0
    
    #### 1.2 NSTimer为什么不准时？有什么方法来保证定时器的准时哪？
    #### 因为NSTimer是依赖于RunLoop的，如果RunLoop的任务过重，即NSTimer事件需要等待RunLoop处理其他的事情，处理完了才会来处理NSTimer事件，所以才会导致NSTimer不准时。想保证定时器任务的准时，可以使用GCD定时器，因为GCD定时器是不依赖Runloop的，它是直接和系统内核挂钩的
    
    #### 1.3 GCD定时器
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    2.介绍下内存的几大区域
    3. 讲一下你对iOS内存管理的理解
    4. autorelease在什么时机释放
    5. 方法里有局部对象，出了方法会立即释放吗
    6. ARC都帮我们做了什么？
    7. weak指针的实现原理
    

















































