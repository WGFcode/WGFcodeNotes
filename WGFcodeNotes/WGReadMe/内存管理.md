### 内存管理
### 1.面试题
#### 1.1. 使用CADisplayLink、NSTimer有什么注意点
    #### CADisplayLink、NSTimer会对targe产生强引用，如果target又对它们产生强引用，那么就会发生循环引用
    @interface WGMainObjcVC()
    @property(nonatomic, strong) CADisplayLink *link;
    @property(nonatomic, strong) NSTimer *timer;
    @end

    @implementation WGMainObjcVC
    - (void)viewDidLoad {
        [super viewDidLoad];
        
        //CADisplayLink其实也是个定时器，区别就是不需要设置时间，保证调用频率和屏幕的刷帧频率一致，60FPS
        //self.link = [CADisplayLink displayLinkWithTarget:self selector:@selector(linkTest)];
        //[self.link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode];
        
        //开启定时器方式一
        //self.timer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(test) userInfo:nil repeats:YES];
        //[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSDefaultRunLoopMode];
        //开启定时器方式二
        self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(test) userInfo:nil repeats:YES];
    }

    -(void)test {
        NSLog(@"%s",__func__);
    }

    -(void)dealloc {
        //[self.link invalidate];
        [self.timer invalidate];
    }
    
    打印结果： -[WGMainObjcVC test]
             -[WGMainObjcVC test]
             ......
#### 即使页面销毁了，定时器中的任务仍然会调用，因为self强引用了CADisplayLink/NSTimer,而CADisplayLink/NSTimer又强引用了target:self,导致了循环引用。
#### 解决方案一： 利用Block的方式创建定时器，然后通过__weak弱引用来解决循环引用问题
        //这种创建定时器的方式利用__weak不能解决循环引用问题
        //因为无论target:的参数传递self还是weakSelf，都是传递个指针给target,
        //而NStimer/CADisplayLink内部都会对传递进来的target参数进行强引用的，__weak是用来解决Block循环引用的。
        __weak typeof(self) weakSelf = self;
        self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:weakSelf selector:@selector(test) userInfo:nil repeats:YES];
        
        //利用Block方式创建定时器，利用__weak是可以解决循环引用问题的
        __weak typeof(self) weakSelf = self;
        //NSTimer强引用者Block，而Block对self是弱引用的，所以可以解决循环引用问题
        self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 repeats:YES block:^(NSTimer * _Nonnull timer) {
            [weakSelf test];
        }];
#### 解决方案二：新建一个对象(让对象来弱引用self)，作为NSTimer/CADisplayLink的target参数，那么这个对象就要实现定时器的任务，为了让self实现定时器任务，在这个对象内部进行消息转发，将消息转发给self来解决循环引用问题
        //WGTargetProxy.h文件
        @interface WGTargetProxy : NSObject
        @property(nonatomic, weak) id target;
        +(instancetype)proxyWithTarget:(id)target;
        @end
        
        //WGTargetProxy.m文件
        @implementation WGTargetProxy
        +(instancetype)proxyWithTarget:(id)target {
            WGTargetProxy *proxy = [[WGTargetProxy alloc]init];
            proxy.target = target;
            return proxy;
        }
        //转发消息给target
        - (id)forwardingTargetForSelector:(SEL)aSelector {
            return self.target;
        }
        @end
        
        //利用添加的对象来作为target,target对self进行弱引用，然后在添加的对象中，对方法进行消息转发，转发给self
        self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:[WGTargetProxy proxyWithTarget:self] selector:@selector(test) userInfo:nil repeats:YES];
    
#### 解决方案三: 创建一个继承自NSProxy的类，然后直接进行消息转发.NSProxy类似于NSObject，是基类，主要用来做消息转发。效率高，因为它不是继承自NSObject的，所以当调用一个不存在的方法时，避免了去父类中查找的过程，而是直接进行消息转发
        //WGTargetProxy.h文件
        @interface WGTargetProxy : NSProxy
        @property(nonatomic, weak) id target;
        +(instancetype)proxyWithTarget:(id)target;
        @end
    
        //WGTargetProxy.m文件
        @implementation WGTargetProxy
        +(instancetype)proxyWithTarget:(id)target {
            //继承自NSProxy类的对象没有init方法
            WGTargetProxy *proxy = [WGTargetProxy alloc];
            proxy.target = target;
            return proxy;
        }
        - (void)forwardInvocation:(NSInvocation *)invocation {
            [invocation invokeWithTarget:self.target];
        }
        -(NSMethodSignature *)methodSignatureForSelector:(SEL)sel {
             return [self.target methodSignatureForSelector:sel];
        }
        @end
    
        self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:[WGTargetProxy proxyWithTarget:self] selector:@selector(test) userInfo:nil repeats:YES];
#### ⚠️知识点：如果是继承自NSProxy的对象，如果调用这个对象的isKindOfClass,那么就是会进入消息转发，会让这个对象的target去执行。例如：
        //继承自NSProxy
        WGTargetProxy *proxy1 = [WGTargetProxy1 proxyWithTarget:self];
        //继承自NSObject
        WGTargetProxy *proxy2 = [WGTargetProxy2 proxyWithTarget:self];
        NSLog(@"继承自NSProxy---%d\n 继承自NSObject---%d\n",[proxy1 isKindOfClass:[self class]],[proxy2 isKindOfClass:[self class]]);
    
        打印结果：继承自NSProxy---1
                继承自NSObject---0
    
#### 1.2 NSTimer为什么不准时？有什么方法来保证定时器的准时哪？
#### 因为NSTimer是依赖于RunLoop的，如果RunLoop的任务过重，即NSTimer事件需要等待RunLoop处理其他的事情，处理完了才会来处理NSTimer事件，所以才会导致NSTimer不准时。想保证定时器任务的准时，可以使用GCD定时器，因为GCD定时器是不依赖Runloop的，它是直接和系统内核挂钩的
#### 1.3 GCD定时器
    
    @interface WGMainObjcVC()
    //必须强引用这个定时器，否则定时器是不会工作的
    @property(nonatomic, strong) dispatch_source_t timer;
    @end

    @implementation WGMainObjcVC
    - (void)viewDidLoad {
        [super viewDidLoad];
        NSLog(@"-------begin-------");
        //创建队列:主队列就是在主线程下，非主队列都是在子线程中
        dispatch_queue_t queue = dispatch_get_main_queue();
        //1. 创建定时器
            参数1：源的类型 参数2/参数3: 直接传递0即可 参数4:设置定时器运行的队列
        self.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);
        //2. 设置时间
            参数1: 设置哪个定时器  参数2: 开始时间，必须是dispatch_time(参数1,开始的时间) NSEC_PER_SEC：纳秒
            参数3: 间隔多长时间执行一次定时器任务  参数4: 误差，设置为0即可
        NSTimeInterval start = 3.0;
        NSTimeInterval interval = 1.0;
        dispatch_source_set_timer(self.timer,
                                  dispatch_time(DISPATCH_TIME_NOW, start * NSEC_PER_SEC),
                                  interval * NSEC_PER_SEC,
                                  0);
        //3. 设置定时器回调方法
        dispatch_source_set_event_handler(self.timer, ^{
            NSLog(@"1111--current Threaad:%@",[NSThread currentThread]);
        });
        //设置定时器回调方法二：通过Block方式
        //dispatch_source_set_event_handler_f(self.timer, timerTest);
        //4. 启动定时器
        dispatch_resume(self.timer);
    }
    
    //typedef void (*dispatch_function_t)(void *_Nullable);
    void timerTest(void* paramer) {
        NSLog(@"1111--current Threaad:%@",[NSThread currentThread]);
    }

    @end
    
    打印结果: 16:00:23.706883+0800 -------begin-------
            16:00:26.708723+0800  1111--current Threaad:<NSThread: 0x2825a20c0>{number = 1, name = main}
            16:00:27.708869+0800  1111--current Threaad:<NSThread: 0x2825a20c0>{number = 1, name = main}
            16:00:28.708798+0800  1111--current Threaad:<NSThread: 0x2825a20c0>{number = 1, name = main}
            16:00:29.708184+0800  1111--current Threaad:<NSThread: 0x2825a20c0>{number = 1, name = main}
    当页面返回时，定时器打印任务结束
#### 分析：我们通过GCD创建的定时器，是不依赖于RunLoop的，所以它的定时时间是准确的，那么如果我们在页面中添加个滚动视图去触摸滚动时，定时器任务是不会停止的，因为GCD创建的定时器和RunLoop没有任何关系，不会存在像NSTimer运行在RunLoopMode导致的实效问题；GCD创建的定时器不存在循环引用的问题，因为GCD内部已经做了处理了。GCD创建的定时器既可以同步执行也可以异步执行

#### 1.4 项目中利用GCD封装定时器
#### 详情见工程项目中的**WGGCDTimer**
    
### 2.介绍下内存的几大区域
#### 2.1 iOS内存布局,后续自己验证
     低地址   
       |   [保留地址]
       |   [代码段(_TEXT)]: 编译之后的代码
       |   [数据段(_DATA)]: 
       |           字符串常量: 比如 NSString *str = @"123"
       |           已初始化数据:已初始化的全局变量、静态变量
       |           未初始化数据:未初始化的全局变量、静态变量
       |   [堆(heap)] : 通过alloc、malloc、calloc等动态分配的空间,分配的内存地址越来越大
       |               堆分配地址是由低到高
       |   [栈(stack)]: 函数调用开销,函数中的局部变量(不管是否初始化)都是放在栈上的,分配的内存地址越来越小
       |               栈分配地址是由高到低
       |   [内核区]
       |
     高地址
#### 2.2   Tagged Pointer技术
#### 从64bit开始,iOS引入了Tagged Pointer技术,用来优化NSNumber、NSDate、NSString等小对象的存储.
1.  在没有使用Tagged Pointer技术前,NSNumber等对象就是普通的OC对象,需要动态分配内存,维护饮用计数等,NSNumber的指针存储的是堆中NSNumber对象的地址值; 
2. 使用Tagged Pointer技术后, NSNumber指针里面存储的数据变成了: Tag(类型标记)+Data(值),也就是直接将数据存储到了指针中

        // 这两行代码完全一样
        NSNumber *number = [NSNumber numberWithInt:10];
        NSNumber *number = @10; 

        //没有使用 Tagged Pointer技术前
        0x10010101                       内存地址: 0x10010101
        number       ------------->    NSNumber对象
                                       存储值10
        //使用 Tagged Pointer技术后
        number = 0xb0000a1   (a代表10 1代表类型)
3. 当指针(Tagged Pointer)不够存储数据时,才会使用动态分配内存的方式来存储数据
4. objc_msgSend能识别Tagged Pointer,比如NSNumber的intValue方法,直接从指针提取数据,节省了以前的调用开销
5. 如何判断一个指针是否是Tagged Pointer? iOS平台,最高有效位是1(第64位); Mac平台,最低有效位是1

        
#### 2.2.1 有关Tagged Pointer面试题
        // 下面两种方式会出现什么问题
        dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
        for (int i = 0; i < 1000; i++) {
            dispatch_async(queue, ^{
                self.name = [NSString stringWithFormat:@"abcdefghijk"];
            });
        }

        dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
        for (int i = 0; i < 1000; i++) {
            dispatch_async(queue, ^{
                self.name = [NSString stringWithFormat:@"abc"];
            });
        }


        @interface WGMainObjcVC()
        @property(nonatomic, copy) NSString *name;
        @end

        @implementation WGMainObjcVC
        - (void)viewDidLoad {
            [super viewDidLoad];

            dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
            for (int i = 0; i < 1000; i++) {
                dispatch_async(queue, ^{
                    self.name = [NSString stringWithFormat:@"abcdefghijk"];
                });
            }
        }
        运行直接报错: Thread 4: EXC_BAD_INSTRUCTION (code=EXC_I386_INVOP, subcode=0x0)
#### 分析, 我们知道self.name实际上调用的是name属性的setter方法,ARC环境下,是系统帮我们添加了release/retain操作,实际在MRC环境下setter方法的伪代码如下, 案例中是多个线程中调用name属性的setter方法,那么就存在同一时间多个线程调用[_name release]方法,即_name可能会被释放多次,所以就会到导致错误(坏内存访问),而无论修饰符是strong还是copy,都会执行[_name release]这句代码,
        -(void)setName:(NSString *)name {
            if (_name != name) {  //如果传进来的属性值和之前不一样,就先将旧值release,然后在赋值
                [_name release];
                _name = [name retain];   //name属性修饰符是strong
                //_name = [name copy];   //name属性修饰符是copy
            }
        }
#### 解决方案: 
* 方案一: 将修饰name属性的nonatomic非原子属性改为atomic原子属性,这样在setter方法时就会有加锁解锁,就可以保证线程访问安全,即同一时间只有一个线程访问. (不推荐)如果其他地方也调用了self.name,而加锁解锁会消耗性能,所以不推荐使用
* 方案二: 直接在对name属性赋值的前后进行加锁/解锁操作即可

        dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
        for (int i = 0; i < 1000; i++) {
            dispatch_async(queue, ^{
                self.name = [NSString stringWithFormat:@"abc"];
            });
        }
        NSString *str1 = [NSString stringWithFormat:@"abcdefghijk"];
        NSString *str2 = [NSString stringWithFormat:@"abc"];
        NSLog(@"str1: ----%@ str2:---- %@",[str1 class],[str2 class]);
        
        正常运行并打印
        str1: ----__NSCFString str2:---- NSTaggedPointerString
        
#### 分析: 因为字符串值是abc, 直接是用Tagged Pointer技术存储的,所以它不是OC对象,不会去调用属性name的setter方法
        
#### 2.3 Tagged Pointer源码分析

        objc_release(id obj){
            if (!obj) return;
            //在realse销毁对象时,如果对象是TaggedPointer直接返回,不做销毁操作,因为它并不是一个OC对象
            if (obj->isTaggedPointer()) return;  
            return obj->release();
        }
        
        objc_object::isTaggedPointer() {
            return _objc_isTaggedPointer(this);
        }
        
        #if OBJC_MSB_TAGGED_POINTERS   //iOS开发,将1向左移63位(指针的最高有效位是1,就是TaggedPointer)
        #define _OBJC_TAG_MASK (1UL<<63)  
        #else  //Mac开发(指针的最低有效位是1,就是TaggedPointer)
        #define _OBJC_TAG_MASK 1UL
        
        //如果 指针&_OBJC_TAG_MASK = _OBJC_TAG_MASK 就是TaggedPointer
        _objc_isTaggedPointer(const void * _Nullable ptr) {
            return ((uintptr_t)ptr & _OBJC_TAG_MASK) == _OBJC_TAG_MASK;
        }
        
### 3. OC对象内存管理
#### 3.1 在iOS中,利用**引用计数**来管理OC对象中的内存;
* 一个新创建的OC对象,引用计数默认是1,当引用计数减为0时,OC对象就会销毁,释放其占用的内存空间;
* 调用retain会让OC对象的引用计数+1,调用release会使对象的引用计数-1;
* 当调用alloc、new、copy、mutableCopy方法返回了一个对象,在不需要这个对象时,需要调用release或autorelease来释放
* 想拥有某个对象,就让它的引用计数+1; 不想再拥有某个对象,就让它的引用计数-1


#### 接下来我们关闭ARC(Build Settings -> Objective-C Automatic Reference Counting ->NO(默认是YES,即ARC)),在MRC下验证

        //WGPerson.m文件
        @implementation WGPerson
        -(void)dealloc {
            [super dealloc];
            NSLog(@"----%s",__func__);
        }
        @end

        int main(int argc, const char * argv[]) {
            @autoreleasepool {
                //内存泄漏: 该释放的对象没有释放
                //WGPerson *p = [WGPerson new];
                WGPerson *p = [[WGPerson alloc]init];
                NSLog(@"%ld", [p retainCount]);
                [p release];
            }
            return 0;
        }

        打印结果: 1
                -----[WGPerson dealloc]
#### 每次创建一个OC对象,都需要在不使用时,调用release进行释放; 另外还有一个释放对象的方法autorelease,该方法好处就是开发者不需要去担心调用对象的方法/属性是在release方法前还是后的问题, 如果使用release进行释放,在release方法后是不能对对象进行操作的,因为对象已经销毁了,再调用对象的属性/方法会报错, 而

        WGPerson *p = [[[WGPerson alloc]init] autorelease];
        NSLog(@"%ld", [p retainCount]);
        
        打印结果: 1
                -----[WGPerson dealloc]
#### 3.2 在OC中各个对象之间是有联系的(WGPerson对象拥有WGDog狗对象),所以涉及到MRC下内存管理方法总结,一般在MRC下我们写setter方法和销毁对象方法是这样的

        @interface WGPerson : NSObject
        {
            WGDog *_dog;
        }
        -(void)setDog:(WGDog *)dog;
        -(WGDog *)dog;
        @end

        @implementation WGPerson
        //MRC下,判断不是同一个对象,先对原来的对象进行release,然后再对传进来的对象进行retain
        -(void)setDog:(WGDog *)dog {
            if (_dog != dog) {
                [_dog release];
                _dog = [dog retain];
            }
        }
        -(WGDog *)dog {
            return _dog;
        }

        -(void)dealloc {
            [_dog release];
            _dog = nil;
            //上面两行代码也可以换成下面的,调用的是setDog方法
            self.dog = nil
            //父类的dealloc放到最后
            [super dealloc];
            NSLog(@"----%s",__func__);
        }
        @end

#### 3.3 在MRC环境下,   @synthesize 属性 = _属性名称; 会自动生成成员变量和属性的setter/getter实现
    @interface WGPerson : NSObject
    //MRC下声明属性,之前仅仅是声明了属性的setter/getter方法,后面编译器做了优化,也对属性的setter/getter方法做了实现
    @property(nonatomic, assign) int age;
    @end

    @implementation WGPerson
    //自动生成成员变量和属性的setter/getter实现,后面编译器做了优化,也对属性的setter/getter方法做了实现,所以后面也可以不用写了
    @synthesize age = _age;
    @end
    
    
    @property(nonatomic, assign) int age;
    @property(nonatomic, retain) WGDog *dog;
    
    在MRC下系统帮我们生成了对应的setter方法如下,但是不会生成dealloc方法,dealloc方法还是需要我们手动去写的
    -(void)setAge:(int)age {
        _age = age;
    }

    -(void)setDog:(WGDog *)dog {
        if (_dog != dog) {
            [_dog release];
            _dog = [dog retain];
        }
    }
#### 可以看出assign/retain的区别,assign针对的是基本数据类型,它的setter方法是直接赋值;而retain修饰是针对对象的,它的setter方法会先对旧的对象进行release,然后再对新的对象进行retain,会使引用计数+1

#### 在MRC下只要不是alloc、new、malloc开头的创建对象,都不需要手动去调用release,例如下面的,因为它们在调用对用的创建方法时,系统已经帮我们做了autorelease操作 
        NSMutableArray *arr = [NSMutableArray array];
        NSDictionary *dic = [NSDictionary dictionary];

#### 3.4 copy 和 mutableCopy
#### 拷贝的目的: 就是产生一个副本.跟源对象互不影响.修改了源对象,不影响副本对象; 修改了副本对象,不影响源对象. iOS提供了两种拷贝方法: 
1. copy: 不可变拷贝,产生不可变副本; 
2. mutableCopy: 可变拷贝, 产生可变副本;

#### 3.4.1 在MRC环境下,当我们通过alloc、new、copy、mutableCopy等方法产生的对象,我们需要负责释放的,如下
        //通过这种方式创建的字符串,在MRC下,系统已经帮我们自动插入了autorelease,所以不需要我们再手动调用releas方法了
        //注意:这里如果写的字符串值比较小,就会用到TaggedPointer计数,那么它的引用计数值会是-1,不利于我们观察对象的引用计数
        //NSString *str0 = [NSString stringWithFormat:@"123sdfasdfsfsf"];
        NSString *str1 = [[NSString alloc]initWithFormat:@"123sdfasdfsfsf"];
        NSString *str2 = [str1 copy];
        NSMutableString *str3 = [str1 mutableCopy];

        NSLog(@"\nstr1:%p\nstr2:%p\n:str3:%p\n",str1,str2,str3);
        [str3 release];
        [str2 release];
        [str1 release];

        打印结果: str1:0x102045a90
                str2:0x102045a90
                :str3:0x102046150
#### 分析,为什么str1和str2的地址值是一样的? copy不是产生了副本对象吗? 原因就是源对象str1是不可变的,而通过copy后产生的副本对象也是不可变的,根据拷贝的准则: 修改源对象/副本对象不影响副本对象/源对象, 因为源对象本身就是不可变的,所以根本无法修改,为了节省空间,所以系统将str2的指针也指向了str1指针所指向的内容, 如果此时对str1或者str2赋新的值,那么它们的地址就会变成不一样的,因为拷贝的准则,所以系统会为str1和str2分配不同的地址空间


#### 3.4.2 深拷贝和浅拷贝
* 深拷贝: 内容拷贝,产生新的对象
* 浅拷贝: 指针拷贝,没有产生新的对象

        //源对象不可变
        NSString *str1 = [[NSString alloc]initWithFormat:@"123"]; 
        NSString *str2 = [str1 copy];                    //浅拷贝,没有产生新的对象
        NSMutableString *str3 = [str1 mutableCopy];      //深拷贝,产生新的对象

        //str1引用计数1   str2和str1指向同一个对象,所以此时的[str1 copy]就相当于[str1 retain],使引用计数+1  str3引用计数1

        //源对象可变
        NSMutableString *str1 = [[NSMutableString alloc]initWithFormat:@"123"];
        NSString *str2 = [str1 copy];                    //深拷贝,产生了新的对象
        NSMutableString *str3 = [str1 mutableCopy];      //深拷贝,产生了新的对象

#### 3.4.3 总结: 数组、字典与字符串仍然适用上面的方法
                             copy                         mutablecopy
       NSString              NSString-浅拷贝               NSMutableString-深拷贝 
       NSMutableString       NSString-深拷贝               NSMutableString-深拷贝
       NSArray               NSArray-浅拷贝                NSMutableArray-深拷贝
       NSMutableArray        NSArray-深拷贝                NSMutableArray-深拷贝
       NSDictionary          NSDictionary-浅拷贝           NSMutableDictionary-深拷贝
       NSMutableDictionary   NSDictionary-深拷贝           NSMutableDictionary-深拷贝


#### 3.4.4 案例分析
#### 在MRC环境下,下面声明的属性会自动生成对应的setter方法
        @interface WGPerson : NSObject
        @property(nonatomic, assign) int age;
        @property(nonatomic, retain) WGDog *dog;
        @property(nonatomic, copy) NSArray *arr;
        @end

        -(void)setAge:(int)age {
            _age = age;
        }
        -(void)setDog:(WGDog *)dog {
            if (_dog != dog) {
                [_dog release];
                _dog = [dog retain];
            }
        }
        -(void)setArr:(NSArray *)arr {
            if (_arr != arr) {
                [_arr release];
                _arr = [arr copy];
            }
        }
#### 下面代码是否有问题
        @interface WGPerson : NSObject
        @property(nonatomic, copy) NSMutableArray *arr;
        @end
        
        int main(int argc, const char * argv[]) {
            @autoreleasepool {
                WGPerson *p = [[WGPerson alloc]init];
                p.arr = [[NSMutableArray alloc]init];
                [p.arr addObject:@"123"];
                [p.arr addObject:@"456"];
                [p release];
            }
            return 0;
        }
        
        //MRC下系统为arr生成的setter方法实现
        -(void)setArr:(NSArray *)arr {
            if (_arr != arr) {
                [_arr release];
                _arr = [arr copy];
            }
        }
#### 分析: 上面代码会报错,因为声明的可变数组arr用的是copy修饰,它底层的setter方法调用的是copy方法,那么返回的数组对象就是不可变的,所以在进行[p.arr addObject:]方法调用时会报错:-[__NSArray0 addObject:]: unrecognized selector sent to instance 0x101801070, 那么可不可以用mutableCopy来修饰arr哪? 答案是肯定不可以,因为mutableCopy压根都不能用来作为属性修饰符. 所以总结一句话: 开发过程中不要用copy来修饰一个可变的数组,而是要修饰一个不可变的数组,这样开发过程中一旦调用了addObject方法,编译器就会直接检查然后报错

#### 3.4.5 OC对象的copy操作
#### OC对象如果想实现copy操作,那么需要实现NSCopying协议中的copyWithZone方法
        @interface WGPerson : NSObject<NSCopying>
        @property(nonatomic, copy) NSMutableArray *arr;
        @end

        -(id)copyWithZone:(NSZone *)zone {
            WGPerson *p = [[WGPerson allocWithZone:zone] init];
            p.arr = self.arr;
            return p;
        }

        int main(int argc, const char * argv[]) {
            @autoreleasepool {
                WGPerson *p = [[WGPerson alloc]init];
                WGPerson *p1 = [p copy];
            }
            return 0;
        }

#### 3.5 **引用计数**存储方式
#### 在64bit中,引用计数可以直接存储在优化过的isa指针中,也可以存储在SideTable类中,见Runtime源码
        struct SideTable {
        spinlock_t slock;
        RefcountMap refcnts;       是一个存放着对象引用计数的散列表
        weak_table_t weak_table;
        ......
        }
        
#### 找到retainCount方法,我们详细看下引用计数是如何获取的
        - (NSUInteger)retainCount {
            return ((id)self)->rootRetainCount();
        }
        
        objc_object::rootRetainCount() {
            //判断是否是TaggedPointer,如果是直接返回(之前验证过,如果是TaggedPointer,那么引用计数就是-1)
            if (isTaggedPointer()) return (uintptr_t)this;  
            sidetable_lock();
            isa_t bits = LoadExclusive(&isa.bits);
            ClearExclusive(&isa.bits);
            if (bits.nonpointer) {      //优化过的isa指针
                uintptr_t rc = 1 + bits.extra_rc;
                if (bits.has_sidetable_rc) {  //如果引用计数不是存储在isa中,而是存储在sideTable结构中
                    rc += sidetable_getExtraRC_nolock();
                }
                sidetable_unlock();
                return rc;
            }
            sidetable_unlock();
            return sidetable_retainCount();
        }
        
        objc_object::sidetable_getExtraRC_nolock() {
            assert(isa.nonpointer);
            //通过key获取到一个value(对象的地址作为Key)
            SideTable& table = SideTables()[this];  
            // 将对象的地址this传给散列表,获取到对象对应的引用计数,然后返回
            RefcountMap::iterator it = table.refcnts.find(this);
            if (it == table.refcnts.end()) return 0;
            else return it->second >> SIDE_TABLE_RC_SHIFT;
        }
#### 查看release方法源码
        -(void) release {
            _objc_rootRelease(self);
        }

        _objc_rootRelease(id obj) {
            assert(obj);
            obj->rootRelease();
        }

        objc_object::rootRelease() {
            return rootRelease(true, false);
        }

        objc_object::rootRelease(bool performDealloc, bool handleUnderflow) { //简化后的
            if (isTaggedPointer()) return false;
            bool sideTableLocked = false;
                if (slowpath(!newisa.nonpointer)) {  //如果不是优化过的isa指针,那么就从sideTable里找
                    ClearExclusive(&isa.bits);
                    if (sideTableLocked) sidetable_unlock();
                    return sidetable_release(performDealloc);
                }
        }
        
        objc_object::sidetable_release(bool performDealloc) {
            //以对象的地址为key,从SideTables散列表中找到一个value
            SideTable& table = SideTables()[this];
            bool do_dealloc = false;
            table.lock();
            RefcountMap::iterator it = table.refcnts.find(this);
            if (it == table.refcnts.end()) {
                do_dealloc = true;
                table.refcnts[this] = SIDE_TABLE_DEALLOCATING;
            } else if (it->second < SIDE_TABLE_DEALLOCATING) {
                // SIDE_TABLE_WEAKLY_REFERENCED may be set. Don't change it.
                do_dealloc = true;
                it->second |= SIDE_TABLE_DEALLOCATING;
            } else if (! (it->second & SIDE_TABLE_RC_PINNED)) {
                it->second -= SIDE_TABLE_RC_ONE;    //减操作
            }
            table.unlock();
            //一旦上面引用计数-1,就有可能会减为0,所以就需要判断是否需要dealloc,如果需要,就通过objc_msgSend发送dealloc消息
            if (do_dealloc  &&  performDealloc) {
                ((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_dealloc);
            }
            return do_dealloc;
        }
#### 查看retain方法源码
        -(id) retain {
            return _objc_rootRetain(self);
        }

        _objc_rootRetain(id obj){
            assert(obj);
            return obj->rootRetain();
        }

        objc_object::rootRetain() {
            return rootRetain(false, false);
        }

        objc_object::rootRetain(bool tryRetain, bool handleOverflow) { //简化后的
            if (isTaggedPointer()) return (id)this;
                if (slowpath(!newisa.nonpointer)) {  //如果不是优化过的isa指针,那么就从sideTable里找
                    ClearExclusive(&isa.bits);
                    if (!tryRetain && sideTableLocked) sidetable_unlock();
                    if (tryRetain) return sidetable_tryRetain() ? (id)this : nil;
                    else return sidetable_retain();
                }
        }
        
        objc_object::sidetable_retain()
            //以对象的地址为key,从SideTables散列表中找到一个value
            SideTable& table = SideTables()[this];
            table.lock();
            size_t& refcntStorage = table.refcnts[this];
            if (! (refcntStorage & SIDE_TABLE_RC_PINNED)) {
                refcntStorage += SIDE_TABLE_RC_ONE;   //加操作
            }
            table.unlock();
            return (id)this;
        }
#### 3.6 weak指针的实现原理
        @implementation Person
        -(void)dealloc {
            NSLog(@"%s---",__func__);
        }
        @end

        - (void)viewDidLoad {
            [super viewDidLoad];
            NSLog(@"begin");
            {
                Person *person = [[Person alloc]init];
            }
            NSLog(@"end");
        }
        打印结果: begin
                -[Person dealloc]---
                end
#### 一旦出了{},person对象就会被销毁
        - (void)viewDidLoad {
            [super viewDidLoad];
            __strong Person *person1;    //__strong可以不写,因为默认都是强引用
            __weak Person *person2;
            __unsafe_unretained Person *person3;
            NSLog(@"begin");
            {
                Person *person = [[Person alloc]init];
                //1. person1是强引用,所以出了{},person对象并不会销毁,而是在viewDidLoad方法执行结束后销毁
                //所以打印结果是: begin  -->   end   --> -[Person dealloc]---
                //person1 = person;
                
                //2. person2是弱引用,所以出了{},person对象就销毁了
                //所以打印结果是: begin  -->   -[Person dealloc]---   -->   end
                //person2 = person;
                
                //3. person3也是弱引用,所以出了{},person对象就销毁了
                //所以打印结果是: begin  -->   -[Person dealloc]---   -->   end
                person3 = person;
                
                //4.__weak和__unsafe_unretained都是弱指针,区别就是__weak弱引用在对象销毁时,会对对象自动置为nil; 而__unsafe_unretained弱引用在对象销毁时,不会对对象自动置为nil,会出现野指针问题,即虽然对象销毁了,但是它的内存仍然存在,如果继续访问该对象,会导致坏内存访问
            }
            NSLog(@"end");
        }
#### 要想知道weak的原理,即对象销毁后,系统是如何对销毁的对象自动置为nil的,我们需要查看dealloc方法源码
        - (void)dealloc {
            _objc_rootDealloc(self);
        }

        _objc_rootDealloc(id obj) {
            assert(obj);
            obj->rootDealloc();
        }

        objc_object::rootDealloc() {
            if (isTaggedPointer()) return;  // fixme necessary?
            if (fastpath(isa.nonpointer  &&             //是否是优化过的isa指针
                         !isa.weakly_referenced  &&     //是否有弱引用表(取反)
                         !isa.has_assoc  &&             //是否有关联对象(取反)
                         !isa.has_cxx_dtor  &&          //是否有C++的析构函数(取反)
                         !isa.has_sidetable_rc)) {      //是否有sideTable(取反)
                assert(!sidetable_present());
                free(this);  //如果上面条件成立,直接释放,不需要其他查询,释放效率会更快
            } else {
                object_dispose((id)this);
            }
        }
        
        object_dispose(id obj) {
            if (!obj) return nil;
            objc_destructInstance(obj);    
            free(obj);   //释放对象前,先去忙其他事情(objc_destructInstance方法)
            return nil;
        }
        
        void *objc_destructInstance(id obj) {
            if (obj) {
                // Read all of the flags at once for performance.
                bool cxx = obj->hasCxxDtor();
                bool assoc = obj->hasAssociatedObjects();
                // This order is important.
                if (cxx) object_cxxDestruct(obj);            //清除成员变量
                if (assoc) _object_remove_assocations(obj);  //移除关联对象
                obj->clearDeallocating();                    //将指向当前对象的弱指针置为nil
            }
            return obj;
        }
        
        objc_object::clearDeallocating() {
            //是否是优化过的isa指针,如果不是(就是普通的isa指针),直接调用sidetable_clearDeallocating方法
            if (slowpath(!isa.nonpointer)) {  
                // Slow path for raw pointer isa.
                sidetable_clearDeallocating();
            } else if (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) {  
                //判断是否有弱引用表
                // Slow path for non-pointer isa with weak refs and/or side table data.
                clearDeallocating_slow();
            }
            assert(!sidetable_present());
        }
        
        objc_object::clearDeallocating_slow(){
            //弱引用表也是一个散列表, 将对象的地址作为key,找到对应的value值,
            SideTable& table = SideTables()[this];
            table.lock();
            if (isa.weakly_referenced) {  //如果是弱引用表
                weak_clear_no_lock(&table.weak_table, (id)this);
            }
            if (isa.has_sidetable_rc) {
                table.refcnts.erase(this);
            }
            table.unlock();
        }
        
        weak_clear_no_lock(weak_table_t *weak_table, id referent_id)  {
            objc_object *referent = (objc_object *)referent_id;
            //根据对象的地址(key)找出对应的东西weak_entry_t
            weak_entry_t *entry = weak_entry_for_referent(weak_table, referent);
            ......
            //将找到的东西weak_entry_t从表中移除
            weak_entry_remove(weak_table, entry);
        }
        
        weak_entry_for_referent(weak_table_t *weak_table, objc_object *referent) {
            //将弱引用对象的地址 & weak_table->mask = 索引 (哈希表操作)
            size_t begin = hash_pointer(referent) & weak_table->mask;
        }
#### 总结: weak实现原理:将弱引用指针存到哈希表中,当弱引用对象销毁时,取出当前对象对应的弱引用表,将弱引用表中存储的弱引用都清楚掉并且置为nil

#### 3.7 ARC帮我们做了什么
1. ARC其实就是LLVM+RunTime系统相互协助的一个结果,
2. ARC利用LLVM编译器自动帮我们生成了release、retain、autorelease代码 
3. 像弱引用这样的存在,是需要运行时Runtime来支持的,由Runtime监控到对象销毁后,利用RunTime来销毁对象的


#### 3.8 autorelease原理





        




    4. autorelease在什么时机释放
    5. 方法里有局部对象，出了方法会立即释放吗
    6. ARC都帮我们做了什么？
    7. weak指针的实现原理
    

















































