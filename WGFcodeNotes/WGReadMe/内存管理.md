### 内存管理
#### 1.面试题
#### 1.1. 使用CADisplayLink、NSTimer有什么注意点
    #### CADisplayLink、NSTimer会对targe产生强引用，如果target又对它们产生强引用，那么就会发生循环引用
    @interface WGMainObjcVC()
    @property(nonatomic, strong) CADisplayLink *link;
    @property(nonatomic, strong) NSTimer *timer;
    @end

    @implementation WGMainObjcVC
    - (void)viewDidLoad {
        [super viewDidLoad];
        
        //CADisplayLink其实也是个定时器，区别就是不需要设置时间，保证调用频率和屏幕的刷帧频率一致，60FPS
        //self.link = [CADisplayLink displayLinkWithTarget:self selector:@selector(linkTest)];
        //[self.link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode];
        
        //开启定时器方式一
        //self.timer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(test) userInfo:nil repeats:YES];
        //[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSDefaultRunLoopMode];
        //开启定时器方式二
        self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(test) userInfo:nil repeats:YES];
    }

    -(void)test {
        NSLog(@"%s",__func__);
    }

    -(void)dealloc {
        //[self.link invalidate];
        [self.timer invalidate];
    }
    
    打印结果： -[WGMainObjcVC test]
             -[WGMainObjcVC test]
             ......
#### 即使页面销毁了，定时器中的任务仍然会调用，因为self强引用了CADisplayLink/NSTimer,而CADisplayLink/NSTimer又强引用了target:self,导致了循环引用。
#### 解决方案一： 利用Block的方式创建定时器，然后通过__weak弱引用来解决循环引用问题
        //这种创建定时器的方式利用__weak不能解决循环引用问题
        //因为无论target:的参数传递self还是weakSelf，都是传递个指针给target,
        //而NStimer/CADisplayLink内部都会对传递进来的target参数进行强引用的，__weak是用来解决Block循环引用的。
        __weak typeof(self) weakSelf = self;
        self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:weakSelf selector:@selector(test) userInfo:nil repeats:YES];
        
        //利用Block方式创建定时器，利用__weak是可以解决循环引用问题的
        __weak typeof(self) weakSelf = self;
        //NSTimer强引用者Block，而Block对self是弱引用的，所以可以解决循环引用问题
        self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 repeats:YES block:^(NSTimer * _Nonnull timer) {
            [weakSelf test];
        }];
#### 解决方案二：新建一个对象(让对象来弱引用self)，作为NSTimer/CADisplayLink的target参数，那么这个对象就要实现定时器的任务，为了让self实现定时器任务，在这个对象内部进行消息转发，将消息转发给self来解决循环引用问题
        //WGTargetProxy.h文件
        @interface WGTargetProxy : NSObject
        @property(nonatomic, weak) id target;
        +(instancetype)proxyWithTarget:(id)target;
        @end
        
        //WGTargetProxy.m文件
        @implementation WGTargetProxy
        +(instancetype)proxyWithTarget:(id)target {
            WGTargetProxy *proxy = [[WGTargetProxy alloc]init];
            proxy.target = target;
            return proxy;
        }
        //转发消息给target
        - (id)forwardingTargetForSelector:(SEL)aSelector {
            return self.target;
        }
        @end
        
        //利用添加的对象来作为target,target对self进行弱引用，然后在添加的对象中，对方法进行消息转发，转发给self
        self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:[WGTargetProxy proxyWithTarget:self] selector:@selector(test) userInfo:nil repeats:YES];
    
#### 解决方案三: 创建一个继承自NSProxy的类，然后直接进行消息转发.NSProxy类似于NSObject，是基类，主要用来做消息转发。效率高，因为它不是继承自NSObject的，所以当调用一个不存在的方法时，避免了去父类中查找的过程，而是直接进行消息转发
        //WGTargetProxy.h文件
        @interface WGTargetProxy : NSProxy
        @property(nonatomic, weak) id target;
        +(instancetype)proxyWithTarget:(id)target;
        @end
    
        //WGTargetProxy.m文件
        @implementation WGTargetProxy
        +(instancetype)proxyWithTarget:(id)target {
            //继承自NSProxy类的对象没有init方法
            WGTargetProxy *proxy = [WGTargetProxy alloc];
            proxy.target = target;
            return proxy;
        }
        - (void)forwardInvocation:(NSInvocation *)invocation {
            [invocation invokeWithTarget:self.target];
        }
        -(NSMethodSignature *)methodSignatureForSelector:(SEL)sel {
             return [self.target methodSignatureForSelector:sel];
        }
        @end
    
        self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:[WGTargetProxy proxyWithTarget:self] selector:@selector(test) userInfo:nil repeats:YES];
#### ⚠️知识点：如果是继承自NSProxy的对象，如果调用这个对象的isKindOfClass,那么就是会进入消息转发，会让这个对象的target去执行。例如：
        //继承自NSProxy
        WGTargetProxy *proxy1 = [WGTargetProxy1 proxyWithTarget:self];
        //继承自NSObject
        WGTargetProxy *proxy2 = [WGTargetProxy2 proxyWithTarget:self];
        NSLog(@"继承自NSProxy---%d\n 继承自NSObject---%d\n",[proxy1 isKindOfClass:[self class]],[proxy2 isKindOfClass:[self class]]);
    
        打印结果：继承自NSProxy---1
                继承自NSObject---0
    
#### 1.2 NSTimer为什么不准时？有什么方法来保证定时器的准时哪？
#### 因为NSTimer是依赖于RunLoop的，如果RunLoop的任务过重，即NSTimer事件需要等待RunLoop处理其他的事情，处理完了才会来处理NSTimer事件，所以才会导致NSTimer不准时。想保证定时器任务的准时，可以使用GCD定时器，因为GCD定时器是不依赖Runloop的，它是直接和系统内核挂钩的
#### 1.3 GCD定时器
    
    @interface WGMainObjcVC()
    //必须强引用这个定时器，否则定时器是不会工作的
    @property(nonatomic, strong) dispatch_source_t timer;
    @end

    @implementation WGMainObjcVC
    - (void)viewDidLoad {
        [super viewDidLoad];
        NSLog(@"-------begin-------");
        //创建队列:主队列就是在主线程下，非主队列都是在子线程中
        dispatch_queue_t queue = dispatch_get_main_queue();
        //1. 创建定时器
            参数1：源的类型 参数2/参数3: 直接传递0即可 参数4:设置定时器运行的队列
        self.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);
        //2. 设置时间
            参数1: 设置哪个定时器  参数2: 开始时间，必须是dispatch_time(参数1,开始的时间) NSEC_PER_SEC：纳秒
            参数3: 间隔多长时间执行一次定时器任务  参数4: 误差，设置为0即可
        NSTimeInterval start = 3.0;
        NSTimeInterval interval = 1.0;
        dispatch_source_set_timer(self.timer,
                                  dispatch_time(DISPATCH_TIME_NOW, start * NSEC_PER_SEC),
                                  interval * NSEC_PER_SEC,
                                  0);
        //3. 设置定时器回调方法
        dispatch_source_set_event_handler(self.timer, ^{
            NSLog(@"1111--current Threaad:%@",[NSThread currentThread]);
        });
        //设置定时器回调方法二：通过Block方式
        //dispatch_source_set_event_handler_f(self.timer, timerTest);
        //4. 启动定时器
        dispatch_resume(self.timer);
    }
    
    //typedef void (*dispatch_function_t)(void *_Nullable);
    void timerTest(void* paramer) {
        NSLog(@"1111--current Threaad:%@",[NSThread currentThread]);
    }

    @end
    
    打印结果: 16:00:23.706883+0800 -------begin-------
            16:00:26.708723+0800  1111--current Threaad:<NSThread: 0x2825a20c0>{number = 1, name = main}
            16:00:27.708869+0800  1111--current Threaad:<NSThread: 0x2825a20c0>{number = 1, name = main}
            16:00:28.708798+0800  1111--current Threaad:<NSThread: 0x2825a20c0>{number = 1, name = main}
            16:00:29.708184+0800  1111--current Threaad:<NSThread: 0x2825a20c0>{number = 1, name = main}
    当页面返回时，定时器打印任务结束
    #### 分析：我们通过GCD创建的定时器，是不依赖于RunLoop的，所以它的定时时间是准确的，那么如果我们在页面中添加个滚动视图去触摸滚动时，定时器任务是不会停止的，因为GCD创建的定时器和RunLoop没有任何关系，不会存在像NSTimer运行在RunLoopMode导致的实效问题；GCD创建的定时器不存在循环引用的问题，因为GCD内部已经做了处理了。GCD创建的定时器既可以同步执行也可以异步执行
    
    
    
    
    
    
    
    
    
    
    
    
    2.介绍下内存的几大区域
    3. 讲一下你对iOS内存管理的理解
    4. autorelease在什么时机释放
    5. 方法里有局部对象，出了方法会立即释放吗
    6. ARC都帮我们做了什么？
    7. weak指针的实现原理
    

















































