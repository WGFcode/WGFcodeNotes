## 数据结构与算法
#### 什么是算法？什么是数据结构
* 算法就是用于解决特定问题的一系列的执行步骤；使用不同的算法，解决同一个问题，效率可能相差非常大
* 如何评判一个算法的好快

        1.正确性、可读性、健壮性(对不合理输入的反应能力)          
        2.时间复杂度：估算程序指令的执行次数（执行时间）            
        3.空间复杂度：估计所需占用的存储空间  
* 算法的优化方式

        1.用尽量少的存储空间
        2.用尽量少的执行步骤（执行时间）
        3.根据情况，可以空间换时间；时间换空间
* 算法一般使用大O表示法来描述复杂度，它表示的数数据规模n对应的复杂度;大O表示法仅仅是一种粗略的分析模型，能帮助我们在短时间内了解一个算法的执行效率

        9---------->O(1)
        2n+3---------->O(n)
        n^2+2n+6---------->O(n^2)
        4log2n+25---------->O(logn)
        2^n---------------->O(2^n)
        O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)

* 数据结构是计算机存储、组织数据的方式，主要分为以下三种

        1. 线性结构：线性表（数组、链表、栈、队列、哈希表）
        2. 树形结构：二叉树、AVL树、红黑树、B树、堆、哈夫曼树、并查集
        3. 图形结构：领接矩阵、领接表

        数据结构逻辑上的分类
        1. 集合结构: 一个集合中有多个元素,元素与元素之间没有任何关系-->**NSSet、NSMutableSet**
        2. 线性结构: 一条线上有很多元素（直线、曲线），元素与元素之间是一对一的关系-->**NSArray、NSMutableArray**
        3. 树形结构: 想象成金字塔的一种结构，其元素之间是一对多的关系
        4. 图形结构: 无穷、无边、无向，任意图形，其元素之间是多对多的关系
        
        数据结构存储上的分类
        1. 顺序存储结构: 存储单元内存地址是连续的; 遍历快、查找快、效率高
        2. 链式存储结构: 存储单元内存地址可以是连续的，也可以是不连续的。它不要求逻辑上相邻的元素在物理位置上也相邻; 添加快、删除快

## 一. 常见的数据结构
* 线性表(数组、栈、队列、链表、哈希表)
* 树
* 图


### 1.线性表
* 线性表就是多个具有相同特性的数据元素(节点)组成的有序、有限的集合; 
* 当线性表的节点个数为0时,称为空表; 
* 线性表第一个节点称为首节点,最后一个元素称为尾节点
* 线性表的存储结构有两种

        顺序存储结构: 用一组地址连续的存储单元依次存储线性表的数据元素, 例如**数据** 
        链式存储结构: 用一组任意的存储单元存储线性表中的数据元素，它的存储单元可以是连续的，也可以是不连续的


#### 1.1. 线性表-数组
* 数组是顺序存储的,数组中的元素存储在一块连续的内存地址中,数组是直接通过下标来查找、删除、插入元素的; 
* 数组是【查询快】、【增删慢】
* 查询直接通过下标查询即可,查询任意数据耗时相同,时间复杂度为O(1); 
* 删除元素的话,要先将原始数据元素删除,同时【被删除元素】后面的每个元素前移,删除效率低; 
* 添加数据时,添加元素位置后的每个元素后移,再添加元素,添加效率极低
* 动态数组有个明显的缺点：可能会造成内存空间的大量浪费

#### 1.2 线性表-栈
* 栈是只能在一端进行插入、删除的数据结构,栈的特点就是【先进后出】或者叫【后进先出】
* 例如我们生活中盛放物品的箱子,先放进去的最后才能拿出来,后放进去的可以最先拿出来, 
* 栈操作主要涉及到【压/进栈】和【弹/出栈】，栈底是封闭的,栈顶是开放的,即只能在栈顶进行数据操作; 
* 出栈和进栈只会影响到最后一个元素

#### 1.3 线性表-队列
* 队列特点就是【先进先出】或者叫【后进后出】，iOS中常见的比如NSOpeartionQueue、GCD中的各种队列
* 我们生活中的排队买票,先进去买票的先出来,后进去的后出来; 
* 队列主要涉及到【入队列】和【出队列】, 入队列的方向称为后端,出队列的方向称为前端

#### 1.4 线性表-链表
* 链表是一种【增删快】【查询慢】的数据结构(对比数组来说的),查询数据必须从头开始查找,链表查找的时间复杂度为O(n);
* 链表数据在内存中是随机存储,每个节点分布在内存的不同位置,依靠【next指针】关联起来; 
* 链表中的数据只能按照指针的方向进行顺序访问; 适合插入、删除操作比较频繁的场景
* 链表是在物理上非连续、非顺序的数据结构,由若干个节点组成, 主要分为两种
    
    1. 单向链表: 每个节点有两部分组成,一部分是存放数据的变量data; 一部分是指向下一个节点的指针next

        头节点                                                             ^节点指向空地址表示结束
        [head+地址11] --->  [数据4+地址9] ---> [数据19+地址289] ---> ...... ---> [数据23+^]
    2. 双向链表: 除了 data 和 next指针,还有指向前置节点的 prev 指针
    3. 循环链表:循环链表由单链表演化过来。单链表的最后一个结点的链域指向NULL，而循环链表的建立，不要专门的头结点，让最后一个结点的链域指向链表结点。
    
#### 循环链表与单链表的区别
* 单链表需要创建一个头结点，专门存放第一个结点的地址；单链表的链域指向NULL。
* 循环链表不需要专门的头结点，让最后一个结点的链域指向链表的头结点。
* 单链表判断结点是否为表尾结点，只需判断结点的链域值是否是NULL。如果是，则为尾结点；否则不是。
* 循环链表盘判断是否为尾结点，则是判断该节点的链域是不是指向链表的头结点。


#### 1.5 线性表-哈希表
* 哈希表也叫散列表,本质上是一个数组,提供了键(key)和值(value)的映射关系,这里有两个重要的概念

    哈希函数: 通过哈希函数,可以把字符串或其它类型的**Key**,转化成数组的下标**index**
    哈希冲突: 不通的**Key**通过**哈希函数**获得的下标有可能相同
* 哈希表的基本操作

    1. 写操作: 在表中插入新的键值对
    2. 读操作: 通过给定的 Key 在哈希表中查找对应的 Value

* 哈希表本质是一个数组,数组中每个元素称为【箱子】, 箱子中存放的是键值对,数组长度即箱子的长度
* 哈希表还有一个重要的属性叫【负载因子】,用来衡量哈希表的空/满程度,负载因子一定程度上可以体现查询的效率

        负载因子 = 总键值对数 / 箱子个数
* 负载因子越大,意味着哈希表越满,越容易导致冲突,性能也就越低,因此,一般情况下,负载因子大于3/4(0.75)时,哈希表会自动扩容
* 重哈希(rehash): 哈希表在扩容时,一般会创建2倍于原来个数的箱子,即使Key的哈希值不变,对箱子个数的取余的结果也会发生改变,所有键值对的存放位置都有可能发生改变,
* 哈希表的问题

    1. 如果哈希表中本来箱子就比较多，扩容时需要重新哈希并移动数据，性能影响较大。
    2. 如果哈希函数设计不合理，哈希表在极端情况下会变成线性表，性能极低。


#### 1.5.1 哈希冲突解决方案          

       例如 h(k)=k%7, h(0)=h(7)=h(14)=...
       
* 开放寻址法: 如果哈希函数返回的位置已经有值,则可以向后查找新的位置来存储这个值,这种方式一般不采用,主要是hash表满了,就没有空间了
* 拉链法: 哈希表每个位置都连接一个链表，当冲突发生时，冲突的元素将被加到该位置链表的最后。查找的时候，先找到hash函数计算的位置，再在链表里找

#### 总结 线性表性能对比         


                查找        更新      插入     删除
        数组     O(1)       O(1)     O(n)    O(n)
        链表     O(n)       O(1)     O(1)    O(1)
        栈       -           -       O(1)    O(1)
        队列                         O(1)    O(1)
        哈希表   O(1)       O(1)      O(1)    O(1)
    


## 二、二叉树
#### 二叉树是树形结构的一种重要类型，实际开发中许多问题的数据结构都可以抽象成二叉树，并且其存储结构和算法都比较简单
那么二叉树最主要的特点就是每个结点最多有两颗子树，且有左右之分，分别为左子树和右子树。二叉树是N个有限元素的集合，该集合或者为空、
或者由一个称为根（root）的元素及两个不相交的、被分别称为左子树和右子树的二叉树组成。

#### 2.1 二叉树分类
* (1)满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树
* (2)完全二叉树：

    1.若设二叉树的高度为a(总共有a层)，除了最后一层a层外，其他1到a-1层的结点数都达到了最大个数；
    2.a层有叶子结点，并且叶子结点都是从左到右依次排布的，可以排不满，但是必须是从左到右的顺序排序的；
    3.如果排满了这个树也就变成满二叉树了。【满二叉树一定是完全二叉树】【完全二叉树不一定是满二叉树】
* (3.二叉查找树（二叉搜索树/排序二叉树）        

    1.所有子树上面左子树的值都比根结点上的值要小，所有子树上面右子树的值都比根结点上的值要大；
    2.任意结点的左右子树又都是二叉查找树。通过中序遍历二叉查找树可以得到一个有序的集合(递增)；
    
* (4).平衡二叉树

    1.满足查找二叉树的条件；它左右两个子树的高度差的绝对值不超过1，并且左右子树又都是平衡二叉树；
    2.当修改/新增/删除结点上的值时，它会通过左旋/右旋的方式使二叉树保持平衡，
    3.最坏的时间复杂度是O(log2n)。常见的平衡二叉树有AVL树、红黑树等

* (5).AVL树

    1.首先本身是一个二叉查找树；
    2.带有平衡条件：每个结点的左右子树的高度之差的绝对值（平衡因子）最多为1。
    3.也可以说AVL树本质是一个带有平衡功能的查找树，增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。

* (6).红黑树

    1. 满足二叉查找树的特点；
    2.节点是红色或者是黑色的；
    3.根结点一定是黑色的；
    4.每个叶子结点都是黑色的(叶子是NIL节点,NIL代表空结点)；
    5.每个红色节点必须有两个黑色节点。
    6.最重要的是对于每个结点，从该结点到子孙叶结点的所有路径包含相同数目的黑节点

#### 2.2 二叉树存储方式
* 数组: 用数组存和访问速度快，但插入/删除操作就比较费时了
* 链表: 实际中更多的是用链来表示二叉树的。

#### 2.3 二叉树遍历方式

* 1. 前序遍历：根结点->左子树->右子树
* 2. 中序遍历：左子树->根结点->右子树
* 3. 后序遍历: 左子树->右子树->根结点
* 4. 层序遍历：按照层级顺序


## 三、典型
#### 3.1 用递归算法计算1-100相加的和    

        -(int)funcTest:(int)num {
            if (num > 1) { //递归条件
                return num + [self funcTest:num -1];
            }
            return num;
        }
* 每次递归调用，系统都要为该次调用分配一系列的栈空间用于存放此次调用的相关信息：返回地址，局部变量等
* 当调用完成时，就从栈空间内释放这些单元，在该函数没有完成前，分配的这些单元将一直保存着不被释放
* 递归调用容易导致栈溢出

#### 3.2 如何判断一个链表是否是循环链表： 

        //方式一: 快慢指针法
        class WGNode {
            var val: Int
            var next: WGNode?
            init(val: Int) {
                self.val = val
                self.next = nil
            }
            // 是否是循环链表: 采用快慢指针法
            func isCycle(head: WGNode?) -> Bool {
                if head == nil {
                    return false
                }
                var slow = head
                var fast = head
                while slow != nil && fast != nil {
                    slow = head?.next
                    fast = head?.next?.next
                    if slow === fast {
                        return true
                    }
                }
                return false
            }
        }
        
        //方式二: 标记法
        class WGNode {
            var val: Int
            var next: WGNode?
            //标记当前节点是否已经访问过了
            var hasVisit: Bool = false
            init(val: Int) {
                self.val = val
                self.next = nil
            }
            // 是否是循环链表: 采用快慢指针法
            func isCycle(head: WGNode?) -> Bool {
                if head == nil {
                    return false
                }
                var currentNode = head
                while currentNode != nil {
                    if currentNode!.hasVisit {
                        return true
                    }
                    currentNode!.hasVisit = true
                    currentNode = currentNode!.next
                }
                return false
            }
        }










































