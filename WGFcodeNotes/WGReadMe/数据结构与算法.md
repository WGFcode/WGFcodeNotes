## 数据结构与算法
#### 1。什么是算法？
#### 算法就是用于解决特定问题的一系列的执行步骤；使用不同的算法，解决同一个问题，效率可能相差非常大

#### 1.1如何评判一个算法的好快
1.正确性、可读性、健壮性(对不合理输入的反应能力)          
2.时间复杂度：估算程序指令的执行次数（执行时间）            
3.空间复杂度：估计所需占用的存储空间             

#### 1.2 大O表示法
#### 一般使用大O表示法来描述复杂度，它表示的数数据规模n对应的复杂度;大O表示法仅仅是一种粗略的分析模型，能帮助我们在短时间内了解一个算法的执行效率

    9---------->O(1)
    2n+3---------->O(n)
    n^2+2n+6---------->O(n^2)
    4log2n+25---------->O(logn)
    2^n---------------->O(2^n)
    O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)
#### 1.3 算法的优化方式
* 用尽量少的存储空间
* 用尽量少的执行步骤（执行时间）
* 根据情况，可以空间换时间；时间换空间

#### 2. 什么是数据结构
#### 数据结构是计算机存储、组织数据的方式，主要分为以下三种
1. 线性结构：线性表（数组、链表、栈、队列、哈希表）
2. 树形结构：二叉树、AVL树、红黑树、B树、堆、哈夫曼树、并查集
3. 图形结构：领接矩阵、领接表

#### 3 线性表
#### 3.1 数组
#### 数组是一种顺序存储的线性表，所有元素的内存地址是连续的；数组有个致命的缺点：无法动态修改容量，实际开发中，我们是希望数组的容量是可以动态改变的
#### 什么是数据结构?计算机存储以及组织数据的方式;简单理解为,有一堆数据,它们之间有些特殊的关系
#### 什么是算法？算法是用于解决特定问题的一系列的执行步骤；使用不同算法，解决同一个问题，效率可能差别比较大

#### 1. 数据结构逻辑上的分类
1. 集合结构: 一个集合中有多个元素,元素与元素之间没有任何关系-->**NSSet、NSMutableSet**
2. 线性结构: 一条线上有很多元素（直线、曲线），元素与元素之间是一对一的关系-->**NSArray、NSMutableArray**
3. 树形结构: 想象成金字塔的一种结构，其元素之间是一对多的关系
4. 图形结构: 无穷、无边、无向，任意图形，其元素之间是多对多的关系

#### 2. 数据结构存储上的分类
1. 顺序存储结构: 存储单元内存地址是连续的; 遍历快、查找快、效率高
2. 链式存储结构: 存储单元内存地址可以是连续的，也可以是不连续的。它不要求逻辑上相邻的元素在物理位置上也相邻; 添加快、删除快

#### 3. 常见的数据结构
* 线性表(数组、栈、队列、链表、哈希表)
* 树
* 图


## 线性表
#### 线性表就是多个具有相同特性的数据元素(节点)组成的有序、有限的集合; 当线性表的节点个数为0时,称为空表; 线性表第一个节点称为**首节点**,最后一个元素称为**尾节点**

####  线性表的存储结构有两种
* 线性表的顺序存储结构: 用一组地址连续的存储单元依次存储线性表的数据元素, 例如**数据** 
* 线性表的链式存储结构: 用一组任意的存储单元存储线性表中的数据元素，它的存储单元可以是连续的，也可以是不连续的


#### 1. 线性表-数组
#### 数组是顺序存储的,数组中的元素存储在一块连续的内存地址中,数组是直接通过下标来查找、删除、插入元素的; 数组是**查询快、增删慢**的数据结构,查询直接通过下标查询即可,查询任意数据耗时相同,时间复杂度为O(1); 但是如果删除元素的话,要先将原始数据删除,同时删除元素后面的每个元素前移,删除效率低; 添加数据时,添加元位置后的每个元素后移,再添加元素,添加效率极低
#### 动态数组有个明显的缺点：可能会造成内存空间的大量浪费

#### 2 线性表-栈
#### 栈可以理解为只能在一端进行插入、删除的数据结构,栈的特点就是**先进后出**,或者叫做**后进先出**,例如我们生活中盛放物品的箱子,先放进去的最后才能拿出来,后放进去的可以最先拿出来, 主要涉及到**压/进栈**和**弹/出栈**, 栈低是封闭的,栈顶是开放的,即只能在栈顶进行数据操作; 出栈和进栈只会影响到最后一个元素

#### 3 线性表-队列
#### 队列在iOS中是一种常见的数据结构,例如NSOpeartionQueue、GCD中的各种队列,其特点就是**先进先出**,或者叫**后进后出**,例如我们生活中的排队买票,先进去买票的先出来,后进去的后出来; 主要涉及到**入队列**和**出队列**, 入队列的方向称为后端,出队列的方向称为前端

#### 4 线性表-链表
#### 链表是在物理上非连续、非顺序的数据结构,由若干个节点组成, 主要分为两种
1. 单向链表: 每个节点有两部分组成,一部分是存放数据的变量data; 一部分是指向下一个节点的指针next

        头节点                                                                        ^节点指向空地址表示结束
        [head+地址11] ---> [数据13+地址35] ---> [数据4+地址9] ---> [数据19+地址289] ---> ...... ---> [数据23+^]
2. 双向链表:  除了**data**和**next**指针,还有指向前置节点的 prev 指针
3. 循环链表: 类似于单链表，也是一种链式存储结构，循环链表由单链表演化过来。单链表的最后一个结点的链域指向NULL，而循环链表的建立，不要专门的头结点，让最后一个结点的链域指向链表结点。
#### 循环链表与单链表的区别
1. 链表的建立。单链表需要创建一个头结点，专门存放第一个结点的地址。
单链表的链域指向NULL。而循环链表的建立，不要专门的头结点，让最后一个结点的链域指向链表的头结点。
2. 链表表尾的判断。单链表判断结点是否为表尾结点，只需判断结点的链域值是否是NULL。如果是，则为尾结点；否则不是。而循环链表盘判断是否为尾结点，则是判断该节点的链域是不是指向链表的头结点。

#### 链表是一种**增删快、查询慢**的数据结构(对比数组来说的),查询数据必须从头开始查找,链表查找的时间复杂度为O(n); 链表数据在内存中是随机存储,即每个节点分布在内存的不同位置,依靠**next**指针关联起来; 链表中的数据只能按照指针的方向进行顺序访问; 适合插入、删除操作比较频繁的场景

#### 5 线性表-哈希表
#### 哈希表也叫散列表,本质上是一个数组,提供了键(key)和值(value)的映射关系,这里有两个重要的概念
1. 哈希函数: 通过哈希函数,可以把字符串或其它类型的**Key**,转化成数组的下标**index**
2. 哈希冲突: 不通的**Key**通过**哈希函数**获得的下标有可能相同
#### 哈希表的基本操作
1. 写操作: 在表中插入新的键值对
2. 读操作: 通过给定的**Key** 在哈希表中查找对应的**Value**

#### 哈希表本质是一个数组,数组中每个元素称为**箱子**, 箱子中存放的是键值对,数组长度即箱子的长度,哈希表还有一个重要的属性叫**负载因子**,用来衡量哈希表的空/满程度,负载因子一定程度上可以体现查询的效率(负载因子=总键值对数/箱子个数),负载因子越大,意味着哈希表越满,越容易导致冲突,性能也就越低,因此,一般情况下,负载因子大于3/4(0.75)时,哈希表会自动扩容

#### 哈希表在扩容的时候,一般会创建2倍于原来个数的箱子,因此即使Key的哈希值不变,对箱子个数的取余的结果也会发生改变,因此所有键值对的存放位置都有可能发生改变,这个过程也称为重哈希(rehash)。哈希表的扩容并不总是能够有效解决负载因子过大的问题。假设所有 key 的哈希值都一样，那么即使扩容以后他们的位置也不会变化。虽然负载因子会降低，但实际存储在每个箱子中的链表长度并不发生改变，因此也就不能提高哈希表的查询性能。

#### 哈希表的问题
1. 如果哈希表中本来箱子就比较多，扩容时需要重新哈希并移动数据，性能影响较大。
2. 如果哈希函数设计不合理，哈希表在极端情况下会变成线性表，性能极低。



#### 5.1 哈希冲突解决方案
       例如 h(k)=k%7, h(0)=h(7)=h(14)=...
1. 开放寻址法: 如果哈希函数返回的位置已经有值,则可以向后查找新的位置来存储这个值,这种方式一般不采用,主要是hash表满了,就没有空间了
2. 拉链法: 哈希表每个位置都连接一个链表，当冲突发生时，冲突的元素将被加到该位置链表的最后。查找的时候，先找到hash函数计算的位置，再在链表里找

#### 6. 线性表性能对比
            查找        更新      插入     删除
    数组     O(1)       O(1)     O(n)    O(n)
    链表     O(n)       O(1)     O(1)    O(1)
    栈       -           -       O(1)    O(1)
    队列                         O(1)    O(1)
    哈希表   O(1)       O(1)      O(1)    O(1)
    


## 二叉树
#### 二叉树是树形结构的一种重要类型，在实际开发中许多问题的数据结构都可以抽象成二叉树，并且其存储结构和算法都比较简单，所以开发中二叉树相当重要。那么二叉树最主要的特点就是每个结点最多有两颗子树，且有左右之分，分别为左子树和右子树。二叉树是N个有限元素的集合，该集合或者为空、或者由一个称为根（root）的元素及两个不相交的、被分别称为左子树和右子树的二叉树组成。
## 二叉树分类
### 1.满二叉树
#### 如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树
### 2.完全二叉树
#### 若设二叉树的高度为a(总共有a层)，除了最后一层a层外，其他1到a-1层的结点数都达到了最大个数，而a层有叶子结点，并且叶子结点都是从左到右依次排布的，可以排不满，但是必须是从左到右的顺序排序的；如果排满了这个数也就变成满二叉树了。所以我们可以说满二叉树一定是完全二叉树，但是完全二叉树不一定是满二叉树
### 3.二叉查找树（二叉搜索树/排序二叉树）
#### 所有子树上面左子树的值都比根结点上的值要小，所有子树上面右子树的值都比根结点上的值要大，任意结点的左右子树又都是二叉查找树。通过中序遍历二叉查找树可以得到一个有序的集合(递增)
### 4. 平衡二叉树
#### 满足查找二叉树的条件；它左右两个子树的高度差的绝对值不超过1，并且左右子树又都是平衡二叉树；当修改/新增/删除结点上的值时，它会通过左旋/右旋的方式使二叉树保持平衡，最坏的时间复杂度是O(log2n)。常见的平衡二叉树有AVL树、红黑树等

### 5. AVL树
#### 首先它本身是一个二叉查找树；带有平衡条件：每个结点的左右子树的高度之差的绝对值（平衡因子）最多为1。也可以说AVL树本质是一个带有平衡功能的查找树，增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。

### 6.红黑树
#### 满足二叉查找树的特点；节点是红色或者是黑色的；根结点一定是黑色的；每个叶子结点都是黑色的(叶子是NIL节点,NIL代表空结点)；每个红色节点必须有两个黑色节点。最重要的是对于每个结点，从该结点到子孙叶结点的所有路径包含相同数目的黑节点


## 二叉树存储方式
#### 二叉树存储方式主要是数组和链表两种存储方式，用数组存和访问速度快，但插入/删除操作就比较费时了。实际中更多的是用链来表示二叉树的。

## 二叉树遍历
### 二叉树遍历方式分为：
#### 1. 前序遍历：根结点->左子树->右子树
#### 2. 中序遍历：左子树->根结点->右子树
#### 3. 后序遍历: 左子树->右子树->根结点
#### 4. 层序遍历：按照层级顺序

## 代码实现二叉树基本操作


## 算法
#### 1. 递归算法
#### 递归是借助于系统栈来实现的。每次递归调用，系统都要为该次调用分配一系列的栈空间用于存放此次调用的相关信息：返回地址，局部变量等。当调用完成时，就从栈空间内释放这些单元，在该函数没有完成前，分配的这些单元将一直保存着不被释放。
#### 1.1 用递归算法计算1-100相加的和
        - (void)viewDidLoad {
            [super viewDidLoad];
            int totalNum = [self testSum:100];
            NSLog(@"1-100相加的和是:%d",totalNum);
        }

        -(int)testSum:(int)num {
            if (num > 1) { //递归条件
                return num + [self testSum:num-1];
            }else { //基线条件:指的是函数不再调用自己，从而避免形成无限循环
                return num;
            }
        }
#### 这种一层一层的深入就是普通的递归,但是当数值比较大的时候,比如10000000,程序会crash,原因就是每次对于testSum的递归调用,系统都会通过一种**栈帧**的东西去管理和分配栈空间,不断调用会导致调用过程越来越慢而且容易出现栈空间的耗尽(栈溢出), 虽然使用递归可以使代码结构层次更清晰使程序更简洁,但是也存在一定的危险; 
#### 为了避免内存溢出和重复创建分配内存以及出现死循环情况,可以使用以下方法来避免
1. 简单粗暴，不要使用递归，使用循环替代。缺点：代码逻辑不够清晰；
2. 限制递归次数；
3.使用尾递归，尾递归是指在方法返回时只调用自己本身，且不能包含表达式。编译器或解释器会把尾递归做优化，使递归方法不论调用多少次，都只占用一个栈帧，所以不会出现栈溢出。然鹅，Java没有尾递归优化。


