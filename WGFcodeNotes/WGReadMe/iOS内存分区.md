## iOS内存分配和分区
### 1. iOS内存分区(由高到低顺序)
1. 栈区(stack):
* 栈是一块连续的内存区域，遵循先进后出(FILO)原则，方便用来函数跳转地址/保存调用现场/恢复调用现场
* 栈区一般由编译器在运行时自动分配并释放的,不会产生内存碎片，访问快速高效；栈区地址是从高到低分配
* 栈区存储局部变量、函数参数，出了作用域就会被销毁
* 栈的内存大小有限制，数据不灵活(iOS主线程栈大小是1MB、其他主线程是512KB、MAC只有8M)

2. 堆区(heap): 
* 堆是不连续的内存区域，类似于链表结构(便于增删，不便于查询)，遵循先进先出(FIFO)原则，内存分配靠遍历链表查找
* 堆是用于存放进程运行中被动态分配的内存段,它的大小并不固定,可动态扩张或缩减，
* 堆的内存分配一般是在运行时，分配和释放需要程序员手动管理、速度慢、容易产生内存碎片；堆是向高地址扩展的数据结构，
* 当调用alloc、new、malloc等函数分配内存时，新分配的内存就被动态添加到堆上，当利用realse释放内存时，被释放的内存从堆中被剔除
* 当需要访问堆中内存时，一般需要先通过对象读取到栈区的指针地址，然后通过指针地址访问堆区

3. 全局区(静态区)
* 全局区是编译时分配的内存空间，在程序运行过程中，此内存中的数据一直存在，程序结束后由系统释放
* 主要为全局变量和静态变量分配内存，包含未初始化的和已经初始化的两个部分
* 未初始化的全局变量和静态变量，即BSS区（.bss）
* 已初始化的全局变量和静态变量，即数据区（.data）
* static修饰的变量就是静态变量，该变量的内存在编译阶段完成分配，且仅分配一次。
* 全局变量是指变量值可以在运行时被动态修改，而静态变量是static修饰的变量，包含静态局部变量和静态全局变量

4. 常量区
* 常量区是在编译时分配内存空间的，在程序运行过程中，此内存中的数据一直存在，程序结束后由系统释放
* 专门用于存放常量(字符串)等，程序结束后由系统释放

5. 代码区
* 通常是指用来存放程序执行代码的一块内存区域。
* 代码区的内存大小在程序运行前就已经确定，并且内存区域通常属于只读,某些架构也允许代码段为可写，即允许修改程序
* 在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。
#### 当app启动后，代码区、常量区、全局区(静态区)大小已固定，程序结束后由系统释放，所以指向这些区的指针不会产生崩溃性的错误，但堆和栈区就不同了，堆区和栈区内存是时刻变化的(堆的创建销毁，栈的弹入弹出),所以开发中一般关注栈区和堆区；如下是内存分区图

                                      |---全局(静态)区-|
    栈                 堆              BSS段      数据段          常量区       代码区
    高地址------------------------------------------------------------------->低地址           
    从高到低分配->    从低到高分配<-   BSS:未初始化的全局变量和静态变量          
                                  数据段:已经初始化的全局变量和静态变量
#### 数据段中包含只读数据段(常量区)和读写数据段(已经初始化的全局变量和静态变量),所以我们知道内存分区可能有2种分法
1. 栈区、堆区、全局(静态区)、常量区、代码区
2. 栈区、堆区、BSS段(未初始化的全局变量和静态变量)、数据段(只读数据段(常量区)和读写数据段(初始化的全局变量和静态变量))、代码区

### 2 堆和栈区别
1. 分配方式不同：栈区由编译器自动分配和释放；堆区是由程序员来分配和释放
2. 栈区内存由编译器分配和释放，在函数执行时分配，在函数结束时收回。只要栈区剩余内存大于所申请的内存，那么系统将为程序提供内存
3. 系统有一个存放空闲内存地址的链表，当程序员申请堆内存的时候，系统会遍历该链表，找到第一个内存大于所申请内存的堆节点，并把这个堆节点从链表中移除。由于这块内存的大小很多时候不是刚刚好所申请的一样大，所以剩余的那一部分还会回到这个空闲链表中(内存碎片)。
4. 申请大小的限制： 栈区是向低地址扩展的数据结构，栈的容量一般是2M，当申请的栈内存大于2M时就会出现栈溢出，可分配的空间比较小
5. 申请大小的限制： 堆是向高地址扩展的数据结构，是不连续的。堆的大小受限于计算机系统中有效的虚拟空间，因此堆可分配的空间比较大
6. 栈：栈由系统自动分配、速度较快，但是不受程序员控制；堆：堆是由alloc分配的内存、速度较慢，并且容易产生内存碎片。


### 3. 内存泄漏、内存溢出
* 内存泄漏: 是指申请的内存空间使用完毕之后未回收
* 内存溢出: 是指程序在申请内存时，没有足够的内存空间供其使用(通俗内存不够用了)。


### 4. iOS中变量-OC
#### iOS中存储方式有以下两种
1. 静态存储方式: 程序一开始运行时就分配存储空间,从程序开始运行到程序结束，存储空间都保持不变的存储方式。
2. 动态存储方式: 程序在运行时，需要使用时才分配存储空间，不需要使用时立即释放的存储方式

#### iOS中变量需要从存储方式、生命周期、作用域来详细研究它们,变量分类主要有4种
1. 全局变量
* 静态存储，存放在全局(静态)区；
* 静态存储方式决定了它的生命周期为**从程序运行开始到结束**
* 作用域是整个程序的所有文件
2. 局部变量
* 动态存储，存放在栈区(数据类型)或堆区(对象类型)
* 动态存储方式决定了它的生命周期为**变量使用期间**
* 作用域是方法或函数体结束

3. 静态全局变量
* 静态存储，存放在全局(静态)区；
* 静态存储方式决定了它的生命周期为**从程序运行开始到结束**
* 作用域是只有申明该变量的文件才可以访问到

4. 静态局部变量
* 静态存储，存放在全局(静态)区；
* 静态存储方式决定了它的生命周期为**从程序运行开始到结束**
* 作用域是方法或函数体结束

#### 总结如下
* 存储方式：全局变量/静态全局变量/静态局部变量是静态存储，都存放在全局(静态)区；局部变量是动态存储,存放在堆区或栈区；
* 生命周期：全局变量/静态全局变量/静态局部变量是**从程序运行开始到结束**；局部变量是在函数或方法体内；
* 作用域: 全局变量是整个工程的所有文件；全局静态变量只能在声明所在的文件内访问；局部变量和静态局部变量是在函数或方法体内；
* static作用有两个：第一个是改变全局变量的作用域，第二个是改变局部变量的生命周期


#### 5. 堆栈溢出
#### 一般情况下应用程序是不需要考虑堆和栈的大小的，但是事实上堆和栈都不是无上限的，过多的递归会导致栈溢出，过多的alloc变量会导致堆溢出，预防堆栈溢出的方法
* 避免层次过深的递归调用；
* 不要使用过多的局部变量，控制局部变量的大小；
* 避免分配占用空间太大的对象，并及时释放;
* 实在不行，适当的情景下调用系统API修改线程的堆栈大小；
