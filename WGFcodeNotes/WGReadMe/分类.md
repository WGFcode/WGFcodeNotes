## 分类Category底层原理
#### 面试题总结
1. 分类Category的实现原理?,分类为什么只能添加方法不能添加成员变量?
### 实现原理就是分类中所有的信息(方法/属性/协议)都包装在Category_t的结构体中,然后在运行时拷贝到类对象中去的; 为什么不能添加成员变量? 首先就是Category_t结构体中没有存放成员变量的变量,其次就是成员变量在编译期内存布局都已经确定了,存放在对象结构体里面了,所以运行时是无法添加的
2. Category中有load方法吗?load方法什么时候调用?load方法能继承吗?
3. load,initialize在Category中的调用顺序?以及出现继承时他们之间的调用过程?
4. load,initialize的却别,以及它们在Category充写时的调用次序?

#### 1. 分类作用
####  分类可以给已经存在的类(系统类/自定义类)扩充指定的方法, 分类是在运行时加载的,

#### 2. 分类中方法
#### 我们知道对象的方法是存放在类对象中的,而分类中的方法也是存在类对象中的

        //Person.h文件
        @interface Person : NSObject
        //实例方法
        -(void)run; 
        @end

        //Person.m文件
        @implementation Person
        //实例方法
        -(void)run {
            NSLog(@"run");
        }
        @end
        
        Person分类WGPersonCategory的.h文件
        @interface Person (WGPersonCategory)
        //实例方法
        -(void)test;
        //类方法
        +(void)abcd;
        @end
        
        Person分类WGPersonCategory的.m文件
        @implementation Person (WGPersonCategory)
        //实例方法
        -(void)test {
            NSLog(@"test");
        }
        //类方法
        +(void)abcd {
            NSLog(@"abcd");
        }
        @end
        
        //方法调用
        - (void)viewDidLoad {
            [super viewDidLoad];
            
            Person *p = [[Person alloc]init];
            [p run];   //调用的是Person的对象(实例)方法
            [p test];  //调用的是Person分类中的对象(实例)方法
        }
        
#### 实例方法: 无论调用对象p的实例方法还是对象p的分类中的实例方法,其本质都是通过对象p的isa指针找到Person类对象,而对象的实例方法和对象分类中的实例方法都是存放在Person类对象中的

#### 类方法: 对象的类方法是放在对象的元类对象中的,而分类中的类方法也是存放在对象的元类对象中的,都是通过isa找到对应的类方法的


#### 3. 分类底层结构
#### 通过RunTime源码找到分类结构
        struct category_t {
            const char *name;       //分类名称
            classref_t cls;         //分类是属性哪个类的
            struct method_list_t *instanceMethods;           //实例方法列表
            struct method_list_t *classMethods;              //类方法列表
            struct protocol_list_t *protocols;               //协议列表
            struct property_list_t *instanceProperties;      //属性
            // Fields below this point are not always present on disk.
            struct property_list_t *_classProperties;

            method_list_t *methodsForMeta(bool isMeta) {
                if (isMeta) return classMethods;
                else return instanceMethods;
            }

            property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);
        };
#### 通过源码我们知道分类可以添加属性/实例方法/类方法/遵守协议,同时我们也发现源码中并没有ivar这个属性,说明分类中不能添加成员变量,但是可以添加属性,但是添加的属性,系统并不会为我们生成对应的成员变量
        @interface Person (WGPersonCategory) <NSCopying>  //遵守协议

        -(void)test;    //实例(对象)方法
        +(void)abcd;    //类方法
        //系统不会为我们自动生成属性对应的成员变量_name
        @property(nonatomic, strong) NSString *name;  //属性
        //分类中声明的属性,系统只会帮我们生成对应的getter/setter方法的声明,上面代码相当于下面的两行代码,但是并不会生成getter/setter实现,getter/setter实现也需要我们自己去实现
        -(void)setName:(NSString * _Nonnull)name;
        -(NSString * _Nonnull)name;

        @end

#### 3.1 我们如何验证分类中的方法/属性是在对应的类对象中哪?
#### 我们通过以下命令行,将指定的.m文件转为C++源码来看一下
1. 首先命令行cd到工程目录
2. xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc Person+WGPersonCategory.m

#### 我们在Person+WGPersonCategory.cpp文件中找到了如下代码
    static struct _category_t _OBJC_$_CATEGORY_Person_$_WGPersonCategory __attribute__ ((used, section ("__DATA,__objc_const"))) = {
        "Person",
        0, // &OBJC_CLASS_$_Person,
        (const struct _method_list_t *)&_OBJC_$_CATEGORY_INSTANCE_METHODS_Person_$_WGPersonCategory,
        (const struct _method_list_t *)&_OBJC_$_CATEGORY_CLASS_METHODS_Person_$_WGPersonCategory,
        (const struct _protocol_list_t *)&_OBJC_CATEGORY_PROTOCOLS_$_Person_$_WGPersonCategory,
        (const struct _prop_list_t *)&_OBJC_$_PROP_LIST_Person_$_WGPersonCategory,
    };
    //实例方法列表 
    static struct /*_method_list_t*/ {
        unsigned int entsize;  // sizeof(struct _objc_method)
        unsigned int method_count;
        struct _objc_method method_list[1];
    } _OBJC_$_CATEGORY_INSTANCE_METHODS_Person_$_WGPersonCategory __attribute__ ((used, section ("__DATA,__objc_const"))) = {
        sizeof(_objc_method),
        1,
        {{(struct objc_selector *)"test", "v16@0:8", (void *)_I_Person_WGPersonCategory_test}}
    };
    //类方法列表
    static struct /*_method_list_t*/ {
        unsigned int entsize;  // sizeof(struct _objc_method)
        unsigned int method_count;
        struct _objc_method method_list[1];
    } _OBJC_$_CATEGORY_CLASS_METHODS_Person_$_WGPersonCategory __attribute__ ((used, section ("__DATA,__objc_const"))) = {
        sizeof(_objc_method),
        1,
        {{(struct objc_selector *)"abcd", "v16@0:8", (void *)_C_Person_WGPersonCategory_abcd}}
    };
    //协议列表
    static struct /*_protocol_list_t*/ {
        long protocol_count;  // Note, this is 32/64 bit
        struct _protocol_t *super_protocols[1];
    } _OBJC_CATEGORY_PROTOCOLS_$_Person_$_WGPersonCategory __attribute__ ((used, section ("__DATA,__objc_const"))) = {
        1,
        &_OBJC_PROTOCOL_NSCopying
    };
    //属性列表
    static struct /*_prop_list_t*/ {
        unsigned int entsize;  // sizeof(struct _prop_t)
        unsigned int count_of_properties;
        struct _prop_t prop_list[1];
    } _OBJC_$_PROP_LIST_Person_$_WGPersonCategory __attribute__ ((used, section ("__DATA,__objc_const"))) = {
        sizeof(_prop_t),
        1,
        {{"name","T@\"NSString\",&,N"}}
    };

#### 总结: 通过上面我们分类中定义的属性/实例方法/对象方法/遵守的协议这些分类中信息都存放在_category_t的结构体中,接下来我们来通过RunTime源码来继续看看系统是如何将_category_t结构体中的分类信息添加到类对象中的

#### RunTime源码->Source->objc-os.mm
    //1. 运行时初始化,通过dyld进行加载的
    1. void _objc_init(void){..._dyld_objc_notify_register(&map_images, load_images, unmap_image);...} 
    2.void map_images(unsigned count, const char * const paths[], const struct mach_header * const mhdrs[]) {...
        return map_images_nolock(count, paths, mhdrs);
     }
     3. void map_images_nolock(unsigned mhCount, const char * const mhPaths[], const struct mach_header * const mhdrs[]) { ...
        if (hCount > 0) {
            _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses);
        }...
    }
    4. void _read_images(header_info **hList, uint32_t hCount, int totalClasses, int unoptimizedTotalClasses)
    {...  
        remethodizeClass(cls);
    }
    5. static void remethodizeClass(Class cls) {... 
        //附加分类 传递进行参数是分类所属的类, 分类列表(其实是个数组,假如一个类有多个分类,那么就会有多个_category_t结构体,多个_category_t结构体组成了category_list分类列表)  
        attachCategories(cls, cats, true /*flush caches*/); 
    ... }
    6. static void attachCategories(Class cls, category_list *cats, bool flush_caches) {...
        //malloc方法列表 malloc分配内存
        method_list_t **mlists = (method_list_t **)
              malloc(cats->count * sizeof(*mlists));
        property_list_t **proplists = (property_list_t **)
              malloc(cats->count * sizeof(*proplists));
        protocol_list_t **protolists = (protocol_list_t **)
              malloc(cats->count * sizeof(*protolists));
        ...
        while (i--) {
              // 从分类列表中取出分类,然后将对应的方法/属性/协议添加到对应的数组中mlists/proplists/protolists
              auto& entry = cats->list[i];
              method_list_t *mlist = entry.cat->methodsForMeta(isMeta);
              if (mlist) {
                  mlists[mcount++] = mlist;
                  fromBundle |= entry.hi->isBundle();
              }
              property_list_t *proplist = 
                  entry.cat->propertiesForMeta(isMeta, entry.hi);
              if (proplist) {
                  proplists[propcount++] = proplist;
              }
              protocol_list_t *protolist = entry.cat->protocols;
              if (protolist) {
                  protolists[protocount++] = protolist;
              }
          }
          ...
          /*通过这个方法,可以获取到类对象中的class_rw_t结构体,这个结构体中存放的就是对象的方法/属性/协议列表
          class_rw_t *data() { 
              return bits.data();
          }
          */
          auto rw = cls->data(); 
          
          // 将分类中的方法/属性/协议列表添加到类对象中的class_rw_t结构体中,
          prepareMethodLists(cls, mlists, mcount, NO, fromBundle);
          
          // 类对象的方法列表.attachLists(所有分类的方法列表,mcount)
          rw->methods.attachLists(mlists, mcount);
          free(mlists);
          if (flush_caches  &&  mcount > 0) flushCaches(cls);
          
          // 类对象的属性列表.attachLists(所有分类的属性列表,propcount)
          rw->properties.attachLists(proplists, propcount);
          free(proplists);
          
          // 类对象的协议列表.attachLists(所有分类的协议列表,protocount)
          rw->protocols.attachLists(protolists, protocount);
          free(protolists);
    }
    7. 接下来我们看分类中方法/属性/协议是如何添加到类对象的class_rw_t结构体中的
        /*
        array()->lists: 类对象原来的方法列表   addedLists: 所有分类的方法列表
        */
        void attachLists(List* const * addedLists, uint32_t addedCount) { ...
            if (hasArray()) {
                // many lists -> many lists
                uint32_t oldCount = array()->count;
                uint32_t newCount = oldCount + addedCount;
                setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));
                array()->count = newCount;
                // 内存移动
                memmove(array()->lists + addedCount, array()->lists, oldCount * sizeof(array()->lists[0]));
                // 内存拷贝
                memcpy(array()->lists, addedLists, addedCount * sizeof(array()->lists[0]));
            }
        }
        
        核心方法memmove和memcpy简化版
        //1.内存移动 将类对象原来的方法列表的内存移动到(类对象原来的方法列表+addedCount)这个内存地址, +addedCount其实就是
        //将指针向后移动多少位, addedCount其实表示的就是分类中所有方法列表的长度
        memmove(类对象原来的方法列表+addedCount, 类对象原来的方法列表, oldCount * sizeof(array()->lists[0]));
        
        
        //2. 内存拷贝 将分类中所有的方法列表拷贝到类对象的空余出来的方法列表内存中,其实就是添加到类对象方法列表的前面
        void *memmove(void *__dst, const void *__src, size_t __len);
        memcpy(类对象原来的方法列表, 所有分类的方法列表, addedCount * sizeof(array()->lists[0]));
#### 总结: 分类中所有的方法/属性/协议通过内存移动和内存拷贝后都存放在类对象对应的列表前面, 再次证明了,如果分类和对象中存在相同的方法,首先调用的是分类中的方法,因为查找方法最先调用的是类对象方法列表最前面出现的方法, 而方法列表中最前面的方法存放的是分类的方法, 即方法覆盖, 更严格的来说,并不是方法覆盖,而是优先调用了分类中的方法, 而原来类中的方法仍然存在类对象的方法列表中,只是分类中的方法调用的优先级更高

#### 3.2 分类和类中有相同的方法时,优先调用的是分类的方法,从上面结论中我们知道类中的方法是还存在的,那么如何证明哪?
        //1. 分类WGPersonCategory
        @interface Person (WGPersonCategory) 
        -(void)test;
        @end

        @implementation Person (WGPersonCategory)
        -(void)test {
            NSLog(@"分类WGPersonCategory中的方法");
        }
        @end

        //2. Person类
        @interface Person : NSObject
        -(void)test;
        @end

        @implementation Person
        -(void)test {
            NSLog(@"类Person中的方法");
        }
        @end
        
        - (void)viewDidLoad {
            [super viewDidLoad];
            Person *p = [[Person alloc]init];
            [p test];
            [self printMethodNameOfClass:[Person class]];
        }

        -(void)printMethodNameOfClass:(Class)cls {
            unsigned int count;
            // 获取方法数组
            Method *methodList = class_copyMethodList(cls, &count);
            // 存储方法名
            NSMutableString *methodNames = [NSMutableString string];
            // 遍历所有的方法
            for (int i = 0; i < count; i++) {
                // 获得方法
                Method method = methodList[i];
                // 获得方法名称
                NSString *methodName = NSStringFromSelector(method_getName(method));
                [methodNames appendString:methodName];
                [methodNames appendString:@","];
            }
            // 释放
            free(methodList);
            //打印方法名
            NSLog(@"%@类中的方法---%@",cls, methodNames);
        }
        
        打印结果:  分类WGPersonCategory中的方法
                 Person类中的方法---test,test,
#### 总结: 优先调用了分类中的test方法, 然后打印Person类中所有的方法时,打印结果显示有两个test方法,第一个是分类中的test方法,第二个就是原来Person类中的test方法
        

#### 3.3 假如两个分类都有相同的方法,那么哪个分类会优先执行哪?
        //1. WGPersonCategory分类
        @interface Person (WGPersonCategory) 
        -(void)test;
        @end

        @implementation Person (WGPersonCategory)
        -(void)test {
            NSLog(@"WGPersonCategory");
        }
        @end

        //2. WGPersonCategory111分类
        @interface Person (WGPersonCategory111) 
        -(void)test;
        @end

        @implementation Person (WGPersonCategory111)
        -(void)test {
            NSLog(@"WGPersonCategory111");
        }
        @end

        - (void)viewDidLoad {
            [super viewDidLoad];
            Person *p = [[Person alloc]init];
            [p test];
        }

        打印结果: WGFcodeNotes[23354:1553915] WGPersonCategory111
#### 总结: 多个分类中存放相同的方法时, 调用顺序是根据分类的编译优先级决定的, 编译优先级可以通过Target->Build Phases->Compile Sources查看,最靠上的编译优先级越高,从这里我们看到WGPersonCategory在最前面,所以编译优先级最高,但是打印的是WGPersonCategory111,所以我们得出结论: 编译优先级最低的分类中的方法优先调用, 因为我们知道后编译的方法列表是存放在类对象方法列表的最前面的, 所以优先调用; 我们也可以直接在Target->Build Phases->Compile Sources中手动来调整分类的编译优先级,拖动某个分类文件来移动它的顺序来设置编译优先级,这样我们就可以指定哪个分类的方法被优先调用了


### 4. Category中load方法
#### load方法是在程序启动的时候就会被调用,不管项目中用到没用到,如下验证
        //Person类
        @interface Person : NSObject
        +(void)load;
        @end

        @implementation Person
        +(void)load {
            NSLog(@"Person--load");
        }
        @end


        //Student类 继承自Person类
        @interface Student : Person
        +(void)load;
        @end

        @implementation Student
        +(void)load {
            NSLog(@"Student--load");
        }
        @end


        //Student的分类StudentCategory
        @interface Student (StudentCategory)
        +(void)load;
        @end

        @implementation Student (StudentCategory)
        +(void)load {
            NSLog(@"Student (StudentCategory)--load");
        }
        @end


        #import "WGMainObjcVC.h"
        #import <UIKit/UIKit.h>

        @implementation WGMainObjcVC
        - (void)viewDidLoad {
            [super viewDidLoad];
        }
        @end
        
        打印结果: Person--load
                Student--load
                Student (StudentCategory)--load
#### 总结, 我们在WGMainObjcVC类中都没有用到我们创建的Person/Student/StudentCategory,也没有import这些类,但是启动项目后仍然打印了这些类的load方法,说明load方法是在程序启动时被调用的,不管项目中是否用到了这些类,而且父类/本类/分类中的load方法都被调用了

#### 4.1 load方法在父类/子类/分类中的调用顺序是什么?
#### 我们先来看RunTime源码 -> objc-os.mm -> _objc_load_image -> call_load_methods
    void call_load_methods(void) { ...
        do {
            // 1. Repeatedly call class +loads until there aren't any more
            while (loadable_classes_used > 0) {
                call_class_loads();  /// 关键方法
            }

            // 2. Call category +loads ONCE
            more_categories = call_category_loads();

            // 3. Run more +loads if there are classes OR more untried categories
        } while (loadable_classes_used > 0  ||  more_categories);
    }
    
    static void call_class_loads(void) { ...
        // Call all +loads for the detached list.
        for (i = 0; i < used; i++) {
            Class cls = classes[i].cls;
            /// load_method就相当于load的内存地址
            load_method_t load_method = (load_method_t)classes[i].method;
            if (!cls) continue; 

            if (PrintLoading) {
                _objc_inform("LOAD: +[%s load]\n", cls->nameForLogging());
            }
            /// 拿到load的内存地址直接调用
            (*load_method)(cls, SEL_load);
        }
        // Destroy the detached list.
        if (classes) free(classes);
    }
    
#### 从上面源码我们可以看出load方法先调用的是类的load方法,然后调用的是分类的load方法,从源码分析上 我们还可以得出如下结论
1. 父亲/本类/本类的分类都有load方法,那么优先调用父类的load方法,然后调用本来的load方法,最后调用分类的load方法
2. 分类中的load方法也会被调用,因为load方法调用是直接拿到load的内存地址然后直接调用,不存在分类中类方法会覆盖本来方法的情况,原因就是load的调用机制走的不是消息发送机制


### 5. initialize方法
1. 当类第一接收到消息时就会被调用(第一次使用这个类时)
2. 会先调用父类的initialize方法,然后再调用当前类的initialize方法
3. 如果之前已经调用过initialize方法,就不会再调用进行初始化了,即initialize方法只会被调用一次
4. 如果父亲/本类/本类的分类都有initialize方法,那么优先调用父类的initialize方法,然后调用分类中的initialize方法,而本类中的initialize方法就不会被调用了, 前面我们知道了分类中的方法在运行时会被拷贝到类对象的方法列表前面,所以优先调用了分类中的方法, 而对于类方法同样的道理,分类中的类方法在运行时会被拷贝到元类对象的方法列表的前面,所以分类中的类方法被优先调用了,而initialize方法只会被初始化一次,所以分类中的initialize方法被调用后,本类中的initialize方法就不会被再次调用了
5. initialize方法调用时通过isa走的消息发送的机制,所以找到在元类对象的方法列表中优先调用分类中的initialize方法

#### 5.1 我们通过RunTime源码->Source->objc-initialize.mm
        void callInitialize(Class cls)
        {
            ((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);
            asm("");
        }
        #### 分析: 从源码中我们看到调用initialize方法,走的是objc_msgSend的消息发送机制,消息发送机制本质就是发送消息,然后通过对象的isa指针类对象,然后通过类对象的isa指针找到元类的方法列表,而分类中的initialize方法肯定是在类方法列表的前面,所以优先调用了分类中的initialize方法,而本类中的initialize方法就不会再被调用了
#### 6. load方法和initialize方法区别
1. load方法在程序启动时就被调用, 即使不使用这些类, load方法一样会被调用
2. load方法调用顺序: 父类->本类->分类, 为什么本类中的load方法被调用,因为load方法调用机制不是消息发送机制,而是找到load方法地址直接调用,所以不存在消息发送机制中的分类方法覆盖会本类中的方法的情况
3. initialize方法是在类第一次使用时调用的,只会被调用一次
4. initialize方法调用顺序: 父类->分类, 为什么本类没用调用initialize方法,因为initialize方法调用走的是消息发送机制,分类中的initialize方法会覆盖本类中initialize方法


### 7. 匿名分类 
#### 匿名分类 其实严格来说应该叫类扩展,只是有些地方叫做匿名分类,其实准确来说这并不是一个分类,因为它跟分类的原理根本不一样, 它只是对方法属性的私有化而已
        //在Person.m文件中这些写其实就是匿名分类
        @interface Person()
        //声明的成员变量必须写在{}里面,并且一定是在声明的属性和方法前面,声明的成员变量为了规范我们一般都是加下划线_XXX,
        成员变量不能用self访问
        {
            int age;
        }
        //这里可以写方法声明,但是这里不能写方法实现,匿名分类其实就是方法的私有化, 作用其实就是代码规范,
        我们进入Person.m文件后可以直接看到.m文件中那些方法是私有的
        -(void)setAge;
        //一般在这里我们都是声明属性,说明这个属性是私有的
        @property(nonatomic, strong) NSString *name;
        @end

        @implementation Person

        +(void)load {
            NSLog(@"Person--load");
        }

        @end

#### 总结: 匿名分类其实就是声明方法和属性,方法和属性都是私有的,声明方法其实就是为了代码规范,一般开发中我们经常在.m文件中添加 @interface Person() ... @end,然后在里面声明一些成员变量和属性,其实就是成员变量和属性的私有化
