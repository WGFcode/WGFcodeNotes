## 性能优化
#### 面试题
1. 你在项目中是怎么优化内存的?
2. 优化你从那几方面着手
3. 列表卡顿的原因有哪些? 你平时是怎么优化的
4. 遇到tabView卡顿吗? 会造成卡顿的原因大致有哪些?

#### 1. CPU和GPU
#### 在屏幕成像的过程中,CPU和GPU起着至关重要的作用
* CPU(中央处理器): 对象的创建和销毁、对象属性的调整、布局计算、文本的计算和排版、图片的格式转换和解码、图像的绘制
* GPU(图形处理器): 纹理的渲染

              计算         渲染          读取               显示
        CPU---------GPU---------帧缓存---------视频控制器---------屏幕
* 在iOS中是双缓存机制,有前帧缓存、后帧缓存
#### 1.1 屏幕成像原理
#### 屏幕显示图像过程是一帧一帧显示的, 当显示一帧画面时,会发出垂直同步信号(VSync),同时也会发出水平同步信号(HSync),当一帧的画面显示完成后循环再显示另一帧画面

#### 1.2卡顿产生的原因
#### 显示内容到屏幕上的过程是: 先通过CPU,然后CPU将计算的结果交给GPU处理,GPU处理完成后等待垂直同步信号(VSync),当垂直同步信号(VSync)到来时,将内容显示到屏幕上
#### 产生卡顿原因: CPU和GPU花费的时间太长,导致垂直同步信号(VSync)来的时候,计算和渲染操作还没有完成,这样就导致掉帧了,所以产生了卡顿

#### 1.2.1 卡顿解决的主要思路
* 尽可能减少CPU、GPU资源消耗
* 按照60FPS(每秒刷新60帧)的刷帧率,每隔16ms(1000毫秒%60)就会有一次垂直同步信号(VSync)

#### 2. 卡顿优化
#### 2.1 CPU优化
1. 尽量用轻量级的对象(如用不到事件处理的地方,可以考虑使用CALayer取代UIView)
2. 不要频繁的调整UIView的相关属性(如frame、bounds、transform等属性)尽量减少不必要的修改
3. 尽量提前计算好布局,在有需要时一次性调整对应的属性,不要多次修改属性
4. Autolayout会比直接设置frame消耗更多的CPU资源(如果对性能要求特别高,可以不用Autolayout)
5. 图片的size最好刚好和UIImageView的size保持一致(若不一致,CPU需要对图片进行伸缩处理)
6. 控制一下线程的最大并发数量
7. 尽量把耗时的操作放到子线程

        文本处理(尺寸计算、绘制)
        图片处理(解码、绘制)

        //文字计算
        [@"sdf" boundingRectWithSize:CGSizeMake(100, MAXFLOAT) options:NSStringDrawingUsesLineFragmentOrigin attributes:nil context:nil];
        //文字绘制
        [@"test" drawWithRect:CGRectMake(0, 0, 100, 100) options:NSStringDrawingUsesLineFragmentOrigin attributes:nil context:nil];
        //图片处理
        UIImageView *imgView = [[UIImageView alloc]init];
        通过这种方式加载图片,其实是不会直接显示到屏幕上的,加载的其实是经过压缩后的二进制数据
        如果要渲染到屏幕上,还需再经过解码,解码成屏幕需要的格式,而解码是放在主线程的,所以可能会产生卡顿
        可以把解码放在子线程,具体如何解码可以参考网上好多第三方的库中找到
        imgView.image = [UIImage imageNamed:@"test"];
        [self.view addSubview:imgView];
#### 2.2 GPU优化
1. 尽量减少视图数量和层次
2. 尽量避免短时间内大量图片的显示,尽可能将多张图片合成一张进行显示
3. GPU能处理的最大纹理尺寸是4096*4096,一旦超过这个尺寸,就会占用GPU资源进行处理,所以纹理尽量不要超过这个尺寸
4. 减少透明的视图(alpha < 1),不透明的就设置opaque为YES
5. 尽量避免出现离屏渲染

#### 2.3 离屏渲染
#### 在OpenGL中,GPU有两种渲染方式
1. On-Screen Rendering: 当前屏幕渲染,在当前用于显示的屏幕缓冲区进行渲染操作
2. Off-Screen Rendering: 离屏渲染,在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作

#### 离屏渲染消耗性能的原因? 
* 需要创建新的缓冲区
* 离屏渲染的整个过程,需要多次切换上下文环境,先是从当前屏幕(On-Screen)切换到离屏(Off-Screen);等到离屏渲染结束后,将离屏缓冲区的渲染结果显示到屏幕上,又需要将上下文环境从离屏切换到当前屏幕
#### 导致离屏渲染的操作有哪些?
1. 光栅栏(layer.shouldRasterize = YES)
2. 遮罩(layer.mask)
3. 圆角(同时设置layer.maskToBounds=YES,layer.cornerRadius大于0,才会触发离屏渲染),可以通过CoreGraphics绘制裁剪成圆角或者让美工提供圆角图片
4. 阴影(layer.shadowXXX)(如果设置了layer.shadowPath就不会产生离屏渲染)

### 3. 卡顿检测


