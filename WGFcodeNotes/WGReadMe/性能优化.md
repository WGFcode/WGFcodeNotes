## 性能优化

#### 性能优化涉及方面比较多，大的分类大概有以下几种
1. 卡顿优化
2. 启动优化
3. 内存相关优化
4. 耗电量优化
5. 安装包瘦身

5. 崩溃率优化
6. 网络流量优化
6. 安全性优化

<!--4. IO性能-->
<!--4. CPU/GPU-->
<!--5. 启动优化-->
<!--6. 包体积-->
<!--7. 性能分析-->
<!--8. 生成ipa包的过程-->

#### 背景概念    
* 应用交互前端UIKit/AppKit ->  Core Animation -> OpenGL ES/ Metal -> GPU Driver -> GPU -> Screen Display
* Core Graphics‌：又被称为(Quartz 2D)是一个2D图形渲染引擎;用于绘制图形、处理图像和创建PDF;基于CPU进行渲染，相对效率较低
* ‌Core Animation‌：是一个动画和图形渲染框架;基于GPU进行渲染，具有更高的性能和更平滑的动画表现‌

            ---------------------------------
            |         UIKit/AppKit          |
            |         Core Animation        |
            | Metal/OpenGL ES Core Graphics |
            |        Graphics Hardware      |
            ---------------------------------

#### 1. 卡顿优化
#### 1.1 iOS屏幕图像显示原理->(CPU和GPU起着至关重要的作用)
* CPU(中央处理器): 对象的创建和销毁、对象属性的调整、计算视图层次结构，布局、文本的绘制、图像解码以及 Core Graphics 绘制
* GPU(图形处理器): 处理图层合并、图像渲染、动画和 Metal 绘制
* CPU 负责准备数据；GPU 负责渲染这些数据
* CPU计算好显示内容提交到GPU，GPU渲染完成后将渲染结果放入帧缓冲区，视频控制器收到VSync信号后逐行读取帧缓冲区的数据，
经过一定的数模转换传递给显示器显示
* 屏幕刷新频率：Refresh Rate或Scanning Frequency，单位hz，是指设备刷新屏幕的频率。
* 帧率：Frame Rate，单位 fps，是指 GPU 生成帧的速率。

              计算         渲染          读取               显示
        CPU---------GPU---------帧缓存---------视频控制器---------屏幕
                                 |
                          前帧缓存  后帧缓存
* 单缓存效率低下并且容易导致画面撕裂问题

        GPU向缓存区中写入数据，视频控制器从缓存区中取图像数据后显示，理想的情况是帧率和屏幕刷新频率相等
        每绘制一帧，屏幕就显示一帧；而实际情况是，如果没有同步机制，当帧率大于屏幕刷新频率时，视屏控制器
        刚逐行读取完第2帧的上半部分时，GPU已经完成第3帧的渲染并提交到缓存区中，视屏控制器会继续读取第三帧
        的下半部，这样会造成画面撕裂
    
* 在iOS中是双缓存区+VSync(垂直同步信号)机制,有前帧缓存、后帧缓存，提高渲染效率

        1.GPU 会预先渲染好一帧放入一个缓存区内(前帧缓存);
        2.显示器发出VSync后,视频控制器的指针会指向前帧缓存区并开始读取,GPU开始渲染下一帧,并将渲染结果放入另一个缓存区(后帧缓存);
        3.显示器发出新的VSync后,视频控制器的指针会指向后帧缓存区并开始读取，GPU开始渲染下一帧，并将渲染结果放入前帧缓存区。
        问题: 若在一个Vsync时间内，CPU或GPU没有完成内容提交，则那一帧就会被废弃，而此时显示器会保留之前的内容不变，造成界面卡顿

* 显示器的电子枪是从上到下进行逐行扫描的，扫描完成后显示器就呈现一帧画面，随后电子枪回到初始位置继续下一次扫描。
* 为了把显示器的显示过程和系统的视频控制器进行同步，显示器（或者其他硬件）会用硬件时钟产生一系列的定时信号
* 显示器通常以“固定频率“进行刷新(屏幕刷新率)，这个刷新率就是VSync信号产生的频率
* iOS设备的屏幕刷新频率是每秒60帧，平均每16.67ms发出一个VSync。

    HSync：
    当电子枪换到新的一行,准备进行扫描时,显示器会发出一个水平同步信号,简称HSync(horizonal synchronization)
    VSync：
    当一帧画面绘制完成后,电子枪回复到原位,准备画下一帧前,显示器会发出一个垂直同步信号,简称VSync(vertical synchronization)
    
#### 1.2 卡顿产生额原因
* CPU计算和GPU渲染花费的时间太长,导致垂直同步信号(VSync)来的时候,计算和渲染操作还没有完成
* 按照60FPS(每秒刷新60帧)的刷帧率,每隔16ms(1000毫秒%60)就会有一次垂直同步信号(VSync)

#### 1.3 卡顿优化方案
* 卡顿优化-CPU
* 卡顿优化-GPU
* 卡顿优化-离屏渲染
* 卡顿优化-卡顿检测
* 卡顿优化-其他方面优化

##### 1.3.1 卡顿优化-CPU
1. 尽量用轻量级的对象(如用不到事件处理的地方,可以考虑使用CALayer取代UIView；能用基本数据类型，就别用NSNumber类型。)
2. 不要频繁的调整UIView的相关属性(如frame、bounds、transform等属性)尽量减少不必要的修改
3. 尽量提前计算好布局,在有需要时一次性调整对应的属性,不要多次修改属性
4. Autolayout会比直接设置frame消耗更多的CPU资源(如果对性能要求特别高,可以不用Autolayout)
5. 图片的size最好刚好和UIImageView的size保持一致(若不一致,CPU需要对图片进行伸缩处理)
6. 控制一下线程的最大并发数量
7. 尽量把耗时的操作放到子线程
8. 文本处理(尺寸计算、绘制)
9. 图片处理(解码、绘制)

        //文字计算
        [@"sdf" boundingRectWithSize:CGSizeMake(100, MAXFLOAT) options:NSStringDrawingUsesLineFragmentOrigin 
        attributes:nil context:nil];
        
        //文字绘制
        [@"test" drawWithRect:CGRectMake(0, 0, 100, 100) options:NSStringDrawingUsesLineFragmentOrigin 
        attributes:nil context:nil];
        //图片处理
        UIImageView *imgView = [[UIImageView alloc]init];
        通过这种方式加载图片,其实是不会直接显示到屏幕上的,加载的其实是经过压缩后的二进制数据
        如果要渲染到屏幕上,还需再经过解码,解码成屏幕需要的格式,而解码是放在主线程的,所以可能会产生卡顿
        可以把解码放在子线程,具体如何解码可以参考网上好多第三方的库中找到
        imgView.image = [UIImage imageNamed:@"test"];
        [self.view addSubview:imgView];
##### 1.3.2 卡顿优化-GPU
1. 尽量减少视图数量和层次
2. 尽量避免短时间内大量图片的显示,尽可能将多张图片合成一张进行显示
3. GPU能处理的最大纹理尺寸是4096*4096,一旦超过这个尺寸,就会占用GPU资源进行处理,所以纹理尽量不要超过这个尺寸
4. 减少透明的视图(alpha < 1),不透明的就设置opaque为YES
5. 尽量避免出现离屏渲染

##### 1.3.3 卡顿优化-避免离屏渲染
#### 在OpenGL中,GPU有两种渲染方式
* 1. On-Screen Rendering: 当前屏幕渲染,在当前用于显示的屏幕缓冲区进行渲染操作
* 2. Off-Screen Rendering: 离屏渲染,在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作
* 离屏渲染消耗性能的原因：

        需要创建新的缓冲区
        离屏渲染的整个过程,需要多次切换上下文环境,先是从当前屏幕(On-Screen)切换到离屏(Off-Screen);
        等到离屏渲染结束后,将离屏缓冲区的渲染结果显示到屏幕上,又需要将上下文环境从离屏切换到当前屏幕
        
#### 避免离屏渲染的操作
* layer 设置了使用了 mask 蒙版
* layer 设置了圆角裁剪(masksToBounds+cornerRadius),且包含 sub layer
* layer 设置了圆角裁剪(masksToBounds+cornerRadius),且设置了layer.contents属性
* layer 设置了圆角裁剪(masksToBounds+cornerRadius),若是UIImageView，且同时设置了backgroundColor和image
* layer 设置了阴影相关属性: shadowColor/shadowOpacity/shadowRadius/shadowOffset   
* layer 设置了光栅化shouldRasterize
* 使用了 blur 模糊效果UIVisualEffectView
* layer 设置了组不透明度allowsGroupOpacity = true，并且不透明度opacity小于1
#### 我们可以通过打开Xcode -> Debug -> View Debuging -> Rendering -> Color Offscreen Rendered Yellow
开关，检查离屏渲染情况


##### 1.3.4 卡顿优化-卡顿检测
* 卡顿监控: 监控原理是对主线程的runloop注册观察者，检测耗时，记录调用栈，上报后台分析。长时间卡顿后，若未进入下一个活跃状态，
则标记为卡死崩溃上报(借鉴第三方检测工具https://github.com/UIControl/LXDAppFluecyMonitor)

        WGMonitorManageDM 类会在主线程的 RunLoop 活动中检测是否有长时间的卡顿，并在检测到卡顿时记录调用栈并上报后台进行分析。
        超时时间设定为 6 秒，以覆盖大部分用户感知场景并减少性能损耗

##### 1.3.5  卡顿优化-其他方面优化
* 加载大图: 最容易造成掉帧的原因就是加载大的图片，对应渲染指令比较多，会影响渲染的时间；[UIImage imageNamed:name]的方式加载本地大图时，
系统会自动进行图片的解码,解码过程需要CPU进行大量的计算，并且解码后的图片通常占用更大的内存，都会影响性能和用户体验
 
    显示大图前可以先加载并显示小尺寸的缩略图，等到用户确需要查看高清图时再加载完整大图
    确保大图像文件的解码最好不要放到主线程，使用CGImageSource来对图片进行解码来减少内存峰值
    可以通过NSCache对图片进行缓存；然后异步加载图片；逐步解码(CGImageSource); 

* 异步绘制: 绘制流程是当视图内容或大小变化时会调用 setNeedsDisplay 或 setNeedsLayout 标记为要更新状态，下个循环会调用 drawRect: 
进行绘制，绘制是 Core Graphics，也就是 CPU，显示靠的是 Core Animation，用的是 GPU；异步绘制就是将 Core Graphics 的动作放到
主线程外，这样主线程就不会收到绘制计算量的影响

    CPU 主要是计算视图层次结构，布局、文本的绘制、图像解码以及 Core Graphics 绘制
    GPU 是处理图层合并、图像渲染、动画和 Metal 绘制
    CPU 负责准备数据，GPU 负责渲染这些数据
    CPU层面: 
            1.简化视图层次;
            2.尽量减少调用setNeedsDisplay/layoutSubviews(因为会导致重新绘制)
            3.图像解码不要放主线程
    避免离屏渲染(避免复杂的圆角、阴影效果、减少对 layer 的属性设置)

* 线程死锁: 选择合适的同步机制取决于具体的应用场景；检测卡顿情况也要重点从同步锁来入手

        NSLock/NSRecursiveLock/NSCondition/NSConditionLock/信号量(Dispatch Semaphore)
        Dispatch Barrier栅栏函数/读写锁pthread_rwlock_t/互斥锁pthread_mutex_t/@synchronized地柜锁
        os_unfair_lock/ 原子性属性atomic/ NSOperationQueue操作队列和操作依赖
        
* IO 过密: 磁盘操作通常是阻塞性的，可以将磁盘 IO 操作放到后台线程中执行
* 跨进程通信导致卡顿: 进程间通信是一种重要的机制,允许不同的进程或应用程序之间交换信息,下面系统API调用可能会导致卡顿或性能问题

        CNCopyCurrentNetworkInfo 获取 WiFi 信息
        设置系统钥匙串 (Keychain) 中的值
        NSUserDefaults 调用写操作
        CLLocationManager 获取当前位置权限状态
        UIPasteboard 设置和获取值
        UIApplication 通过 openURL 打开其他应用




#### 2. 启动优化
#### APP启动分为三种，启动优化主要针对的是【冷启动】阶段(不在内存里也没有进程存在)

* 冷启动: 当用户从完全关闭的应用程序状态启动应用时，系统会重新创建一个新的进程来分配给该应用
* 热启动: 当用户已经打开应用，但在短时间内切换到其他应用后再次返回到应用时，系统几乎不需要重新加载资源，直接从已有的进程中
启动应用，热启动的启动时间较短，因为系统已经保留了应用的进程信息‌
* 后台启动: 发生在应用在后台运行时，用户通过特定的操作（如推送通知、快速操作等）触发应用重新启动
* 启动的最佳时间是400ms以内；启动时间不能大于20s，否则会被系统杀掉
#### APP启动加载流程         


              建立沙箱/检查权限/                objc相关类注册/category分类注册
              加载相关信息(闪屏)                selector唯一性检查
                       |                                |
        点击APP -> 解析info.plist -> 加载Mach-O文件 -> objc运行时的初始化 -> initializers -> main函数
                                       |                                    |
                                加载动态链接库             +load()方法/创建C++全局静态变量
                                rebase指针调整            attribute((constructor))修饰的函数调用
                                bind符号绑定
                                
                                
        -->: pre-main阶段  ->: main阶段
       点击APP --> Mach-O加载进内存并创建进程 --> 内核将控制权交给dyld --> load dylds image(加载动态库)                      
                                                                                           |
                                                        Objc runtime初始化(注册Objc类         |
       main函数 <-- initializers(+load/constructor) <-- category注册/selector唯一性检查) <-- Rebase/bind image
         |
         |
       didFinishLaunchingWithOptions -> keyWindow/TabBarVC -> home Page Init -> getData ->渲染完成
#### Rebase和bind解释
#### ASLR(address space layout Randomization)地址空间布局随机化，ASLR技术之前程序都是在固定的地址加载的，这样就导致
程序可能因为知道某个函数的地址而被植入恶意代码、修改函数的地址等等带来很大的安全隐患；ASLR技术就是为了解决这个问题的。ASLR会使
程序每次启动后地址都会随机变化，程序里所有的代码地址都需要重新进行修复计算才能正常访问，而rebase就是为了调整镜像内部指针的指向
#### Bind就是给符号赋值的过程；例如NSLogo方法在编译时期生成Mach-O文件中会创建一个符号；然后运行时会将真正的地址给符号(即在内存
中将地址和符号进行绑定，是dyld做的，所以也叫动态库符号绑定)

* pre-main优化

        1、Load dylibs阶段：减少或者合并dylibs，将动态库换成静态库。
        2、Rebase/Bind阶段：减少类、方法、分类数量
        3、Objc setup阶段：没啥可做的
        4、Initializers阶段：优化+load方法、减少构造器函数（constructor），减少C++静态全局变量
        5、定位每个import的第三方库，然后衡量因为引入的库导致的延迟加载时间，然后决定是否有对应库的替换或者优化

* APP冷启动可以总结概括为几个阶段（load方法调用是在main函数前被调用的）

        1.加载应用的可执行文件(Mach-O文件)
        2.加载动态链接库加载器dyld(dynamic loader)
        3.dyld递归加载应用所有依赖的dylib(dynamic library动态链接库)
        4.进行Rebase指针调整、Bind符号绑定
        5.Objc Runtime初始化(Objc相关class注册、category注册、selector唯一性检查等)
        6.initializers初始化(执行+load方法、attribute((constructor))修饰的函数调用、创建C++全局静态变量)
        7.main函数调用
        8.调用UIApplicationMain()
        9.willFinishLaunchingWithOptions
        10.didFinishLaunchingWithOptions
     

#### 2.1 dyld是APP的动态链接器用来装载Mach-O文件(可执行文件、动态库等)；dyld做的事情如下: 
#### Xcode中当我们运行项目后,项目会编译在Products文件夹下的XXX.app,点击XXX.app显示包内容,在里面会有黑色图标
的文件XXX,这个文件XXX就是我们项目的可执行文件,这个可执行文件格式就是Mach-O格式文件, 包含了我们项目的所有代码, 但
是我们的代码可能会依赖一些动态库,比如UIKit、Foundation等,而这些动态库是不会存在于可执行文件的  

加载过程是从一个系统调用函数exec()开始的，操作系统首先为进程分配一段内存空间，然后执行如下操作

     exec()函数 -> 加载可执行文件 -> 加载dyld -> 加载dyld其他动态库 -> Rebase -> Bind -> Objc
     
     (1).把APP对应的可执行文件加载到内存
     (2).把Dyld加载到内存
     (3).Dyld进行动态链接(加载动态库 + Rebase和Bind)
* 加载动态库: Dyld从主执行文件的header获取需要加载的所依赖的动态库列表，加载的是动态库列表一个递归依赖的集合
* Rebase: Rebase在Image内部调整指针的指向；过去会把动态库加载到指定的地址，而现在地址空间布局是随机化，
所以需要在原地址基础上根据随机偏移量做修正
* Bind: 把指针正确的指向Image外部的内容；这些指向外部的指针被符号(symbol)名称绑定,dyld需要去符号表中
查找，找到symbol符号对应的实现

#### 2.2 Runtime dyld阶段加载结束后就进入Runtime阶段

        objc -> objc setup -> Initializers 
* objc setup: 

        (1)注册Objc类
        (2)把Category分类的定义插入方法列表
        (3)保证每个Selector方法名唯一性
* Initializers      

        (1)Objc的+load()函数
        (2)C++的构造函数
        (3)非基本类型的C++静态全局变量的创建

#### 2.3 main函数初始化
#### APP启动右dyld主导，将可执行文件加载到内存，顺便加载所有依赖的动态库，并由Runtime负责加载成Objc定义的结构
所有初始化工作结束后，dyld会调用main函数，然后就会调用application:didFinishLaunchingWithOptions:方法
* 进入main函数，启动应用
* 执行@UIApplicationMain()函数，创建UIApplication对象并设置AppDelegate
* 加载应用的主UI(storyboard/xib文件)

#### 2.4 首屏渲染阶段
* 初始化rootViewController，加载和渲染界面
* 渲染完成后，用户可以看到应用的首屏

#### 2.5 二进制文件重排
#### 进程若直接访问物理内存是很不安全的，所以操作系统在物理内存基础上又建立了一层虚拟内存。为提高效率和方便管理，对虚拟
内存和物理内存又进行分页（Page）。当进程访问一个虚拟内存Page而对应的物理内存不存在时，会触发一次缺页中断（Page Fault），
分配物理内存，有需要的话会从磁盘mmap(memory map内存映射技术)读入数据，一次Page Fault的耗时比想象的要多
* 修改代码在二进制文件的布局可以提高启动性能；

 
#### 总结
#### 冷启动优化方案

##### pre-main阶段优化
* 尽量使用静态库，减少动态库的使用,如果要用动态库，尽量将多个dylib动态库合并成一个
* 尽量避免对系统库使用optional linking(optional会有些额外的检查),若用到的系统库在所有支持的系统版本上都有，就设置为required
    
        Xcode -> Build Phases -> Link Binary With Libraries 
* 减少Objective-C Class、Selector、Category的数量，可以合并或者删减一些OC类
* 删减一些无用的静态变量，删减没有被调用到或者已经废弃的方法 
* 将不必须在+load中做的事情尽量挪到+initialize中，+initialize是在第一次初始化这个类之前被调用，+load在加载类的时
候就被调用；或者做load方法迁移
* 尽量不要用C++虚函数，创建虚函数表有开销
* 在初始化方法中不创建线程、不调用dlopen()，dlopen()有性能和死锁的可能性
* 延迟初始化(延迟一些非必要在启动时初始化的工作)
* 减少主线程阻塞(启动阶段尽量避免主线程中处理耗时任务、文件IO、网络请求等，将这些操作放在子线程中处理)

##### main阶段优化
* 尽量不要使用xib/storyboard，而是用纯代码作为首页UI，如果要用xib/storyboard，不要在xib/storyboard中存放太多的视图
* 使用简单的广告页作为过渡，将首页的计算操作及网络请求放在广告页展示时异步进行。
* 对application:didFinishLaunchingWithOptions:里的任务尽量延迟加载或懒加载
* 不要在NSUserDefaults中存放太多的数据，NSUserDefaults是一个plist文件，plist文件会被反序列化一次
* 避免在启动时打印过多的log，少用NSLog，因为每一次NSLog的调用都会创建一个新的NSCalendar实例
* 为了防止使用GCD创建过多的线程，解决方法是创建串行队列，或者使用带有最大并发数限制的NSOperationQueue
* 不要在主线程执行磁盘、网络、Lock或者dispatch_sync、发送消息给其他线程等操作




#### 3. 内存相关优化
#### 内存泄漏: 程序在运行过程中，分配的内存未能及时释放，导致程序占用的内存持续增加，内存泄漏发生情况如下: 
* 循环引用：对象A强引用对象B,对象B又强引用对象A; [用weak解决循环引用]
* Block导致的内存泄漏：Block会对其内部的对象强引用，容易形成循环引用; [用weak解决循环引用]
* NSTimer导致的内存泄漏: NSTimer的target-action机制容易导致self与timer之间的循环引用 [使用NSPoxy代理进行转发]
* 委托模式(Delegate代理)中的内存泄漏；[根据具体场景选择使用weak或strong修饰delegate属性]
* 非OC对象的内存管理: CoreFoundation框架下的对象(如CI、CG、CF开头的对象)和C语言中的malloc使用完毕后需手动
释放(CFRelease、free)
    
#### 内存泄漏检测工具: 基本原理是监控和管理对象的生命周期，检测那些在生命周期结束后仍未被释放的对象FBRetainCycleDetector 
是由 Facebook 开源的一个用于检测 iOS 应用中的内存泄漏的工具

        对象图构建：FBRetainCycleDetector 首先会从一个指定的对象开始，递归地遍历该对象的所有属性和关联对象，构建一个引用图
        深度优先搜索 (DFS): 查找路径起始和终止于同一个对象的闭环
        循环检测: 找到一个循环路径时,会将其标记为潜在的内存泄漏,检测到的循环会以易于理解的方式输出，帮助开发者定位和解决问题
        对象图的遍历和循环检测可能会带来性能开销,主要用于开发和调试阶段,不建议在生产环境中长期使用




#### 4. 耗电量优化
#### 耗电的主要来源
* 1. CPU处理(Processing)
* 2. 网络(Networking)
* 3. 定位(Location)
* 4. 图像(Graphics)

#### 耗电优化方案
* 1. 尽可能降低CPU、GPU功耗(上面已经提过CPU、GPU的优化)
* 2. 少用定时器
* 3. 优化I/O操作(文件的读写):  

        尽量不要频繁写入小数据,最好批量一次性写入; 
        读写大量重要数据时,考虑用dispatch_io,它提供了基于GCD的异步操作文件I/O的API,用dispatch_io系统会优化磁盘访问
        数据量比较大的,建议使用数据库(如SQLite、CoreData)
* 4. 网络优化

        减少、压缩网络数据(XML体积大、JSON体积小、也有用Protocol buffer前提是服务器也用Protocol buffer)
        如果多次请求的结果是相同的,尽量使用缓存(NSCache)
        使用断点续传,否则网络不稳定时可能多次传输相同的内容
        网络不可用时,不要尝试执行网络请求
        让用户可以取消长时间运行或者速度很慢的网络操作,设置合适的超时时间
        批量传输(如下载视频流时,不要传输很小的数据包,直接下载整个文件或一大块一大块的下载;减少发送网络请求的数量)
* 5. 定位优化

        如果只是需要快速确定用户位置,最好用系统库CoreLocation中CLLocationManager的requestLocation方法,
        定位完成后,会自动让定位硬件断电
        
        如果不是导航应用,尽量不要实时更新位置,定位完毕就关闭定位服务
        尽量降低定位精度,比如尽量不要使用精度最高的KCLLocationAccuracyBest
        需要后台定位时,尽量设置pausesLocationUpdatesAutomatically为YES(若用户不太可能移动时系统会自动暂停位置更新)
        




#### 5. 安装包瘦身

![图片](https://github.com/WGFcode/WGFcodeNotes/blob/master/WGFcodeNotes/WGScreenshots/ipa.png)
* _CodeSignature: ipa包签名文件的存放文件夹；存放每个文件的hash值；
* embedded.mobileprovision: 包含证书配置、设备UDID等相关信息
* YXF: 可执行文件Mach-O文件
* PlugIns: App创建的扩展Extensions，比如Widget、Push和Share等
* Frameworks: 

        SwiftSupport: libSwiftxxx 等一系列 Swift 库 
        其他依赖库: carthage方式的第三方库会在该文件中；
        而swiftPackageManage和cocoaPods方式不会出现在该文件中，猜测应该是被打进了可执行文件中
* en.lproj / zh-Hans.lproj: App所支持的语言文件
* Info.plist：项目配置表
* Assets.car：Assets.xcassts在编译过程中生成的最终展示文件，默认里面存放各种分辨率图片

#### 通过分析ipa包大题可以分为如下几个方面，而APP瘦身主要从以下几个方面进行优化
* Exectutable: 编译后的可执行文件
* Resources：图⽚、⾳频、视频等资源⽂件

        图片资源：Assets.car/bundle/png/jpg 等
        视频/音频资源：mp4/mp3 等
        静态网页资源：html/css/js 等
        视图资源：xib/storyboard 等
        其他：文本/字体/证书 等
* Framework：项目中使用的动态库
* Pulgins：Application Extensions

#### 应用瘦身优化方案有以下几种
* 编译器优化
* 资源文件优化


#### 5.1 编译器优化
* 从架构层面，如果是老项目设置放弃支持armv7(支持4s和4)架构，如果不需要模拟器可以放弃模拟器架构
    
        Xcode -> Build Settings -> Architectures
        
        armv7｜armv7s｜arm64 : ARM处理器的指令集
        i386｜x86_64 : Mac处理器的指令集
        
        模拟器32位: i386架构
        模拟器64位: x86_64架构
        真机32位: armv7 / armv7s架构
        真机32位: arm64架构
* 无用代码剥离：去除在程序运行过程中永远不会被执行到的代码。这些代码可能是由于条件判断、未使用的函数或类等原因而不会被调用

        Xcode -> Build Settings -> Dead Code Stripping
        
* 按需设置编译器优化级别：

        Xcode -> Build Settings -> Optimization Level
        Debug: 设定为 None[-O0]  Release: 设定为 Fastest,Smallest[-Os]
* 生成调试符号: 符号主要用于调试器能够将二进制指令映射到源程序中的函数、变量、类等元素，帮助开发者理解程序在运行过程中的行为，方便定位
和解决问题;若不考虑发布后的调试便利性，可以将其设置为NO来减少包体积

        函数符号:对于每个函数，调试符号包含其名称、参数信息、返回值类型以及在二进制文件中的位置
        变量符号:变量符号包含变量的名称、类型、作用域和存储位置等信息
        类和对象符号:对于类，调试符号包含类名、继承关系、成员变量和成员函数等信息
    
        Debug: 设置为YES，方便调试   Release: 设置为NO  设置为NO断点就无法使用了
        Xcode -> Build Settings -> Generate Debug Symbols 
        
        调试符号会增加二进制文件的大小，增加的大小取决于项目的规模和复杂程度
        调试符号本身对性能基本没有影响，不过，在编译过程中，生成调试符号会稍微增加编译时间
* 无用符号剥离
        
        虽然通过Strip Linked Product剥离了调试符号和符号信息，但是通过设置Release下的
        dSYM来还原我们的堆栈符号信息
        Debug Information Format -> Release DWARF with dSYM File

        DEBUG下设为NO，RELEASE下设为YES
        Xcode -> Build Settings -> Strip Linked Product
        
        Deployment Postprocessing是Strip的总开关；只有Deployment Postprocessing这里设置了YES
        Strip Debug Symbols During Copy和Strip Linked Product设置为YES才会生效
        
        Strip Linked Product: 对最终的二进制文件是否进行去除一些不必要的符号信息和调试信息
        Strip Debug Symbols During Copy: 在复制过程中去除调试符号
* 隐藏符号信息来提升安全性/Release模式下设置为YES可以减少包体积: 

    Symbols Hidden by Default: 符号(函数、变量、类等的名称和相关信息)是否默认被隐藏
    使用场景: 构建静态库和框架 / 提高应用安全性 
    框架内部的实现细节可以通过隐藏符号来保护，只将供外部使用的类和方法通过合适的访问控制和符号可见性设置暴露给开发者
    

#### 5.2 资源文件优化
##### [linkMap文件是什么？](https://www.jianshu.com/p/34d579eeeba5)
##### 源码经过编译、链接，最终生成一个可执行文件；编译阶段，每个类会生成对应的.o文件；链接阶段，会把.o文件
和动态库链接在一起；Link Map File就是一个记录链接相关信息的纯文本文件，里面记录了可执行文件的路径、CPU架构、
目标文件、符号等信息

        设置并获取到linkMap文件路径
        Xcode -> Build Settings -> Write Link Map File -> YES
        Xcode -> Build Settings -> Path to Link Map File -> 设置生成linkMap文件路径

        linkMap应用场景:
        1.体积优化‌：通过分析LinkMap文件，可以了解安装包中各个模块的体积贡献，从而进行有针对性的优化，
        减少不必要的代码和资源，缩小安装包体积‌
        2.调试和故障排查‌：在应用发生崩溃时，LinkMap文件可以帮助还原崩溃现场，通过符号信息定位问题源头，
        加速调试过程‌
##### linkMap文件内容包含三部分: (https://www.jianshu.com/p/553f43eca0f8)
* (类表)Object files: 保存了所有用到的类生成的.o文件，也包括用到的dylib库;前面[num]是序号，类是按照顺序保存的，
后续可以通过序号查到具体对应的哪个类
* (段表)Sections: 描述了每个目标文件的节(Section)信息(起始地址、大小等信息);二进制文件中，代码和数据是按照不同的节来组织的
包含代码段（__TEXT）和数据段（__DATA）
* (符号表)Symbols: 记录了程序中的符号(类名、变量名、方法名)(记录着每个方法及占用的大小);每个符号，会有其对应的目标文件和
节信息，这样可以知道某个符号是在哪个目标文件的哪个节中定义的; 比如方法setEntity: 可以发现在Object files:中的编号是331


        Path: /Users/baicai/Library/Developer/Xcode/DerivedData
        /NXYXE-hfacokxfsfvxedcuemnrjpsaqdfh/Build/Products/Debug-iphoneos/NXYXE.app/NXYXE
        Arch: arm64
        Object files:
        [  0] linker synthesized
        [  1] objc-stubs-file
        [  2] stubs-got-file
        [  3] objc-file
        ......
        [331] /Users/baicai/Library/Developer/Xcode/DerivedData/NXYXE-hfacokxfsfvxedcuemnrjpsaqdfh
        /Build/Intermediates.noindex/NXYXE.build/Debug-iphoneos/NXYXE.build/Objects-normal/arm64/
        WGEnterInterfaceVC.o
        
        # Sections:
        # Address        Size        Segment    Section
        0x100004000    0x00DDB0D8    __TEXT    __text
        0x10104C000    0x00001828    __DATA    __got
        ......
        
        # Symbols:
        # Address    Size        File  Name
        0x100004000  0x0000003C  [  4] __ZN7DeepNetC2E10DeviceTypeiRKNSt3__16vectorIiNS1_9allocatorIiEEEE
        0x10014CCD0  0x00000070  [331] -[WGEnterInterfaceVC setEntity:]
        0x10014CD40  0x00000E90  [331] -[WGEnterInterfaceVC layoutUI]
        0x10014DBD0  0x000001E8  [331] ___30-[WGEnterInterfaceVC layoutUI]_block_invoke
        0x10014DDB8  0x00000220  [331] ___30-[WGEnterInterfaceVC layoutUI]_block_invoke_2
        ......

* 删除⽆⽤的资源⽂件：使用工具LSUnusedResources检查项目中无用的资源(图片资源/html/xib/storeboard/.strings等)
* 分析linkMap文件，查看每个类或者库所占用的空间大小，可快速定位需要优化的类或静态库来减少包体积,可以使用两个工具进行分析:
[linkMap](https://github.com/jayden320/LinkMap)
[LinkMapParser](https://github.com/zgzczzw/LinkMapParser)

    (1)使用linkMap工具查询每个文件占用的大小，然后进行优化比如引入了第三方库，但是这些集成的库中有些功能是
    不需要的就可以剔除来减少体积
    (2)使用LinkMapParser工具可以查询每个目标文件占用的大小，并且可以分析两个linkMap文件之间哪些文件
    的内存变大了

* 压缩图⽚⼤⼩
[ImageOptim无损压缩工具](https://imageoptim.com/mac) 直接把压缩后的图片替换掉工程里的原图片，省时省力

    支持多种图片格式(PNG/JPEG/GIF等)的无损压缩 
    有桌面应用程序，对于本地文件处理更方便，无需网络连接即可使用
    压缩比率低于Tinypng;开源免费软件，无使用次数和文件数量的限制
    
[Tinypng有损压缩工具](https://tinypng.com/)

    TinyPNG 主要支持(PNG/JPEG/WebP格式)的有损压缩
    网页在线服务，无需安装软件，但依赖网络
    压缩比率达到 50%-70%；一次最多支持上传 20 张图片

        1.将图片放入Assets.xcassets，因为xcassets里的@2x和@3x图片，在上传时，会根据具体设备分开对应分辨率的图片，
        不会同时包含，而放入.bundle中的都会包含，所以要尽量把图片放入xcassets中
        
        2.大于100KB的图就不要放到xcassets中了，大图可以将格式转为webP格式，webP能够把图片压缩到很小，但是
        肉眼看不出来差别(小二项目中@2x启动图都770KB,转为webP格式后大小为17KB),大图直接放在项目目录中，然后
        通过第三方库(SDWebImage)进行加载
        
        png: 无损压缩(保存和打开过程图片质量不会有任何损失)的图像格式，支持透明度(alpha通道)；比同质量的JPEG格式要大
        
        jpeg:有损压缩(去除图像中的一些细节信息来减少文件大小，压缩比不太高的情况下，人眼很难察觉到质量的下降)的图像格式
         
        webp:谷歌开发的一种现代图片格式，结合了PNG的无损和JPEG的有损压缩有点，支持透明度，保证图片质量同时减少文件大小
        主要用于网页开发来提高网页加载速度，iOS中对webp格式支持有限，需要借助第三方来加载webp格式图片
        
        两个方式管理图片:一种是在项目中添加文件夹存放,另一种是放在Assets.xcassets管理;Assets.xcassets它会把里边的
        所有 png 格式的图片压缩成一个Assets.car文件,压缩比率比其他方式管理图片要高，大大减少图片体积

* 删除Localizable.strings中没有使⽤的字符串：多语⾔⽂件占用内存也会比较大
* 按需加载资源文件：On-Demand Resource,为资源添加标签(选择项目中图片，然后设置tag，最终会在Resource Tags标签下显示)

    ODR中的资源是在APP打包的时候确定的，不进行版本更新就无法更新这些资源。
    ODR的资源是存放在苹果Server的，我们不需要再用自己的服务器

    ODR的三种类型
    (1)initial install Tags：
    此种类型的资源会随着APP从App Store的下载而下载，会影响ipa的大小，也就是说资源会包含在ipa包内。
    (2)Prefetched Tag Order：
    此种类型的资源会在APP下载后开始下载下载相应的资源，下载会有先后顺序，这种不会影响ipa包的大小，也就是说资源不在ipa包内。
    (3)Download Only On Demand：
    此种类型的资源会在必须的时候主动触发下载，这是开发者自己控制下载时机的

    一个资源的标签名是可以任意取的；一个资源可以打多个标签
    1.检查资源是否被下载
    conditionallyBeginAccessingResourceWithCompletionHandler
    2.从APP Server开始下载资源
    beginAccessingResourceWithCompletionHandler
    
    On-Demand Resource优点
    可以减小应用的大小，使得下载更快，提升用户体验
    一些固定的应用资源懒加载
    操作系统会在磁盘不够的时候清理ODR

    Target -> Resource Tags -> Download Only On Demand


#### 5.3 Extension优化
* 使⽤独⽴的Localizable.strings⽂件: 多个Extension时尽量不要用main target的Localizable文件而是单独创建一份

    Extension的资源是各⾃独⽴的，打包后，每个Extension都有⼀份完整的Localizable.strings，所以要分开按需创建
* 剔除多余的三⽅库

#### ipa包瘦身总结
* 利用LSUnusedResources工具检查剔除项目中无用的资源(图片/音视频文件/html等)
* 应用中的图片可以利用压缩工具对图片进行压缩处理;可以使用ImageOptim、TingPNG等压缩工具
* 小的图片@2x/@3x倍图尽量放在Assets.xcassets中进行管理，因为编译器会将图片最终打包压缩成Assets.car文件
这种压缩比其他方式管理图片要高可以大大减少图片体积；针对大的图片如启动图等使用webp格式的图片可以大大减少图片体积
webp格式图片需要借助第三方库(SDWebImage)来加载
* 通过linkMap工具分析linkMap文件中各个类、方法、第三方库的目标文件(.o)所占用的大小，进行分析优化
* 查看架构支持，我们现在可以只支持arm64架构，摒弃掉armv7/arm7/x86_64架构，针对第三方静态库也可以通过lipo命令
行进行查看支持的架构，然后导出我们需要的架构，摒弃不需要的架构支持来减少包体积
* 删除多语言开发中的多语言文件Localizable.strings中无用的字符串
* 通过为资源设置标签tags,来进行按需加载(从苹果服务器下载所需资源，下载时机由我们程序员自己控制)



















#### 3. IO性能优化
* iOS 提供了多个文件存储目录，选择合适的目录有助于管理缓存文件的生命周期;包括Caches 目录和tmp 目录     

        Caches目录: 适合存储缓存文件。系统可能会在磁盘空间紧张时清除这个目录下的文件，因此不应存储重要数据
        tmp目录: 适用于临时文件。系统重启或应用未运行时，可能会清除这个目录下的文件
* 根据数据的重要性和更新频率，制定缓存策略。为缓存数据设置时间戳或过期时间。每次读取缓存时检查数据是否过期，及时更新。
实现 LRU 算法，定期清理最久未使用的缓存文件

* 为缓存文件生成唯一标识符（如使用哈希值），避免文件名冲突。可以将 URL 的 MD5 或 SHA1 哈希值作为缓存文件名。
将缓存文件按类别或特定属性进行分类存储，方便管理。例如，将图片和JSON数据分别存储在不同的子目录中

* 对于大型缓存数据，可以在写入文件时使用 GZIP 等压缩技术，减少存储空间占用;避免在主线程上执行缓存读写操作
* 减少频繁的写入操作，可以将多次写入合并为一次批量操作

* 读写的 API
* 文件缓存: 可以帮助优化应用性能、减少网络请求和延长电池续航
* 定期清理过期或不再使用的缓存文件，避免占用过多磁盘空间
























































        
#### 7. 安装包瘦身
#### 安装包(ipa)主要由可执行文件、资源组成,瘦身主要从这两方面入手
* 资源(图片、音频、视频等)瘦身

        1. 采取无损压缩
        2. 去除没有用到的资源(https://github.com/tinymind/LSUnusedResources)
* 可执行文件瘦身

        1.编译器优化
            Strip Linked Product、Make Strings Read-Only、Symbols Hidden by Default设置为YES
            去掉异常支持(Enable C++ Exceptions、Enable Objective-C Exceptions设置为NO)
            Other C Flags 添加 -fno-exceptions
        2.利用AppCode(https://www.jetbrains.com/objc/)检测未使用的代码(菜单->Code->Inspect Code)(免费时间可用)
        3.编写LLVM插件检测出重复代码、未被调用的代码(难度比较大,仅作为一种瘦身方法了解即可)
        4.生成LinkMap文件,可以查看可执行文件的具体组成(X.txt文件)
        Build Settings -> Write Link Map File设置为YES
        Path to Link Map File 修改$(TARGET_TEMP_DIR)路径为桌面下的某个路径,然后运行项目,就会在指定路径下生成文件X.txt
        当文件X.txt比较大时,可借助第三方工具解析LinkMap文件,来详细查看各个类占用的内存大小(KB单位)
        https://github.com/huanxsd/LinkMap
        
#### 8 性能调优之像素对齐-Color Misaligned Images优化
#### iOS项目中的尺寸是以点(point)为单位,@1x、@2x、@3x代表分别表示一个点对应1个像素、对应2个像素、对应3个像素。而Color Misaligned Images主要就是针对像素不对齐而导致性能问题进行优化处理的
#### 发现项目中存在Misaligned Images问题的方式有两种
1. 模拟器调试时：打开模拟器的Debug - Color Misaligned Images菜单选项
2. Instrument性能检测时，选中Core Animation模板，在Display Settings中勾选Color Misaligned Images选项。可针对模拟器和真机，可查看真机上所有应用的像素混合情况
#### 打开开关后，会看到部分视图出现黄色或洋红色图层标记，代表其像素不对齐
    不对齐: 视图或者图片的点数(point)，不能换算成整数倍的像素值(pixel),导致显示视图时需要对没对齐的边缘进行额外混合计算，
    影响性能洋红色: UIView的frame像素不对齐，即不能换算成整数像素值
    
    黄色: UIImageView的图片像素大小与其frame.size不对齐，图片发生了缩放造成
    
    点(point): 逻辑坐标的基本单位，日常布局中常用的，比如某个视图的宽度为20高度为40，点是虚拟单位，并非实际存在，
    还需GPU计算点对应的像素
    
    像素pixel: 屏幕上最小的色块单元，如iPhone6s的屏幕像素是750x1334像素，对应的点是375*667pt,点和像素的对应关系是1:2,
    所以iPhone6s上需要使用@2x的图片
    
#### 一般UI设计师给的设计图都是像素(px)为单位或者点(pt)为单位，本案例以设计图以像素(px)为单位，如果设计图中图标@2x尺寸为40*40像素，那么实际项目中如果我们在iPhone6s下设置布局时，应该设置它的size为20*20(原因是iPhone6s用的是@2x的图标，即iPhone6s屏幕上的一个点代表2个像素)，否则会出现像素不对齐的问题，所以以后让设计出图出图(像素px为单位时)，尽量@2x的图是项目布局设置尺寸的2倍，对应的@3x是项目布局尺寸的3倍，这样就不会出现像素不对齐而导致性能问题了

#### 洋红色: UIView的frame像素不对齐，即不能换算成整数像素值问题的解决；解决方法就是根据屏幕倍数对点进行向上取整
    0.5个点在@3x(即一个点代表3个像素)的设备上不能转化为整数的像素，
    label.frame = CGRectMake(0.5, 10, 20.5, 30);
    
    
    OC中无法对CGFloat、CGSie、CGRect进行分类添加方法，所以该方法写在全局工具类中
    /// 基于屏幕倍数，进行像素取整
    +(CGFloat)scalePixelInteger:(CGFloat)fl {
        //通过UIScreen.main.scale来获取像素与点的对应关系。
        CGFloat newScale = UIScreen.mainScreen.scale;
        //fl * newScale 点*屏幕倍数 = 像素,然后对像素进行向上取整
        //ceil: 如果参数是小数，则求大于本身的最小整数.
        return ceil(fl * newScale) / newScale;
    }
    
    CGfloat x = [WGUtil scalePixelInteger:0.5];
    CGfloat w = [WGUtil scalePixelInteger:20.5];
    label.frame = CGRectMake(x, 10, w, 30);
    这样就不会再出现洋红色了
    

#### 黄色: UIImageView的图片像素大小与其frame.size不对齐，图片发生了缩放造成；解决方法就是根据图片的像素大小，然后调整布局中的位置；或者让设计师重新出图



### iOS渲染原理
    1.我们在屏幕上绘制图像需要的原始数据叫【位图(Bitmap)】,位图是一种数据结构，一个位图由n*m个像素组成
     每个像素的颜色信息由RGB组合或灰度值表示
     
    2.位图一般存储的是物理像素(物理分辨率)，而应用层一般用的是逻辑像素(逻辑分辨率)
        物理分辨率以pixel(px)为单位；逻辑分辨率以point(pt)为单位;
        iOS 1X倍屏: 1pt = 1个物理像素
        iOS 2X倍屏: 1pt = 2个物理像素
        iOS 3X倍屏: 1pt = 3个物理像素
        
     3.ios开发界面设置长度是以pt(点)为单位的，比如iPhone7plus屏幕尺寸414pt*736pt，所以pt是iOS的开发单位,
     而美工给我们的都是以像素(px)为单位的的
     
     4.屏幕上绘制图像显示的原始数据叫【位图】:电子抢从上到下逐行扫描，扫描一行发出一个Hsync水平同步信号，扫描完成后就显示一帧画面，
     然后电子抢回到初始位置准备进行下一次扫描，在下一次扫描前会发出一个Vsync垂直同步信号，显示器通常以固定的频率进行刷新，这个刷新率就是垂直同步信号
     产生的频率
     
     4.【位图】数据是由CPU、GPU协同工作得到的；
        CPU将计算好显示内容提交给GPU
        GPU渲染完成后将渲染结果存入帧缓冲区
        视频控制器会读取帧缓冲区器的信息传递给显示器进行显示
        
     5.CPU和GPU区别
        CPU:中央处理器，适合处理单一复杂逻辑；cache占用了大量的空间，而且还有特别复杂的控制逻辑，相比之下，计算能力只是CPU 很小的一部分
        GPU:图像处理器，适合高并发简单逻辑；图像渲染涉及到的矩阵运算比较多，矩阵相关的计算可以被拆分成并行的简单的运算，所以渲染处理适合GPU做
        GPU 的工作计算量大，但技术含量不高，需要简单重复很多次；CPU 就像老教授，积分微分都会算，适合处理单一复杂逻辑运算
        
    6.iOS渲染原理
    (1)ios图形渲染有三个核心的库: Core Graphics、Core Animation、Core Image,三个框架主要用来绘制可视化内容,他们都是通过 OpenGL 来
        调用 GPU 进行实际的渲染，然后生成最终位图数据存储到帧缓冲区，视频控制器再将帧缓冲区的数据显示物理屏幕上。
    (2)UIKit是 iOS 开发者最常用的框架,通过设置 UIKit 组件的布局以及相关属性来绘制界面。但是 UIKit 并不具备在屏幕成像的能力，
       这个框架主要负责对用户操作事件的响应（UIView 继承自 UIResponder），事件经过响应链传递。
    (3)Core Animation  主要负责组合屏幕上不同的可视内容，这些可视内容可被分解成独立的图层也就是我们日常开发过程中常接触的 CALayer，
       这些图层被存储在图层树中。CALayer 主要负责页面渲染，它是用户能在屏幕上看见的一切的基础;
    (4)Core Graphics 主要用于运行时绘制图像。开发者可以使用此框架来处理基于路径的绘图，转换，颜色管理，离屏渲染，图案，渐变和阴影等等。
    (5)Core Image  与  Core Graphics 正好相反，Core Graphics  是在运行时创建图像，而  Core Image  则是在运行前创建图像。
    (6)OpenGL ES 和 Metal 都是第三方标准，基于这些标准具体的内部实现是由对应的 GPU 厂商开发的。Metal 是苹果的一套第三方标准，
       由苹果实现。很多开发者都没有直接使用过  Metal，但却通过 Core Animation、Core Image 这些核心的系统框架在间接的使用 metal
       
    7.CoreAnimation 与 UIKit 框架的关系
    (1)Core Animation 是 iOS 和 OS X 上图形渲染和动画的基础框架，主要用来给视图和应用程序的其他可视元素设置动画。Core Animation
       的实现逻辑是将大部分实际绘图的工作交给 GPU 加速渲染，这样不会给 CPU 带来负担，还能实现流畅的动画。CoreAnimation 的核心类是
       CALayer，UIKit 框架的核心类是 UIView
    (2)UIView 和 CALayer 是一一对应的关系，每一个 UIView 都有一个 CALayer 与之对应，UIView负责布局、交互响应，CALayer负责页面渲染
          CALayer 是 UIView 的属性之一，负责渲染和动画，提供可视内容的呈现;UIView 提供了对 CALayer 功能的封装，负责了交互事件的处理
    




























