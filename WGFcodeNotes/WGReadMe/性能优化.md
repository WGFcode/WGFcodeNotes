## 性能优化

#### 性能优化涉及方面比较多，大的分类大概有以下几种
1. 卡顿优化
2. 启动优化
3. 内存相关优化
4. 耗电量优化
5. 安装包瘦身

5. 崩溃率优化
6. 网络流量优化
6. 安全性优化

<!--4. IO性能-->
<!--4. CPU/GPU-->
<!--5. 启动优化-->
<!--6. 包体积-->
<!--7. 性能分析-->
<!--8. 生成ipa包的过程-->

#### 背景概念    
* 应用交互前端UIKit/AppKit ->  Core Animation -> OpenGL ES/ Metal -> GPU Driver -> GPU -> Screen Display
* Core Graphics‌：又被称为(Quartz 2D)是一个2D图形渲染引擎;用于绘制图形、处理图像和创建PDF;基于CPU进行渲染，相对效率较低
* ‌Core Animation‌：是一个动画和图形渲染框架;基于GPU进行渲染，具有更高的性能和更平滑的动画表现‌

            ---------------------------------
            |         UIKit/AppKit          |
            |         Core Animation        |
            | Metal/OpenGL ES Core Graphics |
            |        Graphics Hardware      |
            ---------------------------------

#### 1. 卡顿优化
#### 1.1 iOS屏幕图像显示原理->(CPU和GPU起着至关重要的作用)
* CPU(中央处理器): 对象的创建和销毁、对象属性的调整、计算视图层次结构，布局、文本的绘制、图像解码以及 Core Graphics 绘制
* GPU(图形处理器): 处理图层合并、图像渲染、动画和 Metal 绘制
* CPU 负责准备数据；GPU 负责渲染这些数据
* CPU计算好显示内容提交到GPU，GPU渲染完成后将渲染结果放入帧缓冲区，视频控制器收到VSync信号后逐行读取帧缓冲区的数据，
经过一定的数模转换传递给显示器显示
* 屏幕刷新频率：Refresh Rate或Scanning Frequency，单位hz，是指设备刷新屏幕的频率。
* 帧率：Frame Rate，单位 fps，是指 GPU 生成帧的速率。

              计算         渲染          读取               显示
        CPU---------GPU---------帧缓存---------视频控制器---------屏幕
                                 |
                          前帧缓存  后帧缓存
* 单缓存效率低下并且容易导致画面撕裂问题

        GPU向缓存区中写入数据，视频控制器从缓存区中取图像数据后显示，理想的情况是帧率和屏幕刷新频率相等
        每绘制一帧，屏幕就显示一帧；而实际情况是，如果没有同步机制，当帧率大于屏幕刷新频率时，视屏控制器
        刚逐行读取完第2帧的上半部分时，GPU已经完成第3帧的渲染并提交到缓存区中，视屏控制器会继续读取第三帧
        的下半部，这样会造成画面撕裂
    
* 在iOS中是双缓存区+VSync(垂直同步信号)机制,有前帧缓存、后帧缓存，提高渲染效率

        1.GPU 会预先渲染好一帧放入一个缓存区内(前帧缓存);
        2.显示器发出VSync后,视频控制器的指针会指向前帧缓存区并开始读取,GPU开始渲染下一帧,并将渲染结果放入另一个缓存区(后帧缓存);
        3.显示器发出新的VSync后,视频控制器的指针会指向后帧缓存区并开始读取，GPU开始渲染下一帧，并将渲染结果放入前帧缓存区。
        问题: 若在一个Vsync时间内，CPU或GPU没有完成内容提交，则那一帧就会被废弃，而此时显示器会保留之前的内容不变，造成界面卡顿

* 显示器的电子枪是从上到下进行逐行扫描的，扫描完成后显示器就呈现一帧画面，随后电子枪回到初始位置继续下一次扫描。
* 为了把显示器的显示过程和系统的视频控制器进行同步，显示器（或者其他硬件）会用硬件时钟产生一系列的定时信号
* 显示器通常以“固定频率“进行刷新(屏幕刷新率)，这个刷新率就是VSync信号产生的频率
* iOS设备的屏幕刷新频率是每秒60帧，平均每16.67ms发出一个VSync。

        HSync：
        当电子枪换到新的一行,准备进行扫描时,显示器会发出一个水平同步信号,简称HSync(horizonal synchronization)
        VSync：
        当一帧画面绘制完成后,电子枪回复到原位,准备画下一帧前,显示器会发出一个垂直同步信号,简称VSync(vertical synchronization)
    
#### 1.2 卡顿产生额原因
* CPU计算和GPU渲染花费的时间太长,导致垂直同步信号(VSync)来的时候,计算和渲染操作还没有完成
* 按照60FPS(每秒刷新60帧)的刷帧率,每隔16ms(1000毫秒%60)就会有一次垂直同步信号(VSync)

#### 1.3 卡顿优化方案
* 卡顿优化-CPU
* 卡顿优化-GPU
* 卡顿优化-离屏渲染
* 卡顿优化-卡顿检测
* 卡顿优化-其他方面优化

##### 1.3.1 卡顿优化-CPU
1. 尽量用轻量级的对象(如用不到事件处理的地方,可以考虑使用CALayer取代UIView；能用基本数据类型，就别用NSNumber类型。)
2. 不要频繁的调整UIView的相关属性(如frame、bounds、transform等属性)尽量减少不必要的修改
3. 尽量提前计算好布局,在有需要时一次性调整对应的属性,不要多次修改属性
4. Autolayout会比直接设置frame消耗更多的CPU资源(如果对性能要求特别高,可以不用Autolayout)
5. 图片的size最好刚好和UIImageView的size保持一致(若不一致,CPU需要对图片进行伸缩处理)
6. 控制一下线程的最大并发数量
7. 尽量把耗时的操作放到子线程
8. 文本处理(尺寸计算、绘制)
9. 图片处理(解码、绘制)

        //文字计算
        [@"sdf" boundingRectWithSize:CGSizeMake(100, MAXFLOAT) options:NSStringDrawingUsesLineFragmentOrigin 
        attributes:nil context:nil];
        
        //文字绘制
        [@"test" drawWithRect:CGRectMake(0, 0, 100, 100) options:NSStringDrawingUsesLineFragmentOrigin 
        attributes:nil context:nil];
        //图片处理
        UIImageView *imgView = [[UIImageView alloc]init];
        通过这种方式加载图片,其实是不会直接显示到屏幕上的,加载的其实是经过压缩后的二进制数据
        如果要渲染到屏幕上,还需再经过解码,解码成屏幕需要的格式,而解码是放在主线程的,所以可能会产生卡顿
        可以把解码放在子线程,具体如何解码可以参考网上好多第三方的库中找到
        imgView.image = [UIImage imageNamed:@"test"];
        [self.view addSubview:imgView];
##### 1.3.2 卡顿优化-GPU
1. 尽量减少视图数量和层次
2. 尽量避免短时间内大量图片的显示,尽可能将多张图片合成一张进行显示
3. GPU能处理的最大纹理尺寸是4096*4096,一旦超过这个尺寸,就会占用GPU资源进行处理,所以纹理尽量不要超过这个尺寸
4. 减少透明的视图(alpha < 1),不透明的就设置opaque为YES
5. 尽量避免出现离屏渲染

##### 1.3.3 卡顿优化-避免离屏渲染
#### 在OpenGL中,GPU有两种渲染方式
* 1. On-Screen Rendering: 当前屏幕渲染,在当前用于显示的屏幕缓冲区进行渲染操作
* 2. Off-Screen Rendering: 离屏渲染,在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作
* 离屏渲染消耗性能的原因：

        需要创建新的缓冲区
        离屏渲染的整个过程,需要多次切换上下文环境,先是从当前屏幕(On-Screen)切换到离屏(Off-Screen);
        等到离屏渲染结束后,将离屏缓冲区的渲染结果显示到屏幕上,又需要将上下文环境从离屏切换到当前屏幕
        
#### 避免离屏渲染的操作
* layer 设置了使用了 mask 蒙版
* layer 设置了圆角裁剪(masksToBounds+cornerRadius),且包含 sub layer
* layer 设置了圆角裁剪(masksToBounds+cornerRadius),且设置了layer.contents属性
* layer 设置了圆角裁剪(masksToBounds+cornerRadius),若是UIImageView，且同时设置了backgroundColor和image
* layer 设置了阴影相关属性: shadowColor/shadowOpacity/shadowRadius/shadowOffset   
* layer 设置了光栅化shouldRasterize
* 使用了 blur 模糊效果UIVisualEffectView
* layer 设置了组不透明度allowsGroupOpacity = true，并且不透明度opacity小于1
#### 我们可以通过打开Xcode -> Debug -> View Debuging -> Rendering -> Color Offscreen Rendered Yellow
开关，检查离屏渲染情况


##### 1.3.4 卡顿优化-卡顿检测
* 卡顿监控: 监控原理是对主线程的runloop注册观察者，检测耗时，记录调用栈，上报后台分析。长时间卡顿后，若未进入下一个活跃状态，
则标记为卡死崩溃上报(借鉴第三方检测工具https://github.com/UIControl/LXDAppFluecyMonitor)

        WGMonitorManageDM 类会在主线程的 RunLoop 活动中检测是否有长时间的卡顿，并在检测到卡顿时记录调用栈并上报后台进行分析。
        超时时间设定为 6 秒，以覆盖大部分用户感知场景并减少性能损耗

##### 1.3.5  卡顿优化-其他方面优化
* 加载大图: 最容易造成掉帧的原因就是加载大的图片，对应渲染指令比较多，会影响渲染的时间；[UIImage imageNamed:name]的方式加载本地大图时，
系统会自动进行图片的解码,解码过程需要CPU进行大量的计算，并且解码后的图片通常占用更大的内存，都会影响性能和用户体验
 
    显示大图前可以先加载并显示小尺寸的缩略图，等到用户确需要查看高清图时再加载完整大图
    确保大图像文件的解码最好不要放到主线程，使用CGImageSource来对图片进行解码来减少内存峰值
    可以通过NSCache对图片进行缓存；然后异步加载图片；逐步解码(CGImageSource); 

* 异步绘制: 绘制流程是当视图内容或大小变化时会调用 setNeedsDisplay 或 setNeedsLayout 标记为要更新状态，下个循环会调用 drawRect: 
进行绘制，绘制是 Core Graphics，也就是 CPU，显示靠的是 Core Animation，用的是 GPU；异步绘制就是将 Core Graphics 的动作放到
主线程外，这样主线程就不会收到绘制计算量的影响

    CPU 主要是计算视图层次结构，布局、文本的绘制、图像解码以及 Core Graphics 绘制
    GPU 是处理图层合并、图像渲染、动画和 Metal 绘制
    CPU 负责准备数据，GPU 负责渲染这些数据
    CPU层面:                
            1.简化视图层次;          
            2.尽量减少调用setNeedsDisplay/layoutSubviews(因为会导致重新绘制)         
            3.图像解码不要放主线程          
    避免离屏渲染(避免复杂的圆角、阴影效果、减少对 layer 的属性设置)         

* 线程死锁: 选择合适的同步机制取决于具体的应用场景；检测卡顿情况也要重点从同步锁来入手

        NSLock/NSRecursiveLock/NSCondition/NSConditionLock/信号量(Dispatch Semaphore)
        Dispatch Barrier栅栏函数/读写锁pthread_rwlock_t/互斥锁pthread_mutex_t/@synchronized地柜锁
        os_unfair_lock/ 原子性属性atomic/ NSOperationQueue操作队列和操作依赖
        
* IO 过密: 磁盘操作通常是阻塞性的，可以将磁盘 IO 操作放到后台线程中执行
* 跨进程通信导致卡顿: 进程间通信是一种重要的机制,允许不同的进程或应用程序之间交换信息,下面系统API调用可能会导致卡顿或性能问题

        CNCopyCurrentNetworkInfo 获取 WiFi 信息
        设置系统钥匙串 (Keychain) 中的值
        NSUserDefaults 调用写操作
        CLLocationManager 获取当前位置权限状态
        UIPasteboard 设置和获取值
        UIApplication 通过 openURL 打开其他应用




#### 2. 启动优化
#### 启动优化前我们需要先来了解下APP启动过程。iOS 13之后苹果全面将 dyld3 替代之前的 dyld2，并且在 dyld3 中增加了启动
闭包的概念，在下载/更新 App、系统更新或者重启手机后的第一次启动 App 时创建。所以 iOS13 前后对冷启动的概念会有所区别

        iOS13前:
            冷启动：App 点击启动前，系统中不存在 App 的进程，用户点击 App，系统给 App 创建进程启动；
            热启动：App 在冷启动后用户将 App 退回后台，App 进程还在系统中，用户点击 App 重新返回 App 的过程；
        iOS13后:
            冷启动：重启手机系统后，系统中没有任何 App 进程的缓存信息，用户点击 App，系统给 App 创建进程启动；
            热启动：用户把 App 进程杀死，系统中存在 App 进程的缓存信息，用户点击 App，系统给 App 创建进程启动；
            回前台：App 在启动后用户将 App 退回后台，App 进程还在系统中，用户点击 App 重新返回 App 的过程
            
#### dyld2和dyld3的主要区别就是: 【dyld3具有启动闭包】【dyld2没有启动闭包】
* 启动闭包其实就是一个缓存，用来提升启动速度的                
* 启动闭包会在重启手机或者更新/下载 App 的第一次启动才会创建        
* 启动闭包存储在沙盒的 tmp/com.apple.dyld 目录，清理缓存的时候切记不要清理这个目录               

#### 启动闭包是如何提升启动速度的？里面都有什么内容？
* dependends，依赖动态库列表         
* fixup：bind & rebase 的地址       
* initializer-order：初始化调用顺序       
* optimizeObjc: Objective C 的元数据       
* 其他：main entry, uuid…        
* 上面这些信息是每次启动都需要的，把信息存储到一个缓存文件就能避免每次都解析，进而加快启动速度       

   
#### 通俗上我们一般把冷启动定义为: 从用户点击 App 图标到启动图完全消失后的第一帧渲染完成,整个过程分为两个阶段
* main函数前: main() 函数之前，包括系统创建 App 进程，加载 MachO 文件到内存，创建启动闭包，再到 dyld 处理一系列的加载、符号绑定、初始化等工作,最后跳转到执行 main() 之前
* main函数后: 跳转到 main() 函数之后，开始执行 App 中 UI 场景的创建以及 Delegate 相关生命周期方法，到完成首屏渲染的第一帧


#### 2.1 APP启动大概流程图

        点击APP -> 内核创建APP进程 -> 将Mach-O mmap进虚拟内存 -> 加载dyld动态链接器 -> 创建启动闭包
                                                                                   |
                                                                                   |
        main函数 <- +load & Static initializer <- Runtime初始化 <- Rebase&Bind <- 加载动态库
           |
           |
        UIApplication初始化/启动mian runloop
        
 * 1.点击APP后会发送一个系统调用(execve)到内核; 内核开始创建进程；                 
 * 2.将可执行文件(Mach-O文件格式)通过内存映射技术(memory map简称mmap)映射到虚拟内存的地址空间里；           
 * 3.读取可执行文件中Load Command加载命令中的LC_LOAD_DYLINKER，进而找到动态链接加载器dyld的路径；       
 * 4.然后通过mmap将dyld映射到虚拟内存的地址空间中，找到dyld的进入函数_dyld_start,将其交给PC寄存器后，    
 后续的启动流程就交给动态链接加载器dyld；      
 * 5.dyld会创建启动闭包(重启手机或者更新/下载App的第一次启动才会创建);闭包存储在沙盒的tmp/com.apple.dyld目录;       
 * 6.有了启动闭包后，就可以用启动闭包来启动APP了;        
 * 7.将动态库通过mmap映射到虚拟内存的地址空间里；                
 * 8.将多个Mach-O(除了可执行文件，动态库静态库也属于Mach-O格式文件)进行固定修正fixup，其中包含如下             
 
        Rebase：修复内部指针(Mach-O在mmap到虚拟内存的时候，起始地址会有一个随机的偏移量slide，需要把内部的指针指向加上这个slide)
        Bind：修复外部指针(像printf等外部函数，只有运行时才知道它的地址是什么，bind就是把指针指向这个地址)       
        
        ASLR(address space layout Randomization)地址空间布局随机化                       
        ASLR技术之前程序都是在固定的地址加载的，这样就导致程序可能因为知道某个函数的地址而被植入恶意代码、修改函数的地址等        
        等带来很大的安全隐患；ASLR技术就是为了解决这个问题的。                
        ASLR会使程序每次启动后地址都会随机变化，程序里所有的代码地址都需要重新进行修复计算才能正常访问，而rebase就是为了              
        调整镜像内部指针的指向 
* 9.接下来进入Runtime阶段；              

        (1)初始化 libdispatch(其实就是GCD)
        (2)初始化 objc runtime，注册 sel，加载 category           
        ⚠️这里没有初始化 objc 的类方法等信息，是因为启动闭包的缓存数据已经包含了 optimizeObjc
* 10 接下来会进入执行+load方法和static initializer静态初始化方法；            

         两个方法特点: 调用顺序不确定，和对应文件的链接顺序有关系
         
         如何找到代码里有哪些 load 和 static initializer ? 在linkMap文件中有如下对应关系
            __mod_init_func: static initializer
            __objc_nlclslist: 实现+load 的类
            __objc_nlcatlist: 实现+load 的 Category
            
        load方法会影响启动时间，所以要尽量避免调用+load方法
        +(void)load {
            printf("1234");
        }
        函数会在二进制中的 TEXT 两个段存在：
            __text存函数二进制，
            cstring存储字符串 1234
        为了执行函数首先要访问__text触发一次Page In读入物理内存，为了打印字符串，要访问__cstring，还会触发一次Page In
        为了执行这个简单的函数，系统要额外付出两次Page In 的代价，所以 load 函数多了，page in 会成为启动性能的瓶颈
        
        
        static initializer 产生的条件
            __attribute__((constructor))
            static class object
            static object in global namespace
        ⚠️并不是所有的 static 变量都会产生静态初始化，编译器很智能，对于在编译期间就能确定的变量是会直接 inline
* 11.load&static initializer执行完后，dyld会把启动流程交给APP来启动处理；       
* 12.APP开始执行main函数，main函数里最重要的事情就是；                

        初始化 UIApplication
        启动主线程的 Runloop
* 13.进入UIApplicationDelegate，调用如下方法：
          
        willFinishLaunch           
        didFinishLaunch             
        didFinishLaunchNotification              
 
#### 2.2 虚拟内存和内存映射技术mmap(Memory Map)
#### 早期的计算机中,并没有虚拟内存的概念,任何应用被从磁盘中加载到运行内存中时,都是完整加载和按序排列的导致的
问题如下，解决方案就是引入虚拟内存

        安全问题: 由于在内存条中使用的都是真实物理地址,而且内存条中各个应用进程都是按顺序依次排列的
        那么在【进程1】中通过地址偏移就可以访问到 其他进程 的内存
        效率问题: 随着软件的发展,一个软件运行时需要占用的内存越来越多,但往往用户并不会用到这个应用的所有功能, 
        造成很大的内存浪费,而后面打开的进程往往需要排队等待
#### App 启动后会认为自己已经获取到整个App运行所需的内存空间，但实际上并没有在物理内存上为他申请那么大的空间，      
只是生成了一张 虚拟内存和物理内存关联的表(映射表)
#### 地址翻译: 当 App 需要使用某一块虚拟内存的地址时，会通过这张表查询该虚拟地址是否已经在物理内存中申请了空间        

        如果已经申请了则通过表的记录访问物理内存地址
        如果没有申请则申请一块物理内存空间并记录在表中(Page Fault缺页中断)
        这个通过进程映射表映射到不同的物理内存空间的操作叫 地址翻译 ，这个过程需要 CPU 和操作系统配合
        
#### Page Fault: 当数据未在物理内存会进行下列操作
          
        系统阻塞该进程
        将磁盘中对应Page的数据加载到内存
        把虚拟内存指向物理内存
        上述行为就就是Page Fault
#### 虚拟内存虽然解决了浪费问题，但是万一物理内存空间全都被申请了呢？就会产生内存不足的情况，为保证当前App的正常使用，      
数据加载遵循以下原则：    

        如果有空闲内存空间就放空的内存空间中
        如果没有就覆盖其他进程的数据
        具体覆盖由操作系统处理
#### 空间问题已经解决。如何解决安全问题
* 在dylib的加载过程中系统为了安全考虑引入了ASLR（Address Space Layout Randomization）地址空间随机布局技术和代码签名
        
        ASLR技术: 镜像Image/可执行文件/dylib/bundle在加载时会在其指向的地址(preferred_address)前面
        添加一个随机数偏差(slide)，防止应用内部地址被定位
#### 虚拟内存技术会产生缺页中断（Page Fault），这个过程是个耗时操作;每页耗时也有很大差距，1微秒到0.8毫秒不等

* 内存可以分为虚拟内存和物理内存;
  
        物理内存:是实际占用的内存;
        虚拟内存:在物理内存之上建立的一层逻辑地址，保证内存访问安全的同时为应用提供了连续的地址空间;
        iPhone 6s开始，物理内存的 Page 大小是 16K ;之前的设备 Page 大小是 4K;   
* 物理内存和虚拟内存以页为单位映射      

        映射关系不是一一对应的：一页物理内存可能对应多页虚拟内存；一页虚拟内存也可能不占用物理内存
* mmap 的全称是 memory map，是一种内存映射技术，可以把文件映射到虚拟内存的地址空间里,这样就可以像
直接操作内存那样来读写文件;         
* 当APP进程访问一页虚拟内存page而对应的物理内存不存在时，会触发缺页中断事件：File Backed Page In，     
当发生缺页中断时会阻塞当前进程，然后加载数据到对应物理内存，会比较耗时的
* 缺页中断: 当APP进程访问虚拟内存其对应文件内容在物理内存中不存在时会触发缺页中断，当发生缺页中断时，     
需要将文件内容读入到物理内存；iOS物理内存是有限的，当系统内存被大量应用程序和进程占用，并且新的页面需要
被加载时，可能没有足够的物理内存空间，此时一些页面可能会被置换到磁盘(虚拟内存)中，当应用程序再次访问这些
被置换出去的页面时，就会触发缺页中断

        File Backed Page In过程:      
        (1)MMU(操作系统的内存管理单元) 找到空闲的物理内存页面   
        (2)触发磁盘 IO，把数据读入物理内存 
        (3)如果是 TEXT 段的页，要进行解密(iOS 13 对这个过程进行了优化，Page In 的时候不需要解密了)      
        (4)对解密后的页，进行签名验证         
        (5)数据读入物理内存并且签名完成后，就可以继续了

* Page In(缺页中断)可以通过Xcode -> Instruments -> System Trace(系统跟踪)工具下的查看Page In次数
* Page In(缺页中断)引起的启动时间优化方案就是【二进制文件重排】
  
#### 2.3 二进制文件重排
#### 进程若直接访问物理内存是很不安全的，所以操作系统在物理内存基础上又建立了一层虚拟内存。为提高效率和方便管理，对虚拟
内存和物理内存又进行分页（Page）。当进程访问一个虚拟内存Page而对应的物理内存不存在时，会触发一次缺页中断（Page Fault），

#### 二进制文件重排其实就是通过修改代码在二进制文件的布局可以提高启动性能；      
中心思想就是: 重新排列 方法符号的顺序， 使启动的相关方法排在最前面从而减少启动Page Falut的数量


            page1                 page2
        method1 method2      method3 method4
        
        mthod1和method3是启用用到的方法，为了执行对应的代码，就需要两次Page In(page1与page2都需要从无到有加载到物理内存中)       
        二进制重排就是将method1和method3方法排列在一起，这样就可以减少一次Page In,从而提升启动速度       
#### 项目中的做法是将启动时需要调用的函数放到一起 (比如 前10页中) 以尽可能减少 page fault , 达到优化目的
       
        如何检测 page fault?
        如何重排二进制?
        如何查看自己重排成功了没有?
        如何检测自己启动时刻需要调用的所有方法? 【clang 插桩】
        
#### 2.3.1 如何检测page fault缺页中断
* 打开Xcode -> Open Developer Tool -> Instruments -> System Trace -> Choose  

![图片](https://github.com/WGFcode/WGFcodeNotes/blob/master/WGFcodeNotes/WGScreenshots/system0.png)

* 在Xcode中运行项目，然后快速点击System Trace中的录制按钮，当登录页出现时，再次点击按钮暂停录制，等待数据分析完后    
这里需要注意: 当进程还没创建就点击录制按钮会出现进程不存在报错:Process No Longer Exists,所以尽量等进程创建后点击录制      
这里想同步确实有点难；(先保证手机安装了项目，然后打开System Trace界面没有任何错误前提下，然后删除APP,然后等待APP安装成功后
点击System Trace中的监听按钮)

![图片](https://github.com/WGFcode/WGFcodeNotes/blob/master/WGFcodeNotes/WGScreenshots/system1.png)

* 图中项目的Page Fault 数量达到了6374，Page Fault的 数量和加载耗时都会随着代码增加而增加
#### 二进制重排 可以很好优化这个问题，其中心思想是重新排列 方法符号的顺序， 使启动的相关方法排在最前面从而减少        
启动Page Falut的数量。如何查看原来的方法符号顺序？ 可以通过Link Map File

        NXYXE-LinkMap-normal-arm64.txt 截取部分
        发现[WGWebVC mchntId]方法比didFinishLaunchingWithOptions先执行
        我们是否可以修改方法两个方法的执行顺序那？ 答案是可以的
        ⚠️在Xcode->Build Phases->Compile Sources可以调整文件编译顺序来调整LinkMap中显示的方法顺序
        根据这个我们把启动时要加载的源文件尽量调整到Compile Sources中前面位置进行编译
        但是这种调整源文件的方法并不能起到很大的优化空间，因为二进制排序主要是解决缺页中断内存问题
        
        0x1001D6E58  0x00000068  [392] -[WGWebVC dealloc]
        0x1001D6EC0  0x00000024  [392] -[WGWebVC mchntName]
        0x1001D6EE4  0x0000003C  [392] -[WGWebVC setMchntName:]
        0x1001D6F20  0x00000024  [392] -[WGWebVC mchntId]
        0x1001D6F44  0x0000003C  [392] -[WGWebVC setMchntId:]
        0x1001D6F80  0x00000088  [392] -[WGWebVC .cxx_destruct]
        0x1001D7008  0x00000500  [393] -[AppDelegate application:didFinishLaunchingWithOptions:]
        0x1001D7508  0x00000110  [393] ___57-[AppDelegate application:didFinishLaunchingWithOptions:]_block_invoke
        0x1001D7618  0x000001E0  [393] -[AppDelegate configureHUD]
        
#### 2.3.2 如何重排二进制
* Xcode提供了排列符号的设置: order_file(objc 源码就采用了二进制重排优化)

        (1).项目根目录通过 touch wglink.order 创建order文件(就是我们要写的方法符号排序的方法)
        (2).Xcode -> Build Settings -> Order File 设置路径: ./wglink.order
        如何编写wglink.order文件中的顺序？ 可以参考Runtime源码下的SourceCode/Runtime/libobjc.order
        
        (3)在wglink.order文件中写上如下代码 就可以调整符号(方法)顺序了
        -[AppDelegate application:didFinishLaunchingWithOptions:]

        -[WGWebVC mchntName]
        -[WGWebVC setMchntName:]
        -[WGWebVC mchntId]
        -[WGWebVC setMchntId:]
        
        (4)重新编译运行项目后，获取到linkMap文件发现方法顺序确实是调整过来了，linkMap新的方法顺序如下
        # Symbols:
        # Address    Size        File  Name
        0x100008000  0x00000500  [393] -[AppDelegate application:didFinishLaunchingWithOptions:]
        0x100008500  0x00000024  [392] -[WGWebVC mchntName]
        0x100008524  0x0000003C  [392] -[WGWebVC setMchntName:]
        0x100008560  0x00000024  [392] -[WGWebVC mchntId]
        0x100008584  0x0000003C  [392] -[WGWebVC setMchntId:]
        0x1000085C0  0x0000003C  [  4] __ZN7DeepNetC2E10DeviceTypeiRKNSt3__16vectorIiNS1_9allocatorIiEEEE
#### wglink.order文件中的方法顺序不可能全部手写呀，所以接下来就要用到自动生成order文件了
* 自动化order文件需要保证

        保证不遗漏方法
        保证方法符号正确
        保证方法符号顺序正确
* 如何获取启动加载所有函数的符号。解决方案就是【clang插桩 或叫做编译期插桩】

#### 2.3.3 clang插桩
#### clang插桩就是在代码编译期间修改已有的代码或生成新代码；编译期时，在每一个函数内部二进制源数据添加 hook     
代码来实现全局 hook 效果。[clang 官网自带代码覆盖工具SanitizerCoverage](https://clang.llvm.org/docs/SanitizerCoverage.html),这个工具里面有详细的介绍并且还有相应的Demo;项目具体使用步骤如下：

* 添加编译设置：

        Objective-C项目
        Xcode-> Build Settings-> Apple Clang - Custom Compiler Flags-> Other C Flags    
        添加:
            -fsanitize-coverage=func,trace-pc-guard
        
        Swift项目:
        Xcode-> Build Settings-> Apple Clang - Custom Compiler Flags-> Other C Flags
        添加:
            -sanitize-coverage=func
            -sanitize=undefined
#### 接下来我们通过创建一个空的OC项目(项目名称OCMachO)来详细了解下clang插桩过程
#### 首先我们就是要在Other C Flags 中添加编译设置，然后我们将[Clang官网demo](https://clang.llvm.org/docs/SanitizerCoverage.html) 中的案例代码写在ViewController.m文件中
* 代码如下:            

        -(void)viewDidLoad {
            [super viewDidLoad];
            self.view.backgroundColor = UIColor.yellowColor;
        }

        1.下面两个函数是Sanitizer工具中的两个函数，通常用于代码覆盖率分析等功能
        2.程序运行前或程序初始化阶段被编译器内部函数调用，用于设置初始状态和准备数据结构，以帮助后续的覆盖率信息的收集
        3.sanitizer(消毒杀菌剂) 是编译器提供的一组工具可以帮助开发者发现各种代码错误和潜在问题          
        void __sanitizer_cov_trace_pc_guard_init(uint32_t *start, uint32_t *stop) {
            static uint64_t N;
            if (start == stop || *start) return;
            printf("INIT: %p %p\n", start, stop);
            for (uint32_t *x = start; x < stop; x++)
                *x = ++N;
        }
        void __sanitizer_cov_trace_pc_guard(uint32_t *guard) {
            if (!*guard) return;
            void *PC = __builtin_return_address(0);
            char PcDescr[1024];
            printf("guard: %p %x PC %s\n", guard, *guard, PcDescr);
        }

#### 然后直接运行程序得到如下结果:
* start开始地址: 0x102f993d0
* end结束地址: 0x102f99408
* 通过断点打印发现开始地址和结束里面存储的是1-14这15个数字序号
 
        INIT: 0x102f993d0 0x102f99408     
        guard: 0x102f993e0 5 PC 
        guard: 0x102f993d4 2 PC d
        guard: 0x102f993fc c PC 
        guard: 0x102f99400 d PC 
        guard: 0x102f993fc c PC 
        guard: 0x102f993e4 6 PC 
        guard: 0x102f993fc c PC 
        guard: 0x102f993d0 1 PC 
        //断点
        (lldb) x/10gx 0x102f993d0
        0x102f993d0: 0x0000000200000001 0x0000000400000003
        0x102f993e0: 0x0000000600000005 0x0000000800000007
        0x102f993f0: 0x0000000a00000009 0x0000000c0000000b
        0x102f99400: 0x0000000e0000000d 0x000000000000000e
        0x102f99410: 0x0000000000000000 0x0000000000000000
#### 我们在OCMachO工程中新增两个方法 test1、test2继续打印观察结果如下: 
* 新增加两个方法后，地址信息里面存储的序号就是 1-16  
* start-end地址区间内存储的就是整个工程中符号的个数    

        INIT: 0x100331408 0x100331448
        guard: 0x100331420 7 PC 
        guard: 0x100331414 4 PC d
        guard: 0x10033143c e PC 
        guard: 0x100331440 f PC     
        guard: 0x10033143c e PC 
        guard: 0x100331424 8 PC 
        guard: 0x10033143c e PC 
        guard: 0x100331408 1 PC 
        //断点
        (lldb) x/10gx 0x100331408
        0x100331408: 0x0000000200000001 0x0000000400000003
        0x100331418: 0x0000000600000005 0x0000000800000007
        0x100331428: 0x0000000a00000009 0x0000000c0000000b
        0x100331438: 0x0000000e0000000d 0x000000100000000f
        0x100331448: 0x0000000000000010 0x0000000000000000
#### 接下来我们在touchesBegan中调用test1方法，通过lldb汇编查看调用信息        
* 调用test1方法前被添加进去了一个 bl 调用到 __sanitizer_cov_trace_pc_guard 这个函数中来


        OCMachO`-[ViewController touchesBegan:withEvent:]:
        0x100288090 <+0>:  stp    x20, x19, [sp, #-0x20]!
        0x100288094 <+4>:  stp    x29, x30, [sp, #0x10]
        0x100288098 <+8>:  add    x29, sp, #0x10
        0x10028809c <+12>: mov    x19, x0
        0x1002880a0 <+16>: adrp   x0, 9
        0x1002880a4 <+20>: add    x0, x0, #0x42c
        0x1002880a8 <+24>: bl     0x100288178  ; __sanitizer_cov_trace_pc_guard at ViewController.m:41
        0x1002880ac <+28>: mov    x0, x19
        0x1002880b0 <+32>: ldp    x29, x30, [sp, #0x10]
        0x1002880b4 <+36>: ldp    x20, x19, [sp], #0x20
        0x1002880b8 <+40>: b      0x1002886f4    ; objc_msgSend$test1
#### 总结: 静态插桩实际上是在编译期就在每一个函数内部二进制源数据添加 hook 代码 (我们添加的 __sanitizer_cov_trace_pc_guard 函数 ) 来实现全局的方法 hook 的效果

#### 我们获取到函数符号地址后，如何获取到函数对应的函数名称，我们通过**dlopen**中头文件**dlfcn.h**下的dladdr方法来获取     

        typedef struct dl_info {
                const char  *dli_fname;      //所在文件 
                void        *dli_fbase;      //文件地址 
                const char  *dli_sname;      //符号名称 
                void        *dli_saddr;      //函数起始地址 
        } Dl_info;
        
        //这个函数能通过函数内部地址找到函数符号
        int dladdr(const void *, Dl_info *);
#### 接下来我们还是在OCMachO工程验证下          
* 通过结果打印我们发现获取到函数符号地址后，通过dlopen获取到了函数名，且这些函数名都是按照调用顺序来的  

        void __sanitizer_cov_trace_pc_guard_init(uint32_t *start, uint32_t *stop) {
            static uint64_t N;
            if (start == stop || *start) return;
            printf("INIT: %p %p\n", start, stop);
            for (uint32_t *x = start; x < stop; x++)
                *x = ++N;
        }
        void __sanitizer_cov_trace_pc_guard(uint32_t *guard) {
            if (!*guard) return;
            void *PC = __builtin_return_address(0);
            // 通过函数地址找到函数符号
            Dl_info info;
            dladdr(PC, &info);
            printf("dli_fname: %s \n dli_sname: %s \n\n",info.dli_fname, info.dli_sname);
        }
        
        打印结果:  xxx: var/containers/Bundle/Application/77ED377B-7235-49A0-876B-3FAADD6624C9
        INIT: 0x100a1d3f8 0x100a1d434
        dli_fname: /private/xxx/OCMachO.app/OCMachO 
        dli_sname: main 

        dli_fname: /private/xxx/OCMachO.app/OCMachO 
        dli_sname: -[AppDelegate application:didFinishLaunchingWithOptions:] 
        dli_fname: /private/xxx/OCMachO.app/OCMachO 
        dli_sname: -[SceneDelegate window] 

        dli_fname: /private/xxx/OCMachO.app/OCMachO 
        dli_sname: -[SceneDelegate setWindow:] 
        ....

#### 接下来我们就是要获取启动加载时的所有函数符号了，一般我们都是将第一个页面出现时判断为启动加载完成，那么就可以根据     
实际项目需求在第一屏页面获取，接下来继续在OCMachO工程中的ViewController.m中去做这个事情

        #import "ViewController.h"
        #import <dlfcn.h>
        #import <libkern/OSAtomic.h>
        
        //原子队列(导入头文件#import <libkern/OSAtomic.h>)
        static OSQueueHead symboList = OS_ATOMIC_QUEUE_INIT;
        //定义符号结构体
        typedef struct{
            void * pc;
            void * next;
        }SymbolNode;
        
        @implementation ViewController

        - (void)viewDidLoad {
            [super viewDidLoad];
            self.view.backgroundColor = UIColor.yellowColor;
            [self test1];
            [self test2];
        }
        -(void)test1 {
            NSLog(@"1");
        }
        -(void)test2 {
            NSLog(@"2");
        }
        
        void __sanitizer_cov_trace_pc_guard_init(uint32_t *start, uint32_t *stop) {
            static uint64_t N;
            if (start == stop || *start) return;
            printf("INIT: %p %p\n", start, stop);
            for (uint32_t *x = start; x < stop; x++)
                *x = ++N;
        }
        //每次调用一个函数时都会先插入这个函数
        void __sanitizer_cov_trace_pc_guard(uint32_t *guard) {
            void *PC = __builtin_return_address(0);
            //PC可以获取到函数地址--> 获取到函数名
            //将PC以节点的形式存储在链表中
            SymbolNode *node = malloc(sizeof(SymbolNode));
            *node = (SymbolNode){PC,NULL};
            //入队 将每个PC存放的节点数据入对
            // offsetof 用在这里是为了入队添加下一个节点找到 前一个节点next指针的位置
            OSAtomicEnqueue(&symboList, node, offsetof(SymbolNode, next));
        }
        
        - (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event {
            NSMutableArray<NSString *> * symbolNames = [NSMutableArray array];
            while (true) {
                //遍历链表 offsetof 就是针对某个结构体找到某个属性相对这个结构体的偏移量
                SymbolNode * node = OSAtomicDequeue(&symboList, offsetof(SymbolNode, next));
                if (node == NULL) break;
                Dl_info info;
                dladdr(node->pc, &info);
                //通过函数符号地址获取到函数名
                NSString * name = @(info.dli_sname);
                
                // OC方法是-[xxx]  C语言和Block方法前面需要添加下划线_
                BOOL isObjc = [name hasPrefix:@"+["] || [name hasPrefix:@"-["];
                NSString * symbolName = isObjc ? name : [@"_" stringByAppendingString:name];
                
                //去重
                if (![symbolNames containsObject:symbolName]) {
                    [symbolNames addObject:symbolName];
                }
            }
            //取反
            NSArray * symbolAry = [[symbolNames reverseObjectEnumerator] allObjects];
            NSLog(@"通过函数符号地址找到的函数名称存放在数组中%@",symbolAry);
            //将结果写入到文件
            NSString * funcString = [symbolAry componentsJoinedByString:@"\n"];
            NSString * filePath = [NSTemporaryDirectory() stringByAppendingPathComponent:@"lb.order"];
            NSData * fileContents = [funcString dataUsingEncoding:NSUTF8StringEncoding];
            BOOL result = [[NSFileManager defaultManager] createFileAtPath:filePath contents:fileContents attributes:nil];
            if (result) {
                NSLog(@"%@",filePath);
            }else{
                NSLog(@"文件写入出错");
            }
        }
        //打印结果:
        通过函数符号地址找到的函数名称存放在数组中(
            "_main",
            "-[AppDelegate application:didFinishLaunchingWithOptions:]",
            "-[SceneDelegate setWindow:]",
            "-[SceneDelegate scene:willConnectToSession:options:]",
            "-[SceneDelegate window]",
            "-[ViewController viewDidLoad]",
            "-[ViewController test1]",
            "-[ViewController test2]",
            "-[SceneDelegate sceneWillEnterForeground:]",
            "-[SceneDelegate sceneDidBecomeActive:]",
            "-[ViewController touchesBegan:withEvent:]"
        )
        /private/var/mobile/Containers/Data/Application/B7F8D46B-859E-4656-A268-47CA4580B1C3/tmp/lb.order
    
* 1.第一步就是将符号地址信息以节点node的形式保存在原子队列中     
* 2.遍历原子队列中的节点node,然后通过函数符号地址找到对应的函数名称     
* 3.将函数名称保存在沙河指定的位置下          
* 4.取出文件中的信息复制到我们项目根目录下的order文件中       
* 5.这样就可以通过调整启动时的方法调用来减少Page In缺页中断的次数来达到启动优化的目的       

#### 接下来我们拿项目NXYXE来实战         

* 1.编译器设置        

        Xcode-> Build Settings-> Apple Clang - Custom Compiler Flags-> Other C Flags               
        添加:     
            -fsanitize-coverage=func,trace-pc-guard
             
* 2.cd到项目根目录，通过touch wglink.order创建order文件，然后设置order文件路径

        Xcode-> Build Settings-> Linking - General-> Order File
        添加:
            ./wglink.order
* 3.在登录页面新增如下代码(实际上就是上面我们验证过的代码)      

        #import <dlfcn.h>
        #import <libkern/OSAtomic.h>
        static OSQueueHead symboList = OS_ATOMIC_QUEUE_INIT;
        //定义符号结构体
        typedef struct{
            void * pc;
            void * next;
        }SymbolNode;
        
        void __sanitizer_cov_trace_pc_guard_init(uint32_t *start, uint32_t *stop) {
            static uint64_t N;
            if (start == stop || *start) return;
            printf("INIT: %p %p\n", start, stop);
            for (uint32_t *x = start; x < stop; x++)
                *x = ++N;
        }
        //每次调用一个函数时都会先插入这个函数
        void __sanitizer_cov_trace_pc_guard(uint32_t *guard) {
            void *PC = __builtin_return_address(0);
            //PC可以获取到函数地址--> 获取到函数名
            //将PC以节点的形式存储在链表中
            SymbolNode *node = malloc(sizeof(SymbolNode));
            *node = (SymbolNode){PC,NULL};
            //入队 将每个PC存放的节点数据入对
            // offsetof 用在这里是为了入队添加下一个节点找到 前一个节点next指针的位置
            OSAtomicEnqueue(&symboList, node, offsetof(SymbolNode, next));
        }


        - (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event {
            NSMutableArray<NSString *> * symbolNames = [NSMutableArray array];
            while (true) {
                //遍历链表 offsetof 就是针对某个结构体找到某个属性相对这个结构体的偏移量
                SymbolNode * node = OSAtomicDequeue(&symboList, offsetof(SymbolNode, next));
                if (node == NULL) break;
                Dl_info info;
                dladdr(node->pc, &info);
                //通过函数符号地址获取到函数名
                NSString * name = @(info.dli_sname);
                
                // OC方法是-[xxx]  C语言和Block方法前面需要添加下划线_
                BOOL isObjc = [name hasPrefix:@"+["] || [name hasPrefix:@"-["];
                NSString * symbolName = isObjc ? name : [@"_" stringByAppendingString:name];
                
                //去重
                if (![symbolNames containsObject:symbolName]) {
                    [symbolNames addObject:symbolName];
                }
            }
            //取反
            NSArray * symbolAry = [[symbolNames reverseObjectEnumerator] allObjects];
            NSLog(@"通过函数符号地址找到的函数名称存放在数组中%@",symbolAry);
            //将结果写入到文件
            NSString * funcString = [symbolAry componentsJoinedByString:@"\n"];
            NSString * filePath = [NSTemporaryDirectory() stringByAppendingPathComponent:@"nxyxe.order"];
            NSData * fileContents = [funcString dataUsingEncoding:NSUTF8StringEncoding];
            BOOL result = [[NSFileManager defaultManager] createFileAtPath:filePath contents:fileContents attributes:nil];
            if (result) {
                NSLog(@"nxyxe.order path: %@",filePath);
            }else{
                NSLog(@"文件写入出错");
            }
        }
* 4.然后运行项目等到登录页面出现时点击屏幕即可获取到启动时加载的所有方法，然后将这些方法写入到      
项目根目录的wglink.order文件中 

        //下面是截取的部分order文件中的内容，可以发现后续优化我们可以把load方法给去掉，确实比较占用启动时间和空间
        +[NSArray(WGHookNSArray) load]
        +[NSMutableArray(WGHookMutableArray) load]
        +[UIControl(WGUIControl) load]
        +[NSMutableDictionary(WGHookMutableDictionary) load]
        _UntrusserrriolaRediscour
        _CtuolaRediscoursubge
        _main
        -[AppDelegate application:didFinishLaunchingWithOptions:]
        _Paronymousuiculturocyan
        _Symphiliackpuddtioner
        ___copy_helper_block_e8_32s40s48s
        -[AppDelegate setWindow:]
        -[AppDelegate configureHUD]
        _UIOffsetMake
        +[WGCaptureCrashManage wg_defaultSet]
        ___copy_helper_block_e8_32b
        -[AppDelegate monitoringNetwork]
        ___copy_helper_block_e8_32w
        +[WGBaseNavigationVC initialize]
        -[WGBaseNavigationVC pushViewController:animated:]
        -[WGNewLoginVC viewDidLoad]
        -[WGBaseVC viewDidLoad]
        -[WGNewLoginVC layoutUI]
        -[WGNewLoginVC setLoginType:]

        
        这里需要注意⚠️我们把文件都写到沙河的temp文件目录了，对于真机设备如何获取路径拿到数据？
        /private/var/mobile/Containers/Data/Application/F3986A20-0CCF-4D4D-A90A-209C4173487C/tmp/nxyxe.order
        
        Xcode-> Window-> Devices and Simultor-> 选中指定的项目NXYXE ->选中...然后Download Container进行下载
        
* 5.我们通过NXYXE项目取没有二进制排序前的图和二进制排序后的图进行对比如下

启动优化-二进制重排前效果图
![图片](https://github.com/WGFcode/WGFcodeNotes/blob/master/WGFcodeNotes/WGScreenshots/system2.png)
启动优化-二进制重排后效果图
![图片](https://github.com/WGFcode/WGFcodeNotes/blob/master/WGFcodeNotes/WGScreenshots/system3.png)


     
 
#### 2.4 冷启动优化方案 总结 
##### pre-main阶段优化
* 尽量使用静态库，减少动态库的使用,如果要用动态库，尽量将多个dylib动态库合并成一个
* 尽量避免对系统库使用optional linking(optional会有些额外的检查),若用到的系统库在所有支持的系统版本上都有，就设置为required
    
        Xcode -> Build Phases -> Link Binary With Libraries 
* 减少Objective-C Class、Selector、Category的数量，可以合并或者删减一些OC类
* 删减一些无用的静态变量，删减没有被调用到或者已经废弃的方法 
* 将不必须在+load中做的事情尽量挪到+initialize中，+initialize是在第一次初始化这个类之前被调用，+load在加载类的时
候就被调用；或者做load方法迁移
* 尽量不要用C++虚函数，创建虚函数表有开销
* 在初始化方法中不创建线程、不调用dlopen()，dlopen()有性能和死锁的可能性
* 延迟初始化(延迟一些非必要在启动时初始化的工作)
* 减少主线程阻塞(启动阶段尽量避免主线程中处理耗时任务、文件IO、网络请求等，将这些操作放在子线程中处理)

##### main阶段优化
* 尽量不要使用xib/storyboard，而是用纯代码作为首页UI，如果要用xib/storyboard，不要在xib/storyboard中存放太多的视图
* 使用简单的广告页作为过渡，将首页的计算操作及网络请求放在广告页展示时异步进行。
* 对application:didFinishLaunchingWithOptions:里的任务尽量延迟加载或懒加载
* 不要在NSUserDefaults中存放太多的数据，NSUserDefaults是一个plist文件，plist文件会被反序列化一次
* 避免在启动时打印过多的log，少用NSLog，因为每一次NSLog的调用都会创建一个新的NSCalendar实例
* 为了防止使用GCD创建过多的线程，解决方法是创建串行队列，或者使用带有最大并发数限制的NSOperationQueue
* 不要在主线程执行磁盘、网络、Lock或者dispatch_sync、发送消息给其他线程等操作
* UIImage(named:)和UIImage(contentsOfFile:)要根据需要选择      
      
        UIImage(named:): 会将图片加载到系统的图片缓存中，适用于经常使用的小图片,会占用大量内存，可能导致内存紧张
        UIImage(contentsOfFile:): 直接从文件加载图片，不进行缓存

        
#### 2.5 ipa构造流程

                        
        源文件(.m/.c/.swift文件) --【编译】-- 目标文件(.o) --【链接】-- Mach-O文件
                                               +            
                                           动态库(UIKit.tdb)           
                                               +
                                           静态库(libAFNetwork.a)
                                               +
                                           动态库/静态库(.framework)

       xxx.xcassets -- 编译 -- xxx.car文件 
       xxx.storeboard -- 编译 -- xxx.storeboardc文件 
       
       Mach-O文件 + .car + .storeboardc + ... -> .app  ---签名--- .app

* 源文件(.m/.c/.swift 等)是单独编译的，输出对应的目标文件(.o)
* 目标文件和静态库/动态库一起，链接出最后的 Mach-O
* Mach-O 会被裁剪，去掉一些不必要的信息
* 资源文件如 storyboard，asset 也会编译，编译后加载速度会变快
* Mach-O 和资源文件一起，打包出最后的.app
* 对.app 签名，防篡改







#### 3. 内存相关优化
#### 内存泄漏: 程序在运行过程中，分配的内存未能及时释放，导致程序占用的内存持续增加，内存泄漏发生情况如下: 
* 循环引用：      

        对象A强引用对象B,对象B又强引用对象A; [用weak解决循环引用]
        
* Block导致的内存泄漏：    

        Block会对其内部的对象强引用，容易形成循环引用; [用weak解决循环引用]
* NSTimer导致的内存泄漏:
    
        NSTimer的target-action机制容易导致self与timer之间的循环引用 [使用NSPoxy代理进行转发]
* 委托模式(Delegate代理)中的内存泄漏； 

        [根据具体场景选择使用weak或strong修饰delegate属性]
* 非OC对象的内存管理:   

        CoreFoundation框架下的对象(如CI、CG、CF开头的对象)和C语言中的malloc使用完毕后需手动释放(CFRelease、free)
    
#### 内存泄漏检测工具: 基本原理是监控和管理对象的生命周期，检测那些在生命周期结束后仍未被释放的对象FBRetainCycleDetector 
是由 Facebook 开源的一个用于检测 iOS 应用中的内存泄漏的工具

        对象图构建：FBRetainCycleDetector 首先会从一个指定的对象开始，递归地遍历该对象的所有属性和关联对象，构建一个引用图
        深度优先搜索 (DFS): 查找路径起始和终止于同一个对象的闭环
        循环检测: 找到一个循环路径时,会将其标记为潜在的内存泄漏,检测到的循环会以易于理解的方式输出，帮助开发者定位和解决问题
        对象图的遍历和循环检测可能会带来性能开销,主要用于开发和调试阶段,不建议在生产环境中长期使用




#### 4. 耗电量优化
#### 耗电的主要来源
* 1.CPU处理(Processing)
* 2.网络(Networking)
* 3.定位(Location)
* 4.图像(Graphics)

#### 耗电优化方案
* 1.尽可能降低CPU、GPU功耗(上面已经提过CPU、GPU的优化)
* 2.少用定时器
* 3.优化I/O操作(文件的读写):  

        尽量不要频繁写入小数据,最好批量一次性写入;            
        读写大量重要数据时,考虑用dispatch_io,它提供了基于GCD的异步操作文件I/O的API,用dispatch_io系统会优化磁盘访问       
        数据量比较大的,建议使用数据库(如SQLite、CoreData)            
* 4.网络优化
 
        减少、压缩网络数据(XML体积大、JSON体积小、也有用Protocol buffer前提是服务器也用Protocol buffer)      
        如果多次请求的结果是相同的,尽量使用缓存(NSCache)          
        使用断点续传,否则网络不稳定时可能多次传输相同的内容          
        网络不可用时,不要尝试执行网络请求              
        让用户可以取消长时间运行或者速度很慢的网络操作,设置合适的超时时间         
        批量传输(如下载视频流时,不要传输很小的数据包,直接下载整个文件或一大块一大块的下载;减少发送网络请求的数量)            
* 5.定位优化

        如果只是需要快速确定用户位置,最好用系统库CoreLocation中CLLocationManager的requestLocation方法,
        定位完成后,会自动让定位硬件断电
        
        如果不是导航应用,尽量不要实时更新位置,定位完毕就关闭定位服务
        尽量降低定位精度,比如尽量不要使用精度最高的KCLLocationAccuracyBest
        需要后台定位时,尽量设置pausesLocationUpdatesAutomatically为YES(若用户不太可能移动时系统会自动暂停位置更新)
        




#### 5.安装包瘦身

![图片](https://github.com/WGFcode/WGFcodeNotes/blob/master/WGFcodeNotes/WGScreenshots/ipa.png)
* _CodeSignature: ipa包签名文件的存放文件夹；存放每个文件的hash值；
* embedded.mobileprovision: 包含证书配置、设备UDID等相关信息
* YXF: 可执行文件Mach-O文件
* PlugIns: App创建的扩展Extensions，比如Widget、Push和Share等
* Frameworks: 

        SwiftSupport: libSwiftxxx 等一系列 Swift 库 
        其他依赖库: carthage方式的第三方库会在该文件中；
        而swiftPackageManage和cocoaPods方式不会出现在该文件中，猜测应该是被打进了可执行文件中
* en.lproj / zh-Hans.lproj: App所支持的语言文件
* Info.plist：项目配置表
* Assets.car：Assets.xcassts在编译过程中生成的最终展示文件，默认里面存放各种分辨率图片

#### 通过分析ipa包大题可以分为如下几个方面，而APP瘦身主要从以下几个方面进行优化
* Exectutable: 编译后的可执行文件
* Resources：图⽚、⾳频、视频等资源⽂件

        图片资源：Assets.car/bundle/png/jpg 等
        视频/音频资源：mp4/mp3 等
        静态网页资源：html/css/js 等
        视图资源：xib/storyboard 等
        其他：文本/字体/证书 等
* Framework：项目中使用的动态库
* Pulgins：Application Extensions

#### 应用瘦身优化方案有以下几种
* 编译器优化
* 资源文件优化
* 可执行文件优化
* Extension优化
* 静态库瘦身

#### 5.1 编译器优化
* 从架构层面，如果是老项目设置放弃支持armv7(支持4s和4)架构，如果不需要模拟器可以放弃模拟器架构
    
        Xcode -> Build Settings -> Architectures
        
        armv7｜armv7s｜arm64 : ARM处理器的指令集
        i386｜x86_64 : Mac处理器的指令集
        
        模拟器32位: i386架构
        模拟器64位: x86_64架构
        真机32位: armv7 / armv7s架构
        真机32位: arm64架构
* 无用代码剥离：去除在程序运行过程中永远不会被执行到的代码。这些代码可能是由于条件判断、未使用的函数或类等原因而不会被调用

        Xcode -> Build Settings -> Dead Code Stripping
        
* 按需设置编译器优化级别：

        Xcode -> Build Settings -> Optimization Level
        Debug: 设定为 None[-O0]  Release: 设定为 Fastest,Smallest[-Os]
* 生成调试符号: 符号主要用于调试器能够将二进制指令映射到源程序中的函数、变量、类等元素，帮助开发者理解程序在运行过程中的行为，方便定位
和解决问题;若不考虑发布后的调试便利性，可以将其设置为NO来减少包体积

        函数符号:对于每个函数，调试符号包含其名称、参数信息、返回值类型以及在二进制文件中的位置
        变量符号:变量符号包含变量的名称、类型、作用域和存储位置等信息
        类和对象符号:对于类，调试符号包含类名、继承关系、成员变量和成员函数等信息
    
        Debug: 设置为YES，方便调试   Release: 设置为NO  设置为NO断点就无法使用了
        Xcode -> Build Settings -> Generate Debug Symbols 
        
        调试符号会增加二进制文件的大小，增加的大小取决于项目的规模和复杂程度
        调试符号本身对性能基本没有影响，不过，在编译过程中，生成调试符号会稍微增加编译时间
* 无用符号剥离
        
        虽然通过Strip Linked Product剥离了调试符号和符号信息，但是通过设置Release下的
        dSYM来还原我们的堆栈符号信息
        Debug Information Format -> Release DWARF with dSYM File

        DEBUG下设为NO，RELEASE下设为YES
        Xcode -> Build Settings -> Strip Linked Product
        
        Deployment Postprocessing是Strip的总开关；只有Deployment Postprocessing这里设置了YES
        Strip Debug Symbols During Copy和Strip Linked Product设置为YES才会生效
        
        Strip Linked Product: 对最终的二进制文件是否进行去除一些不必要的符号信息和调试信息
        Strip Debug Symbols During Copy: 在复制过程中去除调试符号
* 隐藏符号信息来提升安全性/Release模式下设置为YES可以减少包体积: 

        Symbols Hidden by Default: 符号(函数、变量、类等的名称和相关信息)是否默认被隐藏            
        使用场景: 构建静态库和框架 / 提高应用安全性                 
        框架内部的实现细节可以通过隐藏符号来保护，只将供外部使用的类和方法通过合适的访问控制和符号可见性设置暴露给开发者
    

#### 5.2 资源文件优化

##### [linkMap文件是什么？](https://www.jianshu.com/p/34d579eeeba5)
##### 源码经过编译、链接，最终生成一个可执行文件；编译阶段，每个类会生成对应的.o文件；链接阶段，会把.o文件     
和动态库链接在一起；Link Map File就是一个记录链接相关信息的纯文本文件

* Link Map File是链接映射文件，Xcode生成可执行文件Mach-O时一并生成的，用于记录链接相关的信息如下:      

        可执行文件的路径
        CPU架构
        .o目标文路径
        方法符号
* Link Map File作用:      

        查看代码加载顺序
        理解内存分段分区
        Crash 时通过 Symbols 定位源码的机制
        分析可执行文件中类或库体积，优化包体积
* 生成 Link Map File

        设置并获取到linkMap文件路径
        Xcode -> Build Settings -> Write Link Map File -> YES
        Xcode -> Build Settings -> Path to Link Map File -> 设置生成linkMap文件路径

        linkMap应用场景:
        1.体积优化‌：通过分析LinkMap文件，可以了解安装包中各个模块的体积贡献，从而进行有针对性的优化，
        减少不必要的代码和资源，缩小安装包体积‌
        2.调试和故障排查‌：在应用发生崩溃时，LinkMap文件可以帮助还原崩溃现场，通过符号信息定位问题源头，
        加速调试过程‌
        
##### linkMap文件内容包含三部分: (https://www.jianshu.com/p/553f43eca0f8)
* 路径部分，展示生成的相关文件路径

        Path: 是.app文件路径
        Object files: 是.o文件路径

        #Path: /Users/baicai/Library/Developer/Xcode/DerivedData/NXYXE-hfacokxfsfvxedcuemnrjpsaqdfh/
        Build/Products/Debug-iphoneos/NXYXE.app/NXYXE
        # Arch: arm64
        # Object files:
        [  0] linker synthesized
        [  1] objc-stubs-file
        [  2] stubs-got-file
        [  3] objc-file
        [  4] /Users/baicai/Desktop/WLKProject/NXYJHXEProject/NXYXE/WGLib/CloudWalkSDK/libs/
        libDeepNetV2.a[arm64][2](DeepNet.o)
        [ ...]... 省略
 
        Object files:保存了所有用到的类生成的.o文件，也包括用到的dylib库;前面[num]是序号，类是按照顺序保存的，      
        后续可以通过序号查到具体对应的哪个类        
* (段表)Sections: 
      
        Mach-O 文件中的虚拟地址最终会映射到物理地址上。这些地址被分成不同的Segement：
            __TEXT段: 包含Mach header，被执行的代码和只读常量（如C 字符串），只读可执行
            __DATA段: 包含全局变量，静态变量等，可读写
            __LINKEDIT段: 包含了加载程序的元数据，比如函数的名称和地址，只读
        Segement 划分成了不同的 Section，不同的 Section 存储着不同的信息
        
        描述了每个目标文件的节(Section)信息(起始地址、大小等信息);二进制文件中，代码和数据是按照不同的节来组织的     
        包含代码段（__TEXT）和数据段（__DATA） 
        
        # Sections:
        # Address    Size        Segment    Section
        0x100008000  0x00D9308C  __TEXT  __text  //代码节，存放机器编译后的代码
        0x100D9B08C  0x00000058  __TEXT  __textcoal_nt
        0x100D9B0E4  0x00004E00  __TEXT  __stubs //用于辅助做动态链接代码(dyld)
        0x100D9FEE4  0x00004E18  __TEXT  __stub_helper //用于辅助做动态链接
        0x100DA4CFC  0x00024040  __TEXT  __objc_stubs
        0x100DC8D3C  0x00083FAC  __TEXT  __gcc_except_tab
        0x100E4CCF0  0x000AFF58  __TEXT  __cstring //代码运行中包含的字符串常量
        0x100EFCC80  0x0002A12D  __TEXT  __const   //存储const修饰的常量
        0x100F26DAE  0x00005BFC  __TEXT  __ustring
        0x100F2C9AA  0x00055F5A  __TEXT  __objc_methname  //objc的方法名称
        0x100F82904  0x00004B5E  __TEXT  __objc_classname //类名
        0x100F87462  0x0000C7DB  __TEXT  __objc_methtype  //方法类型
        0x100F93C40  0x00003138  __TEXT  __swift5_typeref
        0x100F96D78  0x00001D0C  __TEXT  __swift5_capture
        0x100F98A84  0x000034B8  __TEXT  __constg_swiftt
        0x100F9BF40  0x00002233  __TEXT  __swift5_reflstr
        0x100F9E174  0x0000251C  __TEXT  __swift5_fieldmd
        0x100FA0690  0x0000035C  __TEXT  __swift5_proto
        0x100FA09EC  0x000002F8  __TEXT  __swift5_types
        0x100FA0CE4  0x000001B8  __TEXT  __swift5_builtin
        0x100FA0E9C  0x0000004C  __TEXT  __swift5_mpenum
        0x100FA0EE8  0x0000006C  __TEXT  __swift5_protos
        0x100FA0F54  0x000005B8  __TEXT  __swift5_assocty
        0x100FA150C  0x0001FE00  __TEXT  __unwind_info
        0x100FC1310  0x000257A4  __TEXT  __eh_frame
        0x100FE8000  0x0000019E  __TEXT  __oslogstring
        0x100FEC000  0x00001800  __DATA  __got   //存储引用符号的实际地址，类似于动态符号表
        0x100FED800  0x00003400  __DATA  __la_symbol_ptr //懒加载的函数指针地址
        0x100FF0C00  0x000019C0  __DATA  __mod_init_func //模块初始化的方法
        0x100FF25C0  0x0001F6B8  __DATA  __const //存储constant常量的数据(使用extern导出的const修饰的常量)
        0x101011C78  0x00027EE0  __DATA  __cfstring //Core Foundation 字符串
        0x101039B58  0x00001930  __DATA  __objc_classlist //OC类列表和类信息映射了__objc_data的地址
        0x10103B488  0x00000050  __DATA  __objc_nlclslist //OC 的 +load 函数列表，
        0x10103B4D8  0x000002A0  __DATA  __objc_catlist   //categories分类列表
        0x10103B778  0x00000070  __DATA  __objc_nlcatlist //categories的+load函数列表
        0x10103B7E8  0x00000400  __DATA  __objc_protolist //协议列表
        0x10103BBE8  0x00000008  __DATA  __objc_imageinfo //镜像信息
        0x10103BBF0  0x000AD8D8  __DATA  __objc_const //OC常量。保存objc_classdata结构体数据
        0x1010E94C8  0x00011658  __DATA  __objc_selrefs //引用的 OC 方法
        0x1010FAB20  0x000000C8  __DATA  __objc_protorefs //引用的 OC 协议
        0x1010FABE8  0x00001968  __DATA  __objc_classrefs //引用的 OC 类
        0x1010FC550  0x00000E50  __DATA  __objc_superrefs //引用的 OC超类
        0x1010FD3A0  0x000042CC  __DATA  __objc_ivar //ivar指针
        0x101101670  0x0001AB80  __DATA  __objc_data //用于保存类需要的数据
        0x10111C1F0  0x0002FE40  __DATA  __data //存放了协议和已经初始化的静态量
        0x10114C030  0x000000B8  __DATA  __swift_hooks
        0x10114C0E8  0x000000B8  __DATA  __swift51_hooks
        0x10114C1A0  0x00000190  __DATA  __s_async_hook
        0x10114C330  0x000000B0  __DATA  __swift56_hooks
        0x10114C3E0  0x000A15D0  __DATA  __bss  //存储未初始化的静态量
        0x1011ED9B0  0x00002458  __DATA  __common //存储导出的全局的数据

               
* (符号表)Symbols:

        Address：方法代码的地址
        Size：方法占用的空间
        File：文件的编号
        Name：.o文件里面的方法符号
 
        记录了程序中的符号(类名、变量名、方法名)(记录着每个方法及占用的大小);
        每个符号，会有其对应的目标文件和节信息，这样可以知道某个符号是在哪个目标文件的哪个节中定义的;
        比如方法setEntity: 可以发现在Object files:中的编号是331   
        
        Symbols 部分的 File 顺序是和 Target -> Build Phase -> Compile Sources 的文件顺序一致的       

        # Symbols:
        # Address    Size        File  Name
        0x100008000  0x0000003C  [4] __ZN7DeepNetC2E10DeviceTypeiRKNSt3__16vectorIiNS1_9allocatorIiEEEE
        0x10000803C  0x0000003C  [4] __ZN7DeepNetC1E10DeviceTypeiRKNSt3__16vectorIiNS1_9allocatorIiEEEE
        0x100008078  0x00000034  [4] __ZN7DeepNetD2Ev
        0x1000080AC  0x0000000C  [4] ___clang_call_terminate
        ......       ......       X  ......
        0x100150CD0  0x00000070  [331] -[WGEnterInterfaceVC setEntity:]
        0x100150D40  0x00000E90  [331] -[WGEnterInterfaceVC layoutUI]
        0x1001CFB90  0x00000038  [386] -[WGYearMonthView clickCancelBtn]
        0x1001CFBC8  0x00000048  [386] -[WGYearMonthView clickConfirmBtn]
        0x1001CFC10  0x00000050  [386] -[WGYearMonthView numberOfComponentsInPickerView:]


* 删除⽆⽤的资源⽂件：使用工具LSUnusedResources检查项目中无用的资源(图片资源/html/xib/storeboard/.strings等)
* 分析linkMap文件，查看每个类或者库所占用的空间大小，可快速定位需要优化的类或静态库来减少包体积,可以使用两个工具进行分析:
[linkMap](https://github.com/jayden320/LinkMap)
[LinkMapParser](https://github.com/zgzczzw/LinkMapParser)

        (1)使用linkMap工具查询每个文件占用的大小，然后进行优化比如引入了第三方库，但是这些集成的库中有些功能是
        不需要的就可以剔除来减少体积
        (2)使用LinkMapParser工具可以查询每个目标文件占用的大小，并且可以分析两个linkMap文件之间哪些文件
        的内存变大了

* 压缩图⽚⼤⼩
[ImageOptim无损压缩工具](https://imageoptim.com/mac) 直接把压缩后的图片替换掉工程里的原图片，省时省力

        支持多种图片格式(PNG/JPEG/GIF等)的无损压缩 
        有桌面应用程序，对于本地文件处理更方便，无需网络连接即可使用
        压缩比率低于Tinypng;开源免费软件，无使用次数和文件数量的限制
    
[Tinypng有损压缩工具](https://tinypng.com/)

    TinyPNG 主要支持(PNG/JPEG/WebP格式)的有损压缩
    网页在线服务，无需安装软件，但依赖网络
    压缩比率达到 50%-70%；一次最多支持上传 20 张图片

        1.将图片放入Assets.xcassets，因为xcassets里的@2x和@3x图片，在上传时，会根据具体设备分开对应分辨率的图片，
        不会同时包含，而放入.bundle中的都会包含，所以要尽量把图片放入xcassets中；.bundle支持多语言.xcassets 不支持
        建议小图放在.xcassets管理，大图放在.bundle管理
        
        2.大于100KB的图就不要放到xcassets中了，大图可以将格式转为webP格式，webP能够把图片压缩到很小，但是
        肉眼看不出来差别(小二项目中@2x启动图都770KB,转为webP格式后大小为17KB),大图直接放在项目目录中，然后
        通过Bundle.main.path(forResource:ofType:)就可以加载
        
        png: 无损压缩(保存和打开过程图片质量不会有任何损失)的图像格式，支持透明度(alpha通道)；比同质量的JPEG格式要大
        
        jpeg:有损压缩(去除图像中的一些细节信息来减少文件大小，压缩比不太高的情况下，人眼很难察觉到质量的下降)的图像格式
         
        webp:谷歌开发的一种现代图片格式，结合了PNG的无损和JPEG的有损压缩有点，支持透明度，保证图片质量同时减少文件大小
        主要用于网页开发来提高网页加载速度，iOS中对webp格式也是支持的
        
        两个方式管理图片:一种是在项目中添加文件夹存放,另一种是放在Assets.xcassets管理;Assets.xcassets它会把里边的
        所有 png 格式的图片压缩成一个Assets.car文件,压缩比率比其他方式管理图片要高，大大减少图片体积

* 删除Localizable.strings中没有使⽤的字符串：多语⾔⽂件占用内存也会比较大
* 按需加载资源文件：On-Demand Resource,为资源添加标签(选择项目中图片，然后设置tag，最终会在Resource Tags标签下显示)

        ODR中的资源是在APP打包的时候确定的，不进行版本更新就无法更新这些资源。       
        ODR的资源是存放在苹果Server的，我们不需要再用自己的服务器

        ODR的三种类型
        (1)initial install Tags：      
        此种类型的资源会随着APP从App Store的下载而下载，会影响ipa的大小，也就是说资源会包含在ipa包内。        
        (2)Prefetched Tag Order：                
        此种类型的资源会在APP下载后开始下载下载相应的资源，下载会有先后顺序，这种不会影响ipa包的大小，也就是说资源不在ipa包内。      
        (3)Download Only On Demand：          
        此种类型的资源会在必须的时候主动触发下载，这是开发者自己控制下载时机的         

        一个资源的标签名是可以任意取的；一个资源可以打多个标签        
        1.检查资源是否被下载           
        conditionallyBeginAccessingResourceWithCompletionHandler        
        2.从APP Server开始下载资源          
        beginAccessingResourceWithCompletionHandler         
    
        On-Demand Resource优点        
        可以减小应用的大小，使得下载更快，提升用户体验;       
        一些固定的应用资源懒加载             
        操作系统会在磁盘不够的时候清理ODR               

        Target -> Resource Tags -> Download Only On Demand

#### 5.3 可执行文件优化
* 去掉无用的第三方库；整理重复的第三方库
* 对可执行文件进行瘦身，就是找到并删除无用代码的过程



#### 5.4 Extension优化
* 如果App Extension使用了和Main Target一样的静态库，那么可能会存在两份静态库引入包体积增大，
所以如果可以，就把相关依赖的静态库该成动态库

* 使⽤独⽴的Localizable.strings⽂件: 多个Extension时尽量不要用main target的Localizable文件而是单独创建一份

        Extension的资源是各⾃独⽴的，打包后，每个Extension都有⼀份完整的Localizable.strings，所以要分开按需创建
* 剔除多余的三⽅库

#### 5.5 静态库瘦身
* 针对项目中引入的第三方静态库，通过lipo -info 查看支持的架构指令集，我们可以按需引入指定的架构指令集
而把不用的架构指令集剔除掉



#### ipa包瘦身总结
* 利用LSUnusedResources工具检查剔除项目中无用的资源(图片/音视频文件/html等)
* 应用中的图片可以利用压缩工具对图片进行压缩处理;可以使用ImageOptim、TingPNG等压缩工具
* 小的图片@2x/@3x倍图尽量放在Assets.xcassets中进行管理，因为编译器会将图片最终打包压缩成Assets.car文件
这种压缩比其他方式管理图片要高可以大大减少图片体积；针对大的图片如启动图等使用webp格式的图片可以大大减少图片体积
* 通过linkMap工具分析linkMap文件中各个类、方法、第三方库的目标文件(.o)所占用的大小，进行分析优化
* 查看架构支持，我们现在可以只支持arm64架构，摒弃掉armv7/arm7/x86_64架构，针对第三方静态库也可以通过lipo命令
行进行查看支持的架构，然后导出我们需要的架构，摒弃不需要的架构支持来减少包体积
* 删除多语言开发中的多语言文件Localizable.strings中无用的字符串
* 通过为资源设置标签tags,来进行按需加载(从苹果服务器下载所需资源，下载时机由我们程序员自己控制)





### 6.Mach-O文件
#### Mach-O的全称为Mach Object，是OS X与iOS上的一种可执行文件格式,通过可视化工具[MachOView](https://sourceforge.net/projects/machoview/files/latest/download)
可以查看Mach-O文件的内部结构，除了MachOView工具外还可以通过**otool**命令行工具进行查看
* Debug模式下生成的ipa中通过zip解压从Payload文件中找到可执行文件，通过MachOView工具无法打开
而Release模式下可以打开，猜测可能是因为Debug模式下某些符号信息或者权限问题导致工具无法打开MachO文件

        otool -h  mach-o文件路径   查看Mach-O文件头           
        otool -lV mach-o文件路径   查看Mach-O的加载命令             
        otool -L  mach-o文件路径   查看依赖的动态库               
        file mach-o文件路径        查看是否是Mach-o格式的文件                 

#### 常见的Mach-O文件类型
* 1.MH_OBJECT: 可再定址的目标文件,其实就是.o文件和静态库(.a静态库、.framework静态库)

        .o目标文件：源文件编译而成的目标文件          
        .a静态库文件：由多个.o文件编译链接合并而成的文件                  
        
        借助clang命令将OC的.m文件编译成.o目标文件                  
        clang -c oc文件.m -o 目标文件.o               
        
        -c 是compile的意思。代表只执行预处理、编译、汇编步骤。即-c可以生成目标文件            
        -o 是output的意思。代表指定输出的文件的目录和名称，省略-o参数目标文件默认和源文件同名              
        
        可以通过 file xxx.o 验证.o文件属于Mach-O文件格式              
    
* 2.MH_EXECUTE: 可执行文件; 可执行文件是可以在终端中直接运行的文件
    
        可执行文件和目标文件(.o)的区别主要在于可执行文件比目标文件多了链接的过程      
        
        clang -o WGXXX.out WGXXX.m  //.m源文件编译链接成可执行文件        
    
* 3.MH_DYLIB: 动态库文件;常说的动态库包括后缀名为【.dylib的动态库】【.framework的动态库】两种
* 4.MH_DYLINKER: 是指的dyld(也被称为动态链接编辑器/动态链接加载器),在Mac、iphone的/usr/lib/dyld目录中

        dyld到底是做什么的？            
        动态库不能直接运行，而是需要通过系统的动态链接加载器dyld进行加载到内存后执行       
        动态链接加载器dyld在系统中以一个用户态的可执行文件形式存在             
        dyld就是用来将可执行文件、动态库、bundle文件加载进内存的一个特殊的Mach-O文件          
        dyld不能加载自己，dyld由系统加载；dyld代码是开源的，可以查看源码               
* 5.MH_DSYM: .dSYM格式的文件(是iOS App的符号表存储着二进制文件的符号信息。通常我们在分析线上崩溃的时候会用到这个文件)

        release模式下.dsym文件的路径:           
        Window->Organizer->选中Archives下的包->Show In Finder->XXX.xcarchive->显示包内容->dSYMS文件夹
        ->XXX.app.dYSM ->显示包内容 ->找到和项目名XXX同名的文件即是.dSYM文件          
#### 综上可知【可执行文件、.o目标文件、.a静态库、.framework静态库、.dylib动态库、.framework动态库、dyld、.dsym】都属于Mach-O文件格式
在Xcode中可以通过Xcode -> Build Settings -> Linking - General ->Mach-O Type查看当前项目的类型


#### 6.1 Mach-O文件内部结构组成分为三大块
![图片](https://github.com/WGFcode/WGFcodeNotes/blob/master/WGFcodeNotes/WGScreenshots/macho.png)

* Mach64 Header: Mach-O头部;

        保存着Mach-O文件类型/CPU架构类型/加载命令数量/加载命令所占用总的字节数等信息
* Load Commands: 加载命令；存储 Mach-O 的布局信息

        描述文件在虚拟内存中的逻辑结构、布局         
        Mach-O文件被组织成一系列的加载命令，这些命令告诉系统如何将文件的不同部分加载到内存中           
* Data: 数据块(每一个segment的具体数据都保存在这里，这里包含了具体的代码和数据)

        在Load commands中定义的Segment的原始数据


#### 6.1.1 Mach-O文件之Header头文件
![图片](https://github.com/WGFcode/WGFcodeNotes/blob/master/WGFcodeNotes/WGScreenshots/macho_header.png)
* Magic Number: 判断当前Mach-O文件的是32还是64位; 64位架构下是 - MH_MAGIC_64
* CPU Type: 标识CPU的架构; arm64架构 - CPU_TYPE_ARM64 
* File Type: 标识Mach-O文件的类型

        MH_EXECUTE：可执行文件        
* Number of Load Commands: 标识Mach-O文件中加载命令(load commands)的数量
* Size of Load Commands: 标识Mach-O文件加载命令所占用的总字节大小；标记Load Commands段的长度
* Flags: 标识Mach-O文件的一些标志信息;内容很多,好多看不懂的只列出来了一个能明白的
 
        MH_NOUNDEFS: 未带未定义的符号，没有进一步的链接依赖关系           
        MH_DYLDLINK: 目标文件是动态链接器的输入，不能再次静态链接          
        MH_PIE:说明启动地址空间布局随机化ASLR(Address Space Layout Radomization)来增加程序的安全性         

#### 6.1.2 Mach-O文件之加载命令Load Commands
![图片](https://github.com/WGFcode/WGFcodeNotes/blob/master/WGFcodeNotes/WGScreenshots/macho_loadCom.png)
* 每条加载命令的开头结构都是一样的。都包含有两个共同的字段，通过这两个字段，可以对命令进行完整的解析

        Command: 命令类型 
        Command Size:命令的长度大小
* 每条加载命令都是由类型，大小和值三部分组成的，通过解析出每条命令的类型和大小，就可以方便的获取到命令中具体的值
* 不同类型的命令对应的值解析出来的结构也不同

#### 下面是几种常见的命令类型
* 1.LC_SEGMENT_64: 将文件中的段（64位）映射到进程地址空间中,用于描述64位Mach-O文件中的段（segment）信息         
LC_SEGMENT_64命令描述了内核应该如何设置当前应用进程的内存空间，这些段将直接从Mach-O文件中对应的位置加载到内存里       
LC_SEGMENT_64命令指导着内核如果将Mach-O文件中的各个段数据加载到内存里          

        Segment Name:           段名称
        VM Address:             段的虚拟内存地址
        VM Size:                段的虚拟内存大小
        File Offset:            此段在文件中的偏移量
        File Size:              此段在文件中占用的字节数
        Maximum VM Protection:  段的页面所需要的最高内存保护
        Initial VM Protection:  段页面初始时的内存保护
        Number of Sections:     段中区（section）的数量
        
        Segment段名称类型
        Segment Name: __PAGEZERO   空指针异常捕获段
        Segment Name: __TEXT       代码段
        Segment Name: __DATA_CONST 数据段(是__DATA数据段的一个子集)
        Segment Name: __DATA       数据段
        Segment Name: __LINKEDIT   链接器使用的符号和其他表段
        
![图片](https://github.com/WGFcode/WGFcodeNotes/blob/master/WGFcodeNotes/WGScreenshots/macho_segment64.png)

* 2.LC_MAIN: 当所有库加载完成后，此命令用来进行二进制程序的主线程启动

![图片](https://github.com/WGFcode/WGFcodeNotes/blob/master/WGFcodeNotes/WGScreenshots/macho_main.png)

* 3.LC_CODE_SIGNATURE: Mach-O包含的数字签名，如果此签名与代码不匹配，则进程会被强制关闭      

![图片](https://github.com/WGFcode/WGFcodeNotes/blob/master/WGFcodeNotes/WGScreenshots/macho_sign.png)        

        Data Offset: 标记从文件的何处开始读取签名       
        Data Size: 标记签名所占字节数           
        ⚠️:发现每次通过MachOView工具打开mach-o文件这个地址是不会变化的           


* 4.LC_SYMTAB: 此命令用来加载此Mach-O文件的符号表(包含了symbol table和string table在Mach-O文件中的位置)       

![图片](https://github.com/WGFcode/WGFcodeNotes/blob/master/WGFcodeNotes/WGScreenshots/macho_symtab.png)

        Symbol Table Offset: 符号表起始位置的偏移量         
        Number of Symbols:   符号表的字节数           
        String Table Offset: 字符串表起始位置的偏移量        
        String Table Size:   字符串表的字节数             


* 5.LC_DYSYMTAB: 此命令用来加载动态库的符号表，对应的是Dynamic Symbol Table段的数据

![图片](https://github.com/WGFcode/WGFcodeNotes/blob/master/WGFcodeNotes/WGScreenshots/macho_dysymtab.png)

        //本地符号，用来调试          
        LocSymbol Index: 本地符号的位置       
        LocSymbol Number:本地符号的字节数           
        
        //定义的外部符号             
        Defined ExtSymbol Index: 定义的外部符号位置        
        Defined ExtSymbol Number: 定义的外部符号字节数             

* 6.LC_LOAD_DYLINKER: 此命令告知内核需要调用的动态链接器的位置

![图片](https://github.com/WGFcode/WGFcodeNotes/blob/master/WGFcodeNotes/WGScreenshots/macho_dylinker.png)

        Str Offset:        
        Name: 包含链接器的路径名称字符串起始位置的偏移，真正的动态链接器一般为/usr/lib/dyld         


* 7.LC_UUID: 此命令加载时可以读取到一个128位的UUID值

![图片](https://github.com/WGFcode/WGFcodeNotes/blob/master/WGFcodeNotes/WGScreenshots/macho_uuid.png)

        UUID: 128位的UUID值;是文件的唯一标识;UUID必须要和App二进制文件中的UUID一致，才能被正确的符号化
 


* 8.LC_LOAD_DYLIB: 此命令用来加载额外的动态库,通常会有多条命令，每条命令指定一个要加载的动态库

![图片](https://github.com/WGFcode/WGFcodeNotes/blob/master/WGFcodeNotes/WGScreenshots/macho_dylib.png)

        动态库(Dynamic Library)缩写为DYLIB;         
        动态库允许程序在运行时共享代码和数据，从而减小可执行文件的大小，并方便软件的更新和维护；         
        当使用LC_LOAD_DYLIB加载动态库时,若系统找不到指定的动态库或在加载过程中出现错误(格式错误/符号冲突)       
        程序通常会无法正常启动或运行时出现严重错误并崩溃           
        LC_LOAD_DYLIB: 适用于加载程序必需的核心动态库            
    
        Str Offset:           
        Time Stamp: 依赖库构建时的时间戳         
        Current Version: 动态库当前版本号            
        Compatibility Version: 兼容版本号          
        Name: 动态库所在路径字符串的起始位置（相对与当前命令起始的偏移字节）         


* 9.LC_LOAD_WEAK_DYLIB:加载动态库，和LC_LOAD_DYLIB区别如下

        LC_LOAD_WEAK_DYLIB加载动态库时，若该动态库不存在或无法正确加载程序不会像LC_LOAD_DYLIB加载动态库那样
        直接导致程序崩溃             
        
        LC_LOAD_WEAK_DYLIB提供了一种更灵活的加载机制，允许程序在没有特定动态库的情况下继续运行          
        只是与该弱引用动态库相关的功能可能无法使用；程序在面对动态库缺失或加载失败的情况时，具有更好的容错性。       
        
        场景: 比如高级滤镜功能是通过一个动态库提供的,在低端设备或用户没有购买的情况下，这个动态库可能不存在       
        可以使用LC_LOAD_WEAK_DYLIB加载这个动态库，如果动态库存在就使用高级滤镜功能，如果不存在就不使用           
        但核心功能仍然可以正常运行，但是开发人员需要在动态库不可用情况下给出相应的友好提示            
        
        通过检查与该动态库相关的函数指针是否为NULL来判断动态库是否可用             
        
        插件系统开发/适配不同设备特性的功能加载/动态更新部分功能等场景           
    
(1)在Xcode中创建动态库项目：Xcode->File->New->Project->Cocoa Touch Dynamic Libary(针对iOS应用)/
Mac OS X Dynamic Library(针对Mac应用)来创建动态库；构建这个动态库项目，生成动态库文件WG.dylib           

(2)在主项目中引用这个自己开发的动态库,在Build Setting->Linking-> Other Linker Flags中添加-weak_library
WG.dylib，这个标志告诉链接器使用弱引用的方式加载指定的动态库            


* 10.LC_RPATH: 此命令用来进行@rpath外部路径变量的映射

![图片](https://github.com/WGFcode/WGFcodeNotes/blob/master/WGFcodeNotes/WGScreenshots/macho_rpath.png)

        除了系统本身提供了一些动态共享库外，我们也可以使用外部自定义的动态库，        
        这类外部动态库在加载的时候也需要一个明确的路径，通常在加载外部动态库的命令中，            
        库的路径是以@rpath开头的，Xcode的编译选项中可以自定义设置外部库的寻找路径，同时使用此命令进行解析        



* 11.LC_FUNCTION_STAETS:用来描述函数表段所在的起始位置和字节数(和签名命令LC_CODE_SIGNATURE结构一样)

![图片](https://github.com/WGFcode/WGFcodeNotes/blob/master/WGFcodeNotes/WGScreenshots/macho_function_start.png)

        Data Offset: 标记从文件的何处开始读取函数表             
        Data Size: 标记函数表所占字节数           


* 12.LC_DATA_IN_CODE: 主要用于表示代码段（__TEXT）中包含的数据

        传统的编程模型中，代码段__TEXT主要存放机器指令; 数据段（如__DATA）存放变量等数据。
        但是有时候为了优化或者其他目的，会将一些小型的数据（如常量数组等）直接嵌入到代码段中
        LC_DATA_IN_CODE加载命令就是用来描述这些嵌入在代码段中的数据的相关信息       
![图片](https://github.com/WGFcode/WGFcodeNotes/blob/master/WGFcodeNotes/WGScreenshots/macho_dataInCode.png)

* 13.LC_SOURCE_VERSION: 它主要用于存储源文件版本相关的信息


#### 6.1.3 Mach-O文件之数据块(段和区)
#### 在加载命令Load Commands中我们知道LC_SEGMENT_64加载命令包含5个段segment
段和区的命名规则是：段的名称全部大写（比如__TEXT），而区的名称是小写（比如__text）

![图片](https://github.com/WGFcode/WGFcodeNotes/blob/master/WGFcodeNotes/WGScreenshots/macho_lcsegment.png)


* LC_SEGMENT_64(__PAGEZERO): 空指针异常捕获段

        静态链接器创建了__PAGEZERO作为可执行文件的第一个段，该段在虚拟内存的位置和大小都为0
        只能用来处理空指针。我们把指针指向空就是指向这里，程序访问空指针时，会得到一个EXC_BAD_ACCESS错误
        不能读、不能写、不能执行
* LC_SEGMENT_64(__LINKEDIT): 启动App需要的信息，如 bind & rebase 的地址，代码签名，符号表
* LC_SEGMENT_64(__TEXT): 代码段；包含多个区section;常见的区如下

        __TEXT: 代码段，只读可执行/存储函数的二进制代码(__text)/常量字符串(__cstring)/Objective C 的类/方法名等信息

        __text: 主程序代码区              
        __stubs / __stubs_helper: 帮助动态连接器dyld绑定符号         
        __objc_methname: OC方法名              
        __objc_classname: OC类名                
        __objc_methtype: OC方法类型（方法签名）               
        __cstring: 只读的C语言字符串               
        __const：const关键字修饰的只读常量                  
* LC_SEGMENT_64(__DATA) / LC_SEGMENT_64(__DATA_CONST): 数据段(是__DATA数据段的子集)；包含多个区section

        __DATA: 数据段，读写，存储Objective C的字符串(__cfstring)，以及运行时的元数据：class/protocol/method…
    
        __got:  全局非懒绑定符号指针表
        __la_symbol__ptr：懒绑定符号指针表
        __mod_init_func：C++类的构造函数
        __const：未初始化过的常量
        __cfstring:  Core Foundation字符串
        __objc_classlist：OC类列表
        __objc_nlcatlist：实现了+(void)load方法的Objctive_C类列表
        __objc_catlist：OC分类（Category）列表
        __objc_protlist：OC协议（Protocol）列表
        __objc_imageinfo：镜像信息，可用它区分Objective-C 1.0和2.0
        __objc_const：OC初始化过的常量
        __objc_selrefs：OC选择器（SEL）引用列表
        __objc_protorefs：OC协议引用列表
        __objc_classrefs：OC类引用列表
        __objc_superrefs：OC超类（父类）引用列表
        __objc_ivar：OC类的实例变量
        __objc_data：OC初始化过的变量
        __data：实际初始化数据段
        __common：未初始化过的符号声明
        __bss：未初始化的全局变量


    Section64 Header结构：通过下面信息可以在Mach-O文件中找到具体的分区所在的位置，将其加载进内存
        Section Name:  分区名
        Segment Name:  分段名
        Address: 分区地址
        Size: 分区所占字节数
        Offset: 分区在文件中的偏移量
        Alignment: 分区对齐方式
        Relocations Offset: 重定位条目在文件中的偏移量
        Number of Relocations: 需要重定位的条目数
        Flags: 分区标记
        Reserved1: 预留
        Reserved2: 预留
        Reserved3: 预留
    
    
   
<!--   、界面分析-->
<!--• 辅助：Cycript、Reveal-->
<!--2、代码分析，对 Mach-O 文件静态分析（也就是我们一行一行阅读别人的代码）-->
<!--• 辅助：MachOView、class-dump、Hopper Disassembler、ida 等-->
<!--3、动态调试分析，对运行中的 APP 进行代码调试-->
<!--• 辅助：debugserver、LLDB-->
<!--4、代码编写，注入代码到 APP 中，必要时还需要 重新签名、打包ipa -->
<!--    -->
<!-- 代码数量会影响启动速度，为了提升启动速度，我们可以把一些无用代码下掉。那怎么统计哪些代码没有用到呢？可以利用 LLVM 插桩来实现   -->


[好文章](https://juejin.cn/post/6844904130406793224)
https://juejin.cn/post/6844904174287585287
https://zhuanlan.zhihu.com/p/566695205














































#### 3. IO性能优化
* iOS 提供了多个文件存储目录，选择合适的目录有助于管理缓存文件的生命周期;包括Caches 目录和tmp 目录     

        Caches目录: 适合存储缓存文件。系统可能会在磁盘空间紧张时清除这个目录下的文件，因此不应存储重要数据
        tmp目录: 适用于临时文件。系统重启或应用未运行时，可能会清除这个目录下的文件
* 根据数据的重要性和更新频率，制定缓存策略。为缓存数据设置时间戳或过期时间。每次读取缓存时检查数据是否过期，及时更新。
实现 LRU 算法，定期清理最久未使用的缓存文件

* 为缓存文件生成唯一标识符（如使用哈希值），避免文件名冲突。可以将 URL 的 MD5 或 SHA1 哈希值作为缓存文件名。
将缓存文件按类别或特定属性进行分类存储，方便管理。例如，将图片和JSON数据分别存储在不同的子目录中

* 对于大型缓存数据，可以在写入文件时使用 GZIP 等压缩技术，减少存储空间占用;避免在主线程上执行缓存读写操作
* 减少频繁的写入操作，可以将多次写入合并为一次批量操作

* 读写的 API
* 文件缓存: 可以帮助优化应用性能、减少网络请求和延长电池续航
* 定期清理过期或不再使用的缓存文件，避免占用过多磁盘空间
























































        

        
#### 8 性能调优之像素对齐-Color Misaligned Images优化
#### iOS项目中的尺寸是以点(point)为单位,@1x、@2x、@3x代表分别表示一个点对应1个像素、对应2个像素、对应3个像素。而Color Misaligned Images主要就是针对像素不对齐而导致性能问题进行优化处理的
#### 发现项目中存在Misaligned Images问题的方式有两种
1. 模拟器调试时：打开模拟器的Debug - Color Misaligned Images菜单选项
2. Instrument性能检测时，选中Core Animation模板，在Display Settings中勾选Color Misaligned Images选项。可针对模拟器和真机，可查看真机上所有应用的像素混合情况
#### 打开开关后，会看到部分视图出现黄色或洋红色图层标记，代表其像素不对齐
    不对齐: 视图或者图片的点数(point)，不能换算成整数倍的像素值(pixel),导致显示视图时需要对没对齐的边缘进行额外混合计算，
    影响性能洋红色: UIView的frame像素不对齐，即不能换算成整数像素值
    
    黄色: UIImageView的图片像素大小与其frame.size不对齐，图片发生了缩放造成
    
    点(point): 逻辑坐标的基本单位，日常布局中常用的，比如某个视图的宽度为20高度为40，点是虚拟单位，并非实际存在，
    还需GPU计算点对应的像素
    
    像素pixel: 屏幕上最小的色块单元，如iPhone6s的屏幕像素是750x1334像素，对应的点是375*667pt,点和像素的对应关系是1:2,
    所以iPhone6s上需要使用@2x的图片
    
#### 一般UI设计师给的设计图都是像素(px)为单位或者点(pt)为单位，本案例以设计图以像素(px)为单位，如果设计图中图标@2x尺寸为40*40像素，那么实际项目中如果我们在iPhone6s下设置布局时，应该设置它的size为20*20(原因是iPhone6s用的是@2x的图标，即iPhone6s屏幕上的一个点代表2个像素)，否则会出现像素不对齐的问题，所以以后让设计出图出图(像素px为单位时)，尽量@2x的图是项目布局设置尺寸的2倍，对应的@3x是项目布局尺寸的3倍，这样就不会出现像素不对齐而导致性能问题了

#### 洋红色: UIView的frame像素不对齐，即不能换算成整数像素值问题的解决；解决方法就是根据屏幕倍数对点进行向上取整
    0.5个点在@3x(即一个点代表3个像素)的设备上不能转化为整数的像素，
    label.frame = CGRectMake(0.5, 10, 20.5, 30);
    
    
    OC中无法对CGFloat、CGSie、CGRect进行分类添加方法，所以该方法写在全局工具类中
    /// 基于屏幕倍数，进行像素取整
    +(CGFloat)scalePixelInteger:(CGFloat)fl {
        //通过UIScreen.main.scale来获取像素与点的对应关系。
        CGFloat newScale = UIScreen.mainScreen.scale;
        //fl * newScale 点*屏幕倍数 = 像素,然后对像素进行向上取整
        //ceil: 如果参数是小数，则求大于本身的最小整数.
        return ceil(fl * newScale) / newScale;
    }
    
    CGfloat x = [WGUtil scalePixelInteger:0.5];
    CGfloat w = [WGUtil scalePixelInteger:20.5];
    label.frame = CGRectMake(x, 10, w, 30);
    这样就不会再出现洋红色了
    

#### 黄色: UIImageView的图片像素大小与其frame.size不对齐，图片发生了缩放造成；解决方法就是根据图片的像素大小，然后调整布局中的位置；或者让设计师重新出图



#### iOS渲染原理
    1.我们在屏幕上绘制图像需要的原始数据叫【位图(Bitmap)】,位图是一种数据结构，一个位图由n*m个像素组成每个像素的
    颜色信息由RGB组合或灰度值表示
     
    2.位图一般存储的是物理像素(物理分辨率)，而应用层一般用的是逻辑像素(逻辑分辨率)
        物理分辨率以pixel(px)为单位；逻辑分辨率以point(pt)为单位;
        iOS 1X倍屏: 1pt = 1个物理像素
        iOS 2X倍屏: 1pt = 2个物理像素
        iOS 3X倍屏: 1pt = 3个物理像素
        
     3.ios开发界面设置长度是以pt(点)为单位的，比如iPhone7plus屏幕尺寸414pt*736pt，所以pt是iOS的开发单位,
     而美工给我们的都是以像素(px)为单位的的
     
     4.屏幕上绘制图像显示的原始数据叫【位图】:电子抢从上到下逐行扫描，扫描一行发出一个Hsync水平同步信号，扫描完成
     后就显示一帧画面，然后电子抢回到初始位置准备进行下一次扫描，在下一次扫描前会发出一个Vsync垂直同步信号，显示器
     通常以固定的频率进行刷新，这个刷新率就是垂直同步信号产生的频率
     
     5.【位图】数据是由CPU、GPU协同工作得到的；
        CPU将计算好显示内容提交给GPU
        GPU渲染完成后将渲染结果存入帧缓冲区
        视频控制器会读取帧缓冲区器的信息传递给显示器进行显示
        
     6.CPU和GPU区别
        CPU:中央处理器，适合处理单一复杂逻辑；cache占用了大量的空间，而且还有特别复杂的控制逻辑，相比之下，计算能力只是CPU 很小的一部分
        GPU:图像处理器，适合高并发简单逻辑；图像渲染涉及到的矩阵运算比较多，矩阵相关的计算可以被拆分成并行的简单的运算，所以渲染处理适合GPU做
        GPU 的工作计算量大，但技术含量不高，需要简单重复很多次；CPU 就像老教授，积分微分都会算，适合处理单一复杂逻辑运算
        
    7.iOS渲染原理
    (1)ios图形渲染有三个核心的库: Core Graphics、Core Animation、Core Image,三个框架主要用来绘制可视化内容,他们都是通过 OpenGL 来
        调用 GPU 进行实际的渲染，然后生成最终位图数据存储到帧缓冲区，视频控制器再将帧缓冲区的数据显示物理屏幕上。
    (2)UIKit是 iOS 开发者最常用的框架,通过设置 UIKit 组件的布局以及相关属性来绘制界面。但是 UIKit 并不具备在屏幕成像的能力，
       这个框架主要负责对用户操作事件的响应（UIView 继承自 UIResponder），事件经过响应链传递。
    (3)Core Animation  主要负责组合屏幕上不同的可视内容，这些可视内容可被分解成独立的图层也就是我们日常开发过程中常接触的 CALayer，
       这些图层被存储在图层树中。CALayer 主要负责页面渲染，它是用户能在屏幕上看见的一切的基础;
    (4)Core Graphics 主要用于运行时绘制图像。开发者可以使用此框架来处理基于路径的绘图，转换，颜色管理，离屏渲染，图案，渐变和阴影等等。
    (5)Core Image  与  Core Graphics 正好相反，Core Graphics  是在运行时创建图像，而  Core Image  则是在运行前创建图像。
    (6)OpenGL ES 和 Metal 都是第三方标准，基于这些标准具体的内部实现是由对应的 GPU 厂商开发的。Metal 是苹果的一套第三方标准，
       由苹果实现。很多开发者都没有直接使用过Metal，但却通过 Core Animation、Core Image 这些核心的系统框架在间接的使用 metal
       
    7.CoreAnimation 与 UIKit 框架的关系
    (1)Core Animation 是 iOS 和 OS X 上图形渲染和动画的基础框架，主要用来给视图和应用程序的其他可视元素设置动画。Core Animation
       的实现逻辑是将大部分实际绘图的工作交给 GPU 加速渲染，这样不会给 CPU 带来负担，还能实现流畅的动画。CoreAnimation 的核心类是
       CALayer，UIKit 框架的核心类是 UIView
    (2)UIView 和 CALayer 是一一对应的关系，每一个 UIView 都有一个 CALayer 与之对应，UIView负责布局、交互响应，CALayer负责页面渲染
          CALayer 是 UIView 的属性之一，负责渲染和动画，提供可视内容的呈现;UIView 提供了对 CALayer 功能的封装，负责了交互事件的处理
    




























