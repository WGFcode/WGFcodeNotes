## iOS签名机制
#### iOS签名机制学习路线
1. 加密解密: 对称密码(DES、3DES、ARS)  公钥加密(RSA)
2. 单向散列函数: MD4、MD5、SHA-1、SHA-2、SHA-3
3. 数字签名
4. 证书
5. iOS签名机制

#### 1.  加密解密.根据密钥的使用方法,可以将密码分为2种: 对称密码、公钥密码(非对称密码)
#### 1.1 对称密码: 加密、解密时使用的是同一个密钥,常用的对称密码算法有DES、3DES、AES
#### DES(Data Encryption Standard)加密: 是一种将64bit明文加密成64bit密文的对称密码算法,密钥长度是56bit,规格上来说,密钥长度是64bit,但每隔7bit会设置一个用于错误检查的bit,因此密钥长度实质上是56bit
                           密钥56比特(56位)
                                 |
      加密:明文64比特(64位)----->DES加密----->密文64比特(64位)


                           密钥56比特(56位)
                                |
      解密:密文64比特(64位)----->DES解密----->明文64比特(64位)
#### 由于DES每次只能加密64bit的数据,遇到比较大的数据,需要对DES加密进行迭代(反复); 目前已经可以在短时间内被破解,所以不建议使用

#### 3DES加密: 将DES重复3次所得到的一种密码算法,也叫做3重DES; 目前还被一些银行等机构使用,但处理速度不高,安全性逐渐暴露出问题

                 DES密钥1     DES密钥2     DES密钥3
                    |           |           |
    加密:明文----->DES加密----->DES解密----->DES加密----->密文


                 DES密钥1     DES密钥2     DES密钥3
                    |           |           |
    解密:密文----->DES解密----->DES加密----->DES解密----->明文
#### 如果所有密钥都是相同的,则结果和普通的DES是等价的
#### AES加密(Advanced Encryption Standard): 取代DES成为新标准的一种对成加密算法,目前AES已经逐步取代DES、3DES,成为首选的对成密码算法; 我们都使用同一套AES加密算法,为什么能够安全? 因为虽然加密算法都一样但是密钥是不同的

#### 1.2 密钥配送问题
#### 在使用对成密码时,一定会遇到密钥配送问题,因为在发送密钥给对方时,密钥可能会被窃取, 如何解决密钥配送的问题,有以下几种方式, 最常用的还时公钥密码方式
1. 事先共享密钥
2. 密钥分配中心
3. Diffie-Hellman密钥交换
4. 公钥密码


#### 1.3 公钥密码(非对称密码)
#### 公钥密码种,密钥分为加密密钥、解密密钥2种,它们并不是同一个密钥;公钥密码也被称为非对称密码;加密密钥一般是公开的,因此该密钥称为公钥;解密密钥,由消息接收者自己保管,不能公开的,称为私钥; 公钥和私钥匙一一对应的,不能单独生成,一对公钥和私钥统称为密钥对;

#### 1.3.1 解决密钥配送问题
1. 由消息的接收者,生成一对公钥匙、私钥
2. 将公钥发送给消息的发送者
3. 消息的发送者使用公钥加密消息

        A发消息给B
         发送者                 接收者
           A      ------>       B(生成一对公私钥)
                B将公钥交给A
                  <------    
        明文+公钥   ------>      密文(利用私钥对密文进行解密)   
#### 即使公钥被窃取了,也没问题的的,因为只有拥有私钥才能解密文,这样就解决了密钥配送的问题,现在通常用到的公钥密码是RSA加密算法.

#### 1.4 混合密码系统
1. 对称密码缺点:是不能很好的解决密钥配送问题;优点是: 加密解密速度快
2. 公钥密码缺点:加密解密速度比较慢(相对于对称密码来说); 优点是: 解决密钥配送问题
3. 混合密码系统: 将对称密码和公钥密码的优势相结合的方法; 解决了公钥密码速度慢的问题; 并通过公钥密码解决了对称密码的密钥配送问题, 网络上的密码通信所用的SSL/TLS(HTTPS)都运用了混合密码系统
#### 1.4.1 混合密码-加密过程
     发送者                    接收者
       A      ------>     B  (生成一对公私钥M/m)
            B将公钥M交给A
              <------    
    1.发送者A利用伪随机数生成器生成一个随机数(会话密钥n),这个随机数作为后续消息传递过程中对称加密的密钥
    2.发送者利用公钥M对会话密钥n进行加密发送给  ------> 接收者B(接收者收到密文后,利用私钥m对密文进行解密,得到对称加密的密钥n)
    3.消息明文+密钥n=密文发送给   ------>    接收者B(利用密钥n对密文进行解密得到明文)     

#### 2. 单向散列函数(One-way hash function)
#### 2.1 单向散列函数,可以根据消息的内容计算出散列值;散列值的长度和消息的长度是无关的,无论消息是1bit、10M、100G,单向散列函数都会计算出固定长度的散列值; 单向散列函数又被称为消息摘要函数/哈希函数;输出的散列值,也被称为消息摘要、指纹

#### 2.2 单向散列函数特点
1. 根据任意长度的消息,计算出固定长度的散列值
2. 计算速度快,能快速计算出散列值
3. 消息不同,散列值也不同
4. 具备单向性, 拿到散列值是无法推测出消息内容的
5. 单向散列函数,又

#### 2.3 常见的几种单向散列函数有
1. MD4、MD5: 生成128bit的散列值,MD就是Message Digest的缩写,目前已经不安全了;Mac终端上默认是可以使用md5命令的,例如在桌面创建1.txt文件,然后使用命令md5 1.txt,即可得出1.txt文档中内容的散列值
2. SHA-1: 产生160bit的散列值,目前已经不安全了
3. SHA-2: SHA-256、SHA-384、SHA-512,散列值长队分别是256bit、384bit、512bit, 散列值长度越长越安全
4. SHA-3: 目前仍在研发中

#### 2.4 单向散列函数的作用
1. 防止数据被篡改: 如果数据被篡改了,那么它的散列值就会不一样,这样就能判断数据是否被篡改,也可用于判断软件是否是正版
2. 口令加密: 比如登录页面,用户输入完账号和密码后,密码不可能直接存储到服务器上(若数据库被攻击那么所有用户的密码都会泄露)而是将密码的散列值存储在服务器,下次登录时,来和服务器上的密码的散列值和现在输入密码的散列值相等,则登录成功

#### 3. 数字签名
#### 场景: 张三发消息(你来吧)给李四, 但是张三发的消息可能被篡改;或者有人伪装成张三发消息;或者说就是张三发的消息,但他可以否认是他发的; 那么李四如何确认这段消息的真实性? 如何识别篡改、伪装、否认?

#### 3.1在数字签名技术中,有以下两种行为
1. 生成签名: 由消息的发送者完成,通过“签名密钥”生成.即发送者张三来生成签名,来证明是自己发的消息
2. 验证签名: 由消息的接收者完成,通过“验证密钥”验证.即接收者李四来验证签名

#### 3.2 如何能保证这个签名是消息发送者自己签的?
* 用消息发送者的私钥进行签名(因为私钥是属于发送者自己的)

#### 在公钥加密中,任何人都可以使用公钥进行加密; 在数字签名中,任何人都可以使用公钥验证签名

#### 3.3 数字签名过程
     发送者                    接收者
       A      ------>           B 
    发送者A发消息给接收者B,但是B无法确认消息是否是发送者A发送的?是否消息被篡改了?发送者A否认消息是他发送的?
    1. 发送者A将消息Message发送给接收者B
    2. 发送者A利用自己的私钥对消息Message进行加密形成密文,这个密文就是签名
    3. 发送者将签名也发送给接收者B
    4. 接收者B接收到消息Message和签名后,利用发送者A的公钥(A的公钥谁都可以拿到的)进行解密得到消息Message1
    5. 接收者B将解密得到的消息Message1和消息Message进行对比,如果两者相同,则签名验证成功
#### 上面的过程仍然会有个问题,即消息的内容可能很多(100KB),因为签名也是个加密的过程,所以加密后的签名可能也是很大的(100KB),所以这样就会导致传输消息效率低,解决方法是,对消息进行单向散列函数操作得到散列值,对散列值进行加密得到签名,消息和散列值是一对一的关系,所以拿到散列值的签名就是拿到消息的散列值,


#### 3.4. 数字签名和公钥密码区别
                       私钥                  公钥
        公钥加密   接收者解密时使用         发送者加密时使用
        数字签名   签名者生成签名时使用     验证者验证签名时使用
        谁持有密钥  个人持有              只要需要,任何人都可以持有
        
#### 如果有人篡改了文件内容或者签名内容,结果就是:签名验证失败,证明内容被篡改,数字签名不能保证机密性,仅仅是为了能能够识别内容有没有被篡改


#### 3.5 数字签名的作用
1. 确认消息的完整性
2. 识别消息是否被篡改
3. 防止消息发送人否认

#### 正确使用签名的前提是: 用于验证签名的公钥必须属于真正的发送者, 所以在验证签名之前,首先得先验证公钥的合法性.如何验证公要的合法性? 证书

#### 4. 证书(Certificate)
#### 4.1证书是由权威机构认证的,密码学中的证书,全称叫**公钥证书**. 公钥证书由三部分组成,CA就是能够认定“公钥确实属于此人”
1. 姓名、邮箱等个人信息
2. 公钥
3. 由认证机构(Certificate Authority,CA)施加数字签名

#### 4.2 证书的利用过程(HTTPS中的证书其实就是下面的流程)

     发送者                    接收者
       A      ------>           B 
    目的: 接收者B要将公钥发给发送者A
    问题:发送者A发消息给接收者B,发消息前,接收者B要先将自己的公私钥对中的公钥发给发送者A,这样发送者A就可以拿到公钥对消息进行
    加密,接收者B收到消息后,利用私钥对加密消息进行解密得到消息明文,但是接收者在发送公钥时,容易被中间人拦截,那么就需要利用证书了
    1. 接收者B先去认证机构(CA)中注册自己的公钥,CA利用自己的私钥对接收者B注册的公钥施加数字签名并生成证书
    2. 形成证书过程: CA利用自己的私钥对接收者B的公钥进行加密形成密文,即数字签名,然后将数字签名+接收者B的公钥+接收者B个人信息=证书
    3. 发送者A可以拿到认证机构CA的证书,并且也可以拿到CA自己的公钥,
    4. 发送者A利用CA的公钥对数字签名进行验证(解密),然后和证书中的公钥进行对比,如果验证两者相同,那么说明公钥是合法的
    5. 验证公钥合法后,就可以通过拿到的公钥对发送的消息进行加密,然后发送给接收者B,
    6. 接收者B接收到密文后,就用自己的私钥进行解密,得到消息的明文

#### 5. 总结
    1.对称加密
         加密解密用的是同一组密钥
         加密解密速度快
         无法解决密钥配送问题
    2.公钥加密
         加密解密用的是不同的密钥
         加密解密速度慢
         解决密码配送问题
    3.单向散列函数
         根据消息生成对应的固定长度的散列值
         防止数据被篡改
    4.数字签名
         用私钥加密消息的散列值,生成的密文
    5.证书
         用CA的私钥,对公钥生成数字签名

#### 6. iOS签名机制
#### 6.1 iOS签名机制的作用
* 保证安装到用户手机上的APP都是经过Apple官方允许的

#### 不管真机调试还是发布app,开发者都需要经过一系列复杂的步骤
1. 生成CertificateSigningRequest.cerSigningRequest文件(mac公钥)
2. 获取ios_development.cer/ios_distribution.cer证书文件(利用Apple私钥,对Mac公钥生成了数字签名)
3. 注册device、添加App ID
4. 获得*.mobileprovision文件(利用Apple私钥,对[.cer证书+devices+AppID+entitlements]进行数字签名)

#### 对于真机调试,现在Xcode已经自动帮开发者做了以上操作,但是我们需要研究整个签名的流程

#### 6.2 iOS签名机制
         Mac设备              Apple苹果后台           iOS设备
      Mac公钥/Mac私钥           Apple私钥            Apple公钥 
      
      每次选择设备后运行Xcode时,都会对我们的代码进行签名
      
              Mac私钥(进行签名)                           
      1.APP----------------------->APP代码包 + 签名1

                    Apple私钥(进行签名)             
      2.Mac公钥------------------------------>证书(Mac公钥+签名2) [苹果官网上创建证书的过程]
                                                                
      3.证书(Mac公钥+签名2) + (device、App ID、entitlements(权限,例如推送))
                        |
                        |  Apple私钥(进行签名)
                        |
      证书(Mac公钥+签名2) + (device、App ID、entitlements(权限,例如推送)) + 签名3 
      [这个就是*.mobileprovision文件, 苹果官网上选择AppID,选择设备UDID,然后选择证书生成profile文件]

#### 综上,ipa包中包含的内容有: [App代码(Mach-O文件)、签名1]、[证书(Mac公钥+签名2) + (device、App ID、entitlements(权限,例如推送)) + 签名3], 签名2和签名2都需要用Apple公钥进行验证,签名1需要Mac公钥进行验证,具体对应的我们创建的文件分析如下:
1. 生成Mac设备的公钥: 钥匙串访问->证书助理->从证书颁发机构请求证书->...CertificateSigningRequest.cerSigningRequest文件,即CSR文件
2. 苹果官网上去创建证书: Certificate -> +...->ios_development.cer/ios_distribution.cer证书文件. (利用Apple后台的私钥,对Mac设备的公钥进行签名后的证书文件)
3. 生成mobileProvision文件: 选择AppID、设备UDID、证书,最后生成mobileProvision文件

