### 1.weak的实现原理 / weak的实现原理是什么？当引用对象销毁是它是如何管理内部的Hash表的？（这里要参阅weak源码）
### __weak/__unsafe_unretained都是弱引用，都是对指向的对象进行弱引用，不同点就是若__weak指针指向的对象销毁了，那么weak指针会自动置为nil;但是__unsafe_unretained不会置为nil,会导致野指针问题

     weak使用场景：1.解决循环引用,用__weak标记，2.委托代理delegate用weak修饰
     
     被weak标记的对象在被使用过程中，不会使对象的引用计数(增加)+1，而且这个对象销毁时，被weak标记的变量会自动置为nil, 不会产生野指针问题
     __weak NSObject *obj1 = obj;       编译为：objc_initWeak(&obj1, obj);
     Person *person = [[Person alloc]init];
     __weak Person *weaakPerson1 = person;
     __weak Person *weaakPerson2 = person;
     __weak Person *weaakPerson3 = person;
     
     1.在初始化时，调用objc_initWeak方法，首先判断对象是否有效(不为nil),若对象无效，则weak修饰的变量指针指向的就是nil
     若对象有效，则调用storeWeak方法，这个方法的目的就是更新指针的指向，创建弱引用表
     2.在对象销毁时，最后会调用clearDeallocating函数，该函数会通过对象的地址找到弱引用表中的weak指针的数组，
     然后紧接着遍历这个数组，将其中的数组开始置为 nil;
     弱引用表其实是一个哈希表，存储在全局的哈希表Sidetables中，通过对象地址哈希值找到对应的SideTable,从而获取到弱引用表
     然后通过对象地址的哈希值找到弱引用表对应的下标，获取里面元素weak_table_t,从而获取里面的weak_entry_t信息，
     weak_entry_t里面存放的就是指向该对象的的弱引用weak指针数组
### 2. category的实现原理





### 3.iOS响应者链，怎么寻找最合适的响应者，如果为nil会怎么办

### 4.autoreleasePool的底层实现机制

### 5.dealloc的整个过程
 dealloc对象销毁过程
 1⃣️._objc_rootDealloc
 2⃣️. rootDealloc
    拿到对象的isa指针判断
   [是优化过的isa/不存在弱引用/没有设置过关联对象/没有CPP析构函数/引用计数存储在isa指针内部而不是存储在SideTable结构中]
   若上面5个条件同时都满足，则执行free(this)直接销毁对象即可；若上面条件有一个不满足，则执行步骤3⃣️
 3⃣️. object_dispose
 4⃣️. objc_destructInstance
     条件1: hasCxxDtor
     如果有析构函数: 则执行object_cxxDestruct方法 该方法其中一个功能是对对象的属性/成员变量进行置nil或者说销毁的
     我们创建一个继承自NSObject的对象，如果写上属性，则编辑器会自动为该对象添加隐式方法.cxx_desctruct(若全是assign类型的属性则不会有该方法)
     cxx_desctruct该方法会在object_cxxDestruct中被调用，用来销毁属性或者说对象的属性值都会被置为nil
 
     条件2: hasAssociatedObjects
     如果有关联对象，则执行_object_remove_assocations(obj)销毁关联对象
     关联对象存储在一个全局的由AssociationsManager管理的哈希表AssociationsHashMap中
     AssociationsManager -----  [disguised_ptr_t: ObjectAssociationMap] (AssociationsHashMap)
                                  对应的objc                 |
                                                    [void * : ObjcAssociation] (ObjectAssociationMap)
                                            对应关联对象时设置的key      ｜
                                                               uintptr_t _policy(对应策略)
                                                                  id _value](对应值)
    关联对象销毁过程:通过对象在全局的哈希表AssociationsHashMap中找到对应的ObjectAssociationMap哈希表，并将其清除，
    然后再将ObjcAssociation中对应的策略和值也清空
 
 4⃣️.1⃣️ 执行clearDeallocating()
    条件1: 如果isa指针没有被优化过，则执行sidetable_clearDeallocating()处理引用计数
    全局的SideTables哈希表   [objc : SideTable]   (SideTables)
     struct SideTable {
         spinlock_t slock;         自旋锁：用于上锁/解锁SideTable
         RefcountMap refcnts;      引用计数哈希表（key为对象，value为引用计数）
         weak_table_t weak_table;  弱引用哈希表[key是对象地址: value是entry]
     }
    struct weak_table_t { 弱引用哈希表
        weak_entry_t *weak_entries;         //hash数组(动态数组)
        size_t    num_entries;              //hash数组中元素的个数
        uintptr_t mask;                     //hash数组长度-1，而不是元素的个数，一般是做位运算定义的值
        uintptr_t max_hash_displacement;    //hash冲突的最大次数(最大哈希偏移值)
    };
    entry也可以理解为是哈希表，存储一个对象的所有弱引用, [key:是弱引用地址(id*): value也是弱引用地址]
    对应关系是[referent weak指针的数组]
    struct weak_entry_t {
        DisguisedPtr<objc_object> referent;   被弱引用的对象
        weak_referrer_t *referrers   指向 referent 对象的weak指针数组。动态数组保存弱引用,存储弱引用指针地址的hash数组
    }
    拿到对象的地址通过hash算法从全局的SideTables哈希表中获取到SideTable，通过SideTable拿到里面的引用计数哈希表refcnts
    如果有弱引用表，则去处理weak_clear_no_lock(&table.weak_table, (id)this)
    接着遍历引用计数哈希表refcnts,然后清除该对象的引用计数

    条件2: 如果isa指针被优化过，并且[有弱引用或使用了sideTable来存储引用计数]，则执行clearDeallocating_slow()
    如果有弱引用表，则去处理weak_clear_no_lock(&table.weak_table, (id)this);
    如果SideTable存储了引用计数，则从引用计数表中擦除该对象的引用计数。
 
    处理弱引用对象的销毁
    拿到对象的地址通过hash算法从全局的SideTables哈希表中获取到SideTable，通过SideTable拿到里面的弱引用哈希表weak_table
    在弱引用哈希表weak_table中找到对象对应的弱引用数组*referrers，遍历存放弱引用的数组，若弱引用的地址指向该对象，则将该弱引用置为nil
    然后将该weak_entity_t从弱引用表中移除
 5⃣️. free(obj); 最后直接销毁对象

### 7.关联对象的原理

### 8.多线程容易出现的问题，怎么解决

### 9.开发中遇到的crash

### 10.NSTimer、CADisplayLink以及GCD Timer的对比

### 11.手指触摸屏幕后系统都做了哪些事情

### 12.frame和bounds的区别

### 13.git常用命令

     git config --global user.name ""  指定用户名
     git config --global user.email "" 指定邮箱
     git init 初始化版本库(把这个目录变成Git可以管理的仓库)
     git add  工作区修改添加到暂存区
     git commit 将暂存区文件提交到本地仓库
     git push： 将本地仓库内容提交到远程仓库
     
     git log: 查看提交的历史日志(commit历史数据)，以便确定要回退到哪个版本
     git status 查看工作区/暂存区/本地仓库状态
     git checkout -- file  回撤修改(撤销工作区的修改，还没有add)
     git reset HEAD file   回撤修改(add到暂存区，但还没有commit)，回撤的是把这次add的记录给清除掉，即没有这次add了，工作区状态回到了add前的状态，即修改还存在；
     如果修改都不想要了，再次执行 git checkout -- file即可
     git reset --hard HEAD^  回退版本到上一个版本(这里的版本指的是commit)，HEAD^上个版本 HEAD^^前两个版本  HEAD-100前100个版本(add并且commit了，想回退)
     git reset --hard 1094a 回退版本到指定的版本(1094a代表指定版本的commitId)
     git reflog 查看历史命令 以便确定要回到未来的哪个版本。
     （假如有三个commit，当通过git reset从cmmit3回到commit2后，这时HEAD当前版本指向的就是commit2，
     如果想再回到commit3,此时git log看不到cmmit3了，那么就用git reflog查看历史版本，可以找到commit3的commitId进行回退）
     
     git checkout -b dev  :创建分支dev并切换到dev分支
     git checkout dev     :切换到分支dev
     git merge dev        :合并dev分支到当前分支
     git branch -d dev    :删除分支dev
     git branch           :查看有哪些分支
     
     1.本地有项目了，并创建了一个git仓库，但又想在Github上创建仓库并实现和本地项目同步
     git remote add origin git@github.com:XXX/XXX.git  将本地仓库和远程仓库关联
     git push -u origin master  本地库的所有内容推送到远程库
     2. 本地没有项目，远程仓库有项目
     git clone git@github.com:XXX/XXX.git 从远程仓库克隆项目到本机上

### 14 KVO底层原理
     对一个对象的属性添加KVO后，runtime会动态生成一个NSKVONotifity_XXX的子类，并且让对象的isa指针指向这个全新的子类；
     当修改对象的属性时，会调用Foundation下的NSSetXXXValueAndNotify函数，这个函数内部会调用WillChangeValueForKey/父类原来的setter方法/didChangeValueForKey
     didChangeValueForKey方法内部会触发监听器的监听方法observeValueForKeyPath:ofObject:change:context:方法
     生成的这个子类内部实现了4个方法：KVOA方法/监听属性的setter方法/dealloc/class，实现class方法的作用就是对外屏蔽KVO的内部实现细节
#### 如何手动实现KVO？
     手动调用WillChangeValueForKey和didChangeValueForKey
#### KVO可以监听可变数组NSMutableArray吗?
#### 可以监听，实现方式有两种
    方式一:创建一个新类，将可变数组作为该类的属性，然后监听该属性的变化即可，记得必须该对象的mutableArrayValueForKey获取数组，
          然后进行数组的增删改查操作切记不能通过对象的点语法来获取数组，这种方式获取是无法监听到数组变化的
    方式二:直接在操作可变数组的前后添加willChangeValueForKey 和 didChangeValueForKey手动开启KVO，也能实现可变数组的监听



#### 15.产生死锁的条件
1.主队列中添加同步任务(串行队列同步任务不会产生死锁)

        NSLog(@"---start");
        dispatch_queue_t queue = dispatch_get_main_queue();
        dispatch_sync(queue, ^{
            NSLog(@"111111");
        });
        NSLog(@"----end");
        
2.使用sync函数往当前串行队列中添加任务,会卡住当前的串行队列,产生死锁

        NSLog(@"---start");
        dispatch_queue_t queue = dispatch_queue_create("queue", DISPATCH_QUEUE_SERIAL); //串行队列
        dispatch_sync(queue, ^{
            NSLog(@"111111");
            //向当前串行队列中添加同步任务
            dispatch_sync(queue, ^{ //dispatch_sync立马在当前线程同步执行任务
                NSLog(@"22222");
            });
            NSLog(@"3333");
        });
        NSLog(@"----end");
        
#### 16 Block是如何实现的？Block对应的数据结构是什么样子的？__block的作用是什么？它对应的数据结构又是什么样子的？

 1.Block是封装了函数调用和上下文环境的匿名函数，本质是一个OC对象，
 2。底层是一个结构体，包含了两个成员变量impl，desc,impl存放isa指针和block内函数的地址，desc描述了block结构体占用内存的大小，结构体里面还包含捕获的变量信息，
 如果捕获的是对象类型的变量，则desc成员结构体中除了包含block占用内存大小的信息，还会多出来两个方法copy方法和dispose方法，用来决定block对捕获的对象是强引用还是弱引用，说白了就是用来管理捕获对象的内存的
 3. block主要分为三种类型，global Block/stack Block/malloc Block,没有访问auto变量的都是global Block,即便block访问了static静态变量也是global Block；访问了auto变量的block是stack Block；对stack Block进行copy操作的就变成了malloc Block；
 4. block对auto自动变量和static局部变量可以捕获，对全局变量和全局静态变量是不会捕获的，对auto是值捕获，对static局部变量是指针捕获
 5. 无论MRC还是ARC环境下，对于栈stack Block，block对捕获的对象类型的auto变量，都不会产生强引用；如果是ARC环境下，如果捕获的对象外部是强引用，则block对捕获的对象是强引用；如果外部是弱引用，则block结构体对捕获的变量是弱引用
 6.ARC环境下，iOS会对以下情况，对栈block进行copy操作，使其成为堆Block，为什么要进行copy操作，原因就是栈block什么时候销毁我们是控制不了的，而堆Block什么时候销毁我们是知道的，栈Block访问外部变量容易导致不可预知的错误；【Block被强指针引用】【GCD中的Block】【cocoaAPI中出现的useingBlock】
 7.Block访问外部变量，只能访问不能修改，如果想要修改，则需要在外部变量前面添加__block标识，被__block标识的变量，编译器会将__block修饰的变量包装成一个对象(底层就是个结构体)，block底层内部结构会有个指针指向这个包装的结构体，然后通过指针修改结构体中的成员变量
 8. 解决循环引用方式：
 1. __weak修饰(弱引用): 指向的对象销毁时,会自动让指针置为nil
 2. __unsafe_unretained修饰(弱引用): 指向的对象销毁时,指针存储的地址值不变
 3. __block(必须调用block并在block内对访问的变量在不需要时置为nil)
 
 
 
 
#### 17. GCD中的Block是在堆上还是栈上？
#### 在堆上
    
    
#### 18. NSNotificaiton是同步还是异步的，如果发通知时在子线程，接收在哪个线程？
#### NSNotificaiton是同步执行的，如果发送的通知在子线程，则接收的通知方法也是在发送通知的那个子线程中接收的；如果多次调用postNotificationName发送通知，则也会多次收到通知消息


#### 19. NSCoding协议是干什么用的？
     一种编码协议，归档时和解档时需要依赖该协议定义的编码和解码方法。Foundation和Cocoa Touch中的大部分类都遵循了这个协议，一般被NSKeyedArchiver做自定义对象持久化时使用。
     数据持久化对于自定义类型的数据是无法存储的，必须通过序列化(编解码)才能存储

#### 20. NSOperation有哪些特性比着GCD有哪些优点，它有哪些API？

     NSOperation/NSOperationQueue 是对GCD的高度封装，使用步骤 1.创建操作 2.创建操作队列 3.将操作添加到操作队列中
     NSOperation提供了两个子类来创建操作：NSBlockOperation/NSInvocationOperation，
     也可以自定义继承自NSOperation的类来创建操作，需要重写main方法或start方法
    【1】在不使用NSOperationQueue操作队列的情况下，
     1.单纯使用NSBlockOperation创建操作(没有调用addExecutionBlock)，然后start,那么任务执行就是在当前线程中同步执行的
     2.如果通过addExecutionBlock方法继续添加添加操作，那么系统就会新开线程来执行添加的操作任务(具体开多少个线程由系统决定)，操作之间是异步执行的，但是第一个创建的NSBlockOperation操作仍然是当前线程中执行
     3.在没有操作队列NSOperationQueue参与下，不能添加操作之间的依赖（会crash）
    【2】操作NSOperation和操作队列NSOperationQueue结合情况下
     1.将操作添加到操作队列后，(操作)任务之间会异步执行
     2.操作之间可以设置依赖关系：谁依赖谁(谁在谁的后面执行),必须是先添加依赖关系，然后再将操作添加到队列中
     3.maxConcurrentOperationCount=1.则是串行队列
    【3】NSOperationQueue操作队列分为2种，主队列和自定义队列，主队列在主线程中执行任务，自定义队列在系统分配的子线程中执行
     
     特性：
          1.可以设置线程最大并发数量
          2.操作(任务)之间可以添加依赖，控制操作(任务)执行顺序；可以单个取消、暂停操作(任务)
          3.只有主队列和自定义队列，没有像GCD中的(串行队列/并发队列/主队列/全局并发队列)
          4.操作队列可以取消队列中的所有操作(任务)
     区别：1.NSOperation/NSOperationQueue是面向对象的，是对GCD的封装，所以效率上GCD更胜一筹；GCD是一套C语言的API
          2.NSOperation可以通过KVO监听操作(任务)的状态(取消/暂停/执行/完成)；GCD无法通过KVO进行判断
          3.NSOperation可以设置操作(任务)自身的优先级，但是优先级高的不一定先执行；GCD只能设置队列的优先级，无法在执行的block设置优先级；
     

#### 21.ARC方案的原理是什么？它是在什么时候做的隐式添加release操作？(https://www.jianshu.com/p/a40fafc6f824) 
     ARC自动引用计数，通过LLVM编辑器自动管理对应的引用计数，ARC开启时，无需手动键入retain/release,它是在编译阶段添加retain或者release代码的
     
     1.arm64架构之后，iOS的引用计数存储在对象优化过的isa指针中，isa指针利用位域技术来存储更多信息，isa指针占8个字节，共64位，
     用最后的19位来存储引用计数(引用计数-1),如果引用计数不够存储(最多存储255个)，会存储在全局的哈希数组SideTables中
     2.SideTables是一个64个元素长度的哈希数组，里面存储的元素类型都是SideTable，SideTables的hash键值就是一个对象obj的address，
     所以一个对象对应一个SideTable，一个SideTable可以对应多个对象
     3.SideTable底层是个结构体，里面存储了三个成员变量：自旋锁/弱引用表/引用计数表
     4.通过对象的地址在全局的哈希数组中找到SideTable，然后在SideTable中获取到引用计数表，然后通过对象的地址经过哈希函数找到
     引用计数表中的桶(其实就是桶数组中的元素，元素类型类似swift中的元素(对象,引用计数)),对引用计数进行加减
     5.引用计数表其实就是个数组，通过对象的地址经过哈希函数找到对应的引用计数值进行+1或-1操作，需要注意这个哈希表(数组)同样会存储哈希冲突的问题
     刚开始假如分配了10个元素的空间（buckets），有ABC三个对象，拿对象的地址通过哈希函数后找到数组的下标，如果下标对应的是空桶(bucket)则存储对象，假如是下标为0的桶存储了A对象，此时对象B如果哈希后的下标也是0，则发现不是空桶，则需要进行下一步哈希算法来查找合适的位置，假如是4，则下标4存储B对象的引用计数；依次类推
     假如对象A在下标为3的桶位置，如果对象A销毁，会将该位置标记为墓碑，如果有新的对象B进来，通过哈希算法获取的下标也是下标3(墓碑位置)，那么就继续进行哈希算法
     进行查找，如果找到了空桶，则证明对象B在引用计数表中不存在，此时就可以将存放墓碑的下标(下标3)的位置拿来存储对象B的引用计数了，这样就可以利用释放掉的空间了

#### 22  循环引用有哪些场景，如何避免？
     1.CADisplayLink/NSTimer会对target产生强引用，导致无法释放，可以通过NSProxy代理，或者NSTimer通过Block方式创建，
     若Block内部访问了target,则通过__weak标识
     2.使用Block时，某个类将block作为属性，并且block内部又访问了该类本身，就容易导致循环引用，解决方法有以下几种
        1),将访问的类本身用__weak标识，这样Block内部对本类对象就是弱引用;对象销毁时会自动置为nil
        2),将访问的类本身用__unsafe_unretained标识，这样Block内部对本类对象就是弱引用;对象销毁时，不会自动置为nil
        3)将访问的类本身用__block标识，然后在block内部记得设置为nil,然后调用Block即可
     3.委托代理(delegate),声明delegate时请用assign(MRC)或者weak(ARC)
     4.NSNotificationCenter，注册通知和移除通知要成对出现，否则所在的VC无法释放，导致循环引用；
       ⚠️这里需要区分情况
       1)用addObserver:selector:name:object:注册通知，在iOS9之后，我们可以不用手动移除通知，系统会帮我们做
       2)用addObserverForName:object:queue:usingBlock:(void (^)(NSNotification *note))block注册通知，方法会返回个Observer，用于移除通知，
     如果block内访问了当前页面信息(self),则会产生循环引用，导致当前VC无法释放，所以如果需要访问当前页面信息(self),则需要标记为__weak即可；
     同时同时⚠️在VC销毁dealloc中必须移除这个通知，因为这个注册通知方式，NSNotificationCenter也会对Observer引用着，Observer也是不会释放的
     验证流程就是第一个页面发送通知，第二页面注册通知，并有发送通知的触点，然后从第二个页面返回后，再次进入第二个页面，会收到通知，说明Observer并没有释放
     解决问题方式就是：在VC销毁时，移除到这个通知
     
             @property(nonatomic, strong) NSObject *observerName;
             __weak typeof(self) weakSelf = self;
             //返回一个Observer，系统持有
             self.observerName = [[NSNotificationCenter defaultCenter] addObserverForName:@"111" object:nil queue:NSOperationQueue.mainQueue usingBlock:^(NSNotification * _Nonnull note) {
                 NSLog(@"1111-----%@----%p",note.userInfo,weakSelf);
             }];
             -(void)dealloc {
                 [[NSNotificationCenter defaultCenter] removeObserver:self.observerName];
                 NSLog(@"---%s",__func__);
             }
         
     4.1
     如果postNotificationName是在主线程中发送的，则接受通知也是在主线程；若postNotificationName发送通知是在子线程中，则接收通知也是在该子线程中；
     注册通知addObserver如果在子线程中，则发送通知postNotificationName必须也在这个子线程中才能接收到通知消息，否则接收不到通知消息
     注册通知addObserver在主线程中，则发送通知postNotificationName可以在主线程也可以在子线程中，只是接收通知在对应的主线程或子线程中接收即可

#### 23 为什么当我们在使用block时外面是weak 声明一个weakSelf，还要在block内部使用strong再持有一下？
     block外面声明的__weak,是为了实现Block对对象的弱引用，block内使用__strong是为了保证block内使用过程中不会发生释放
     
    1.block外部声明__weak,block就会对这个对象是弱引用，避免循环引用
    int main(int argc, const char * argv[]) {
        @autoreleasepool {
            
            WGPerson *person = [[WGPerson alloc]init];
            person.age = 18;
            __weak WGPerson *weakPerson = person;
            person.personBlock = ^{
                NSLog(@"person age is %d",weakPerson.age);
            };
            person.personBlock();
        }
        return 0;
    }
    
    2.大括号结束后，person对象已经销毁了，而过2秒后，才开始执行打印信息“person age is %d”，此时对象销毁了，所以不会再有信息打印了
    
        - (void)viewDidLoad { 
            Person *person = [[Person alloc]init];
            person.age = 18;
            __weak Person *weakPerson = person;
            person.personBlock = ^{
                NSLog(@"1111");
                dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0*NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
                    NSLog(@"person age is %d",weakPerson.age);
                });
                NSLog(@"2222");
            };
            person.personBlock();
        }

        打印结果: 1111
                2222
                -[Person dealloc]

    3.解决上面问题的方式就是在block内使用__strong，来保证block内部在使用过程中，person对象不会销毁，Person对象中有block，对Block是强引用，Block内部对Person对象是弱引用，Block内部又有个block，这个block对弱引用对象是强引用，这样就可以避免person对象在block内使用过程中被销毁了
    
        -(void)viewDidLoad {
            [super viewDidLoad];
            Person *person = [[Person alloc]init];
            person.age = 18;
            __weak Person *weakPerson = person;
            person.personBlock = ^{
                __strong Person *strongPerson = weakPerson;
                NSLog(@"1111");
                dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0*NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
                    NSLog(@"person age is %d",strongPerson.age);
                });
                NSLog(@"2222");
            };
            person.personBlock();
        }
        打印结果: 1111
                2222
                person age is 18
                -[WGPerson dealloc]


#### 24.Autoreleasepool是实现机制是什么？它是什么时候释放内部的对象的？它内部的数据结构是什么样的？当我提到哨兵对象时，会继续问哨兵对象的作用是什么，
为什么要设计它？哪些对象会放入到Autoreleasepool中？
     
     1。Autoreleasepool自动释放池，是iOS中的一种内存回收机制，它可以将加入自动释放池中的对象的release的时机延迟;也就是说正常创建的对象在
     超出作用域后会立马销毁；而如果加入自动释放池，则该对象不会立刻释放销毁，而是等到当前RunLoop休眠或者超出AutoReleasePool的作用域{}之后才会被释放
     2.@Autoreleasepool自动释放池，在其作用域开始和结束的位置分别会调用objc_autoreleasePoolPush构造函数和objc_autoreleasePoolPop析构函数
     3.加入自动释放池时调用objc_autoreleasePoolPush方法；在调用析构函数objc_autoreleasePoolPop的时候会释放这些对象
     
     4.Autoreleasepool自动释放池底层结构是一个以AutoreleasePoolPage为页的双向链表，每个AutoreleasePoolPage占用4096个字节，除了用来存放
     它内部的成员变量外，剩下的空间用来存放autorelease对象的地址，AutoreleasePoolPage内部成员变量有7个，成员变量占用56个字节，剩下的4040个字节用来存放autorelease对象
     5. 一个AutoreleasePoolPage的空间被占满时，会新建一个新的AutoreleasePoolPage对象，连接链表，后来的autorelease对象加入到新的page
     6. 调用push方法时，会先将一个POOL_BOUNDARY(哨兵对象/边界对象)入栈POOL_BOUNDARY，值为nil，作为边界，然后返回这个边界对象POOL_BOUNDARY
     的内存地址；push就是压栈操作，先加入边界对象，然后再添加autorelease对象
     7. 调用pop方法时传入一个POOL_BOUNDARY的内存地址，会从最后一个入栈的对象开始发送release消息，直到遇到这个POOL_BOUNDARY
     
     8. autorelease对象在什么时候释放？
        程序运行启动时，RunLoop会注册两个Observer来管理和维护AutoreleasePool，
       6.1一个Observer用来检测进入RunLoop的状态(kCFRunLoopEntry)，此时会调用objc_autoreleasePoolPush方法向当前的AutoreleasePoolPage
       增加一个POOL_BOUNDARY标志创建自动释放池。
       6.2一个Observer用来检测RunLoop即将进入休眠状态(kCFRunLoopBeforeWaiting)和退出状态(kCFRunLoopExit),
       在检测到RunLoop即将进入休眠状态时，会调用objc_autoreleasePoolPop() 和objc_autoreleasePoolPush() 方法.
       系统会根据情况从最新加入的对象一直往前清理直到遇到POOL_BOUNDARY标志
       在检测到RunLoop退出状态时，会调用objc_autoreleasePoolPop() 方法释放自动释放池内对象
       ⚠️所以autorelease的释放时机取决于RunLoop的运行状态，在RunLoop即将进入休眠和退出状态时，会释放AutoreleasePool自动释放池中所有的autorelease对象
     9. 每一页page里都存储了next指针，指向下次新添加的autoreleased对象的位置
     10. 每一页都有一个深度标记，第一页深度值为0，后面的页面递增1
     11. 自动释放池存储在栈区，page内部地址从低到高依次存储：AutoreleasePoolPage自身的成员、哨兵、自动释放的对象。
     12. 哨兵作为对象指针的边界，在释放池里只会有一个,如果autoreleasepool嵌套,那么可能会有多个哨兵对象
     13. 调用pop方法时传入一个POOL_BOUNDARY的内存地址，会从最后一个入栈的对象开始发送release消息，直到遇到这个POOL_BOUNDARY
     
     
     哨兵对象作用：用来标记autorelease对象从哪里开始存储的，主要就是为了方便后续释放对象时查找结束位置
     
     哪些对象会放入到Autoreleasepool中？
        1)非alloc/new/copy/mutablecopy 开始的方式初始化时。
        2)id的指针或对象的指针在没有显示指定时


#### 25.类方法是存储到什么地方的？类属性呢？
         类class属性，编译器不会生成类属性的setter/getter方法;⚠️必须我们自己实现，否则在使用的时候会报错
         @property(nonatomic, strong, class) NSString *name;
         
         对象属性，默认编译器会生成属性的setter/getter方法声明、实现、带下划线(_parentName)的成员变量
         @property(nonatomic, strong) NSString *parentName;

         类方法、类属性都存储在元类对象中













































