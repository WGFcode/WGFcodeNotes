### 1.weak的实现原理
### __weak/__unsafe_unretained都是弱引用，都是对指向的对象进行弱引用，不同点就是若__weak指针指向的对象销毁了，那么weak指针会自动置为nil;但是__unsafe_unretained不会置为nil,会导致野指针问题





### 2. category的实现原理
### 3.iOS响应者链，怎么寻找最合适的响应者，如果为nil会怎么办

### 4.autoreleasePool的底层实现机制

### 5.dealloc的整个过程
 dealloc对象销毁过程
 1⃣️._objc_rootDealloc
 2⃣️. rootDealloc
    拿到对象的isa指针判断
   [是优化过的isa/不存在弱引用/没有设置过关联对象/没有CPP析构函数/引用计数存储在isa指针内部而不是存储在SideTable结构中]
   若上面5个条件同时都满足，则执行free(this)直接销毁对象即可；若上面条件有一个不满足，则执行步骤3⃣️
 3⃣️. object_dispose
 4⃣️. objc_destructInstance
     条件1: hasCxxDtor
     如果有析构函数: 则执行object_cxxDestruct方法 该方法其中一个功能是对对象的属性/成员变量进行置nil或者说销毁的
     我们创建一个继承自NSObject的对象，如果写上属性，则编辑器会自动为该对象添加隐式方法.cxx_desctruct(若全是assign类型的属性则不会有该方法)
     cxx_desctruct该方法会在object_cxxDestruct中被调用，用来销毁属性或者说对象的属性值都会被置为nil
 
     条件2: hasAssociatedObjects
     如果有关联对象，则执行_object_remove_assocations(obj)销毁关联对象
     关联对象存储在一个全局的由AssociationsManager管理的哈希表AssociationsHashMap中
     AssociationsManager -----  [disguised_ptr_t: ObjectAssociationMap] (AssociationsHashMap)
                                  对应的objc                 |
                                                    [void * : ObjcAssociation] (ObjectAssociationMap)
                                            对应关联对象时设置的key      ｜
                                                               uintptr_t _policy(对应策略)
                                                                  id _value](对应值)
    关联对象销毁过程:通过对象在全局的哈希表AssociationsHashMap中找到对应的ObjectAssociationMap哈希表，并将其清除，
    然后再将ObjcAssociation中对应的策略和值也清空
 
 4⃣️.1⃣️ 执行clearDeallocating()
    条件1: 如果isa指针没有被优化过，则执行sidetable_clearDeallocating()处理引用计数
    全局的SideTables哈希表   [objc : SideTable]   (SideTables)
     struct SideTable {
         spinlock_t slock;         自旋锁：用于上锁/解锁SideTable
         RefcountMap refcnts;      引用计数哈希表（key为对象，value为引用计数）
         weak_table_t weak_table;  弱引用哈希表[key是对象地址: value是entry]
     }
    struct weak_table_t { 弱引用哈希表
        weak_entry_t *weak_entries;         //hash数组(动态数组)
        size_t    num_entries;              //hash数组中元素的个数
        uintptr_t mask;                     //hash数组长度-1，而不是元素的个数，一般是做位运算定义的值
        uintptr_t max_hash_displacement;    //hash冲突的最大次数(最大哈希偏移值)
    };
    entry也可以理解为是哈希表，存储一个对象的所有弱引用, [key:是弱引用地址(id*): value也是弱引用地址]
    对应关系是[referent weak指针的数组]
    struct weak_entry_t {
        DisguisedPtr<objc_object> referent;   被弱引用的对象
        weak_referrer_t *referrers   指向 referent 对象的weak指针数组。动态数组保存弱引用,存储弱引用指针地址的hash数组
    }
    拿到对象的地址通过hash算法从全局的SideTables哈希表中获取到SideTable，通过SideTable拿到里面的引用计数哈希表refcnts
    如果有弱引用表，则去处理weak_clear_no_lock(&table.weak_table, (id)this)
    接着遍历引用计数哈希表refcnts,然后清除该对象的引用计数

    条件2: 如果isa指针被优化过，并且[有弱引用或使用了sideTable来存储引用计数]，则执行clearDeallocating_slow()
    如果有弱引用表，则去处理weak_clear_no_lock(&table.weak_table, (id)this);
    如果SideTable存储了引用计数，则从引用计数表中擦除该对象的引用计数。
 
    处理弱引用对象的销毁
    拿到对象的地址通过hash算法从全局的SideTables哈希表中获取到SideTable，通过SideTable拿到里面的弱引用哈希表weak_table
    在弱引用哈希表weak_table中找到对象对应的弱引用数组*referrers，遍历存放弱引用的数组，若弱引用的地址指向该对象，则将该弱引用置为nil
    然后将该weak_entity_t从弱引用表中移除
 5⃣️. free(obj); 最后直接销毁对象

### 7.关联对象的原理

### 8.多线程容易出现的问题，怎么解决

### 9.开发中遇到的crash

### 10.NSTimer、CADisplayLink以及GCD Timer的对比

### 11.手指触摸屏幕后系统都做了哪些事情

### 12.frame和bounds的区别

### 13.git常用命令

     git config --global user.name ""  指定用户名
     git config --global user.email "" 指定邮箱
     git init 初始化版本库(把这个目录变成Git可以管理的仓库)
     git add  工作区修改添加到暂存区
     git commit 将暂存区文件提交到本地仓库
     git push： 将本地仓库内容提交到远程仓库
     
     git log: 查看提交的历史日志(commit历史数据)，以便确定要回退到哪个版本
     git status 查看工作区/暂存区/本地仓库状态
     git checkout -- file  回撤修改(撤销工作区的修改，还没有add)
     git reset HEAD file   回撤修改(add到暂存区，但还没有commit)，回撤的是把这次add的记录给清除掉，即没有这次add了，工作区状态回到了add前的状态，即修改还存在；
     如果修改都不想要了，再次执行 git checkout -- file即可
     git reset --hard HEAD^  回退版本到上一个版本(这里的版本指的是commit)，HEAD^上个版本 HEAD^^前两个版本  HEAD-100前100个版本(add并且commit了，想回退)
     git reset --hard 1094a 回退版本到指定的版本(1094a代表指定版本的commitId)
     git reflog 查看历史命令 以便确定要回到未来的哪个版本。
     （假如有三个commit，当通过git reset从cmmit3回到commit2后，这时HEAD当前版本指向的就是commit2，
     如果想再回到commit3,此时git log看不到cmmit3了，那么就用git reflog查看历史版本，可以找到commit3的commitId进行回退）
     
     git checkout -b dev  :创建分支dev并切换到dev分支
     git checkout dev     :切换到分支dev
     git merge dev        :合并dev分支到当前分支
     git branch -d dev    :删除分支dev
     git branch           :查看有哪些分支
     
     1.本地有项目了，并创建了一个git仓库，但又想在Github上创建仓库并实现和本地项目同步
     git remote add origin git@github.com:XXX/XXX.git  将本地仓库和远程仓库关联
     git push -u origin master  本地库的所有内容推送到远程库
     2. 本地没有项目，远程仓库有项目
     git clone git@github.com:XXX/XXX.git 从远程仓库克隆项目到本机上

### 14 KVO底层原理
     对一个对象的属性添加KVO后，runtime会动态生成一个NSKVONotifity_XXX的子类，并且让对象的isa指针指向这个全新的子类；
     当修改对象的属性时，会调用Foundation下的NSSetXXXValueAndNotify函数，这个函数内部会调用WillChangeValueForKey/父类原来的setter方法/didChangeValueForKey
     didChangeValueForKey方法内部会触发监听器的监听方法observeValueForKeyPath:ofObject:change:context:方法
     生成的这个子类内部实现了4个方法：KVOA方法/监听属性的setter方法/dealloc/class，实现class方法的作用就是对外屏蔽KVO的内部实现细节
#### 如何手动实现KVO？
     手动调用WillChangeValueForKey和didChangeValueForKey
#### KVO可以监听可变数组NSMutableArray吗?
#### 可以监听，实现方式有两种
    方式一:创建一个新类，将可变数组作为该类的属性，然后监听该属性的变化即可，记得必须该对象的mutableArrayValueForKey获取数组，
          然后进行数组的增删改查操作切记不能通过对象的点语法来获取数组，这种方式获取是无法监听到数组变化的
    方式二:直接在操作可变数组的前后添加willChangeValueForKey 和 didChangeValueForKey手动开启KVO，也能实现可变数组的监听

