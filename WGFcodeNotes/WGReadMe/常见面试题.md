### 1.weak的实现原理 / weak的实现原理是什么？当引用对象销毁是它是如何管理内部的Hash表的？（这里要参阅weak源码）
### __weak/__unsafe_unretained都是弱引用，都是对指向的对象进行弱引用，不同点就是若__weak指针指向的对象销毁了，那么weak指针会自动置为nil;但是__unsafe_unretained不会置为nil,会导致野指针问题

     weak使用场景：1.解决循环引用,用__weak标记，2.委托代理delegate用weak修饰
     
     被weak标记的对象在被使用过程中，不会使对象的引用计数(增加)+1，而且这个对象销毁时，被weak标记的变量会自动置为nil, 不会产生野指针问题
     __weak NSObject *obj1 = obj;       编译为：objc_initWeak(&obj1, obj);
     Person *person = [[Person alloc]init];
     __weak Person *weaakPerson1 = person;
     __weak Person *weaakPerson2 = person;
     __weak Person *weaakPerson3 = person;
     
1.在初始化时，调用objc_initWeak方法，首先判断对象是否有效(不为nil),若对象无效，则weak修饰的变量指针指向的就是nil
若对象有效，则调用storeWeak方法，这个方法的目的就是更新指针的指向，创建弱引用表      
2.在对象销毁时，最后会调用clearDeallocating函数，该函数会通过对象的地址找到弱引用表中的weak指针地址的数组，     
然后紧接着遍历这个数组，将其中的数据置为 nil，最后把这个entry从弱引用表中移除;        
3.弱引用表其实是一个哈希表，存储在全局的哈希表Sidetables中，通过对象地址哈希值找到对应的SideTable,从而获取到弱引用表    
然后通过对象地址的哈希值找到弱引用表对应的下标，获取weak_entries数组里面的元素weak_entry_t,weak_entry_t是一个hash结构的表    
key是所指对象的地址，value是weak指针的地址数组，weak_entry_t里面存放的就是指向该对象的的弱引用weak指针地址的数组    
     
### 2. category的实现原理
1.category底层结构是一个category_t结构体，里面存储着分类的对象方法/类方法/属性/协议信息，在程序运行时，runtime会将category分类中的数据，
通过内存移动和内存拷贝将分类中的信息合并到类信息中(合并都是将分类信息添加到类信息前面)        
2.分类中声明的属性，只会生成属性对应的getter/setter方法声明，不会自动生成属性对应的带下划线的成员变量(因为分类中没有存放成员变量的结构)，
也不会生成属性的getter/setter方法实现         
3.分类中不能添加成员变量，这是因为分类底层结构中不存在存储成员变量的变量；成员变量在编译期内存布局已经确定了，存放在对象结构体中，所以运行时无法添加         
4.如果类和分类中都有方法A，则调用方法A时，会优先调用分类中的方法A，因为分类中的方法A在方法列表(方法数组)中的前面，而类方法A在方法列表的后面      
5.分类A和分类B中都有方法testFunc，那么就看哪个分类先编译了，先编译的分类的方法【后调用】，先编辑的先放到方法列表中，然后后编译的会插入到方法列表的前面    
6.分类中可以添加对象方法、类方法、属性、遵守协议等;分类是在运行时才去加载的      
7. 分类中的信息是如何添加到类信息中的？在运行时Runtime会通过内存移动和内存拷贝将分类的信息合并到类信息列表的前面，例如方法列表插入到
类的方法列表的前面，属性协议都一样，都是添加到类信息中属性协议列表的前面，所以如果如果分类和对象中存在相同的方法,首先调用的是分类中的
方法,因为查找方法最先调用的是类对象方法列表最前面出现的方法, 而方法列表中最前面的方法存放的是分类的方法, 即方法覆盖, 更严格的来说，
并不是方法覆盖,而是优先调用了分类中的方法, 而原来类中的方法仍然存在类对象的方法列表中,只是分类中的方法调用的优先级更高         
 
        //分类底层结构category_t
        struct category_t {
            const char *name;                               //分类名称
            classref_t cls;                                 //类对象
            struct method_list_t *instanceMethods;          //对象方法列表 一维数组[method_t]
            struct method_list_t *classMethods;             //类方法列表 一维数组[method_t]
            struct protocol_list_t *protocols;              //协议列表 一维数组[method_t]
            struct property_list_t *instanceProperties;     //属性列表 一维数组[property_t]
            // Fields below this point are not always present on disk.
            struct property_list_t *_classProperties;
        };
     
     
#### load和initialize区别
1.调用方式不同: load是根据函数地址直接调用；initialize方法是通过objc_msgSend机制调用的 
       
2.调用时机不同：load方法是在runtime加载类/分类时调用的；initialize方法是类在第一次接收到消息时调用的，每个类的initialize方法
只会调用一次(父类的initialize可能会被调用多次)        

3.调用顺序不同:

        load: 1.先调用类的load方法(先编译的类先调用load，调用子类的load方法前，先调用父类的load方法) 2.再调用分类的load方法(先编译的分类先调用load)
        initialize：先初始化父类；再初始化子类(最终调用的可能是父类的initialize方法)


### 3.iOS响应者链，怎么寻找最合适的响应者，如果为nil会怎么办
* 1.点击屏幕，UIKit会生成UIEvent对象来描述触摸事件(触摸坐标等信息)，将该对象加入到AppDelegate的事件队列中，AppDelegate会从事件队列
中取出触摸事件传递给UIWindow来的处理，UIWindow会通过视图的hitTest:withEvent:和pointInside:withEvent:方法找到第一响应者
* 2.事件传递给keyWindow后，会调用keyWindow的hitTest:withEvent:方法，在hitTest:withEvent:方法中会先调用
keyWindow的pointInside:withEvent:方法判断当前的点是否在keyWindow范围上    
* 3.如果在keyWindow范围内，会遍历keywindow所有的子视图(遍历顺序就是从subView.count-1开始一直到1,即最后addSubview的子视图最先遍历)，
调用子视图的hitTest:withEvent:方法,如果子视图的pointInside:withEvent:方法返回false，则hitTest:withEvent:方法返回nil;
如果子视图的pointInside:withEvent:方法返回true，并且这个子视图还包含子视图则继续遍历子视图的所有子视图，
并执行同样的操作,如果这个子视图没有子视图了，则hitTest:withEvent:方法会把这个子视图返回，这个子视图也就是查找的第一响应者    
* 4.最终这个第一响应者会顺着响应者链，传递回Application,这样Application就知道了第一响应者是谁了
* 5.Application知道了第一响应者，就会把事件交给响应者来处理，如果响应者能处理，那么整个触摸事件响应过程结束
* 6.如果响应者无法处理触摸事件，就会把事件传递给下一个响应对象(响应者的父视图)，沿着响应链一直向上传递，直到传递到Application
* 7.如果Application也无法处理，则会丢弃该事件
* 8 UIView不能接收事件的情况：1.userInteractionEnabled = NO 2.hidden=YES 隐藏的控件不能接受事件 3.如果设置一个控件的透明度<0.01，会直接影响子控件的透明度
 
#### 事件的传递和响应的区别：事件的传递是从上到下（父控件到子控件），事件的响应是从下到上（顺着响应者链条向上传递：子控件到父控件。
#### 总结:如果我们想指定哪个视图去响应事件，那么可以找到它的父试图，    

1.在父视图中重写hitTest:withEvent方法，判断触摸点坐标在指定视图的范围，那么就并返回这个指定的视图，否则返回super.hitTest:withEvent:
2.在父视图中重写pointInside:withEvent:方法，判断触摸点坐标在指定视图的范围，那么就返回true,否则返回false；
pointInside:withEvent:方法返回true：查找响应者可以继续向它的子视图去查找，返回false：则hitTest:withEvent:方法会返回nil，表示响应者不在视图范围
 
        hitTest:withEvent: 寻找并返回第一响应者
        pointInside:withEvent:判断点在不在当前view上
    
#### 如何判断上一个响应者？
1 如果当前这个view是控制器的view,那么控制器就是上一个响应者     
2 如果当前这个view不是控制器的view,那么父控件就是上一个响应者

#### 事件响应分为
1.事件传递链: Application -> UIWindow ->hitTest:withEvent(pointInside:withEvent) ->subViews(遍历子视图数组，谁后add进来的先遍历谁)
2.事件响应链: 由离用户最近的view向下一个响应者传递

#### 这里有类似面试题: 在VC中有个按钮UIButton,有点击事件testA;按钮的上层有个全屏的视图B，有个点击事件testB,当点击按钮时，响应的肯定时事件testB,
如何处理才能让点击按钮区域时响应事件testA,不是按钮区域时响应事件testB
#### 这里就涉及到事件穿透了，有以下方式可以解决
1. 修改视图层级关系，将视图A通过bringSubviewToFront方法放在视图层级中的最外层，这样点击按钮区域就可以响应了
这种方式主要是利用事件传递关系来的(按钮先添加，然后添加了视图B，所以遍历查询事件是先从视图B开始的，调整下视图层级就可以先遍历按钮了)
2. 不改变视图层级的情况下，我们可以在视图B种通过方法point(inside: event:)判断若点击的区域属于按钮，则返回false,表示触摸点不在视图B，
那么就会顺着去检查按钮视图了，这样点击按钮区域就可以响应事件了，判断点击区域是否属于按钮设计到坐标系转换

    A.convert(point, to: B)  //point是相对A的坐标系，以B为坐标系重新计算point
    A.convert(point, from: B) //point是相对于B的坐标系，以A为坐标系重新计算point
    
    //方式二: 在视图B中通过point(inside:event)判断点击区域是否在指定区域，如果是指定区域则返回false,否则返回true
    override func point(inside point: CGPoint, with event: UIEvent?) -> Bool {
        //let newPoint = self.convert(point, to: self.superview!)  //point是相对于self的，以self.superView为坐标系计算point
        let newPoint = self.superview!.convert(point, from: self)  //point是相对于self的，以self.superView为坐标系计算point
        if btn.frame.contains(newPoint) { //点击的区域是在按钮身上
            return false
        }
        return true
    }
    
    或者通过hitTest(point::event)判断也可以
    override func hitTest(_ point: CGPoint, with event: UIEvent?) -> UIView? {
        //判断点击点是否在按钮区域内，若在则直接返回按钮视图，这样就能响应事件了
        let clickPoint = self.convert(point, to: btn)
        if btn.point(inside: clickPoint, with: event) {
            return btn
        }
        return super .hitTest(point, with: event)
    }
    
    延伸，通过hitTest(point::event)方法可以扩大按钮的点击区域
    override func hitTest(_ point: CGPoint, with event: UIEvent?) -> UIView? {
        // 0 0 100 100 ---> -20 -20 120 120
        let newFrame = self.bounds.insetBy(dx: -20, dy: -20)
        return newFrame.contains(point) ? self : nil
    }
    通过point(inside:event)方法扩大按钮的点击区域
    override func point(inside point: CGPoint, with event: UIEvent?) -> Bool {
        let newFrame = CGRectInset(self.bounds, -20, -20)
        return CGRectContainsPoint(newFrame, point)
    }
3. 手势识别器和触摸事件可以并存，当一个视图同时添加了触摸事件和手势识别器时，当触摸开始，手势识别器和视图都可以接收到触摸事件    
但是，手势识别器会首先接收并处理触摸事件，如果手势识别器识别出了手势，那么它就会“吞掉”这次触摸事件，视图的触摸事件处理方法就不会被调用     
如果手势识别器没有识别出手势，那么这次触摸事件就会被视图的触摸事件处理方法接收并处理
这种行为可以通过手势识别器的cancelsTouchesInView属性来改变。如果将该属性设置为NO，那么即使手势识别器识别出了手势，视图的触摸事件处理方法仍然会被调用    



### 4. autorelease对象什么时候释放？作用是什么？底层原理是什么？听过哨兵对象吗？它的作用是什么？为什么需要哨兵对象？哪些对象会放入自动释放池Autoreleasepool

#### 先回答结论: 
1. autorelease对象的释放时机取决于RunLoop的运行状态，在RunLoop即将进入休眠和退出状态时，会释放AutoreleasePool自动释放池中所有的autorelease对象
即向自动释放池中的所有对象发送release消息进行销毁

2.自动释放池用来延迟对象释放销毁，将对象加入自动释放池后对象出了作用域不会立马销毁，等到自动释放池销毁时
(当次runloop休眠或者退出时/或超出AutoReleasePool的作用域{})才会向池中所有对象发送release消息进行销毁。

3.自动释放池是iOS中的一种内存收回机制，项目中一般使用的就是@autoreleasepool {业务代码}，系统会在作用域开始和结束位置调用
objc_autoreleasePoolPush构造函数和objc_autoreleasePoolPop析构函数。 

4.Autoreleasepool自动释放池底层结构是一个以AutoreleasePoolPage为页的双向链表，每个AutoreleasePoolPage占用4096个字节，除了用来存放    
它内部的成员变量外，剩下的空间用来存放autorelease对象的地址，AutoreleasePoolPage内部成员变量有7个，成员变量占用56个字节，剩下的4040个字
节用来存放autorelease对象

5.对象加入自动释放池时调用push方法，调用push方法时首先会将一个POOL_BOUNDARY哨兵对象(边界对象)入栈，值为nil作为边界，然后将对象入栈，最后返回
POOL_BOUNDARY哨兵对象的地址；当自动释放池要销毁时调用pop方法，pop方法传入哨兵对象的地址，然后遍历栈从最后入栈的对象开始发送release消息，一直到遇到    
POOL_BOUNDARY哨兵对象才算结束

6.哨兵对象作用：用来标记autorelease对象从哪里开始存储的，主要就是为了方便后续释放对象时查找结束位置
     
7.一个AutoreleasePoolPage的空间被占满时，会新建一个新的AutoreleasePoolPage对象，连接链表，后来的autorelease对象加入到新的page    

8. 自动释放池存储在栈区，page内部地址从低到高依次存储：AutoreleasePoolPage自身的成员、哨兵、自动释放的对象。

9. 哨兵作为对象指针的边界，在释放池里只会有一个,如果autoreleasepool嵌套,那么可能会有多个哨兵对象

![图片](https://github.com/WGFcode/WGFcodeNotes/blob/master/WGFcodeNotes/WGScreenshots/autoreleasepool.png)
![图片](https://github.com/WGFcode/WGFcodeNotes/blob/master/WGFcodeNotes/WGScreenshots/autoreleasepool_page.png)
![图片](https://github.com/WGFcode/WGFcodeNotes/blob/master/WGFcodeNotes/WGScreenshots/autoreleasepool_push.png)
![图片](https://github.com/WGFcode/WGFcodeNotes/blob/master/WGFcodeNotes/WGScreenshots/autoreleasepool_pop.png)


#### 扩展: 
#### 1. 临时变量什么时候释放？
* 正常情况下，一般是超出其作用域就会立即释放

#### 2. RunLoop 和 AutoreleasePool的关系?
*主程序的RunLoop在每次事件循环之前之前，会自动创建一个 autoreleasePool,
并且会在事件循环结束时，执行drain操作，释放其中的对象
* 从程序启动到加载完成，主线程对应的runloop会处于休眠状态，等待用户交互来唤醒runloop
* 用户的每一次交互都会启动一次runloop，用于处理用户的所有点击、触摸事件等
* runloop在监听到交互事件后，就会创建自动释放池，并将所有延迟释放的对象添加到自动释放池中
* 在一次完整的runloop结束之前，会向自动释放池中所有对象发送release消息，然后销毁自动释放池

#### 3.AutoreleasePool的释放时机是什么时候？
* App 启动后，苹果在主线程 RunLoop 里注册了两个 Observer.
* 第一个 Observer 监视的事件是 Entry(即将进入 Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池
* 第二个 Observer 监视了两个事件: BeforeWaiting(准备进入休眠) 时调用 _objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush()
 释放旧的池并创建新池;Exit(即 将退出 Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池

#### 3. thread 和 AutoreleasePool的关系
* 每个线程，包括主线程在内都维护了自己的自动释放池堆栈结构
* 新的自动释放池在被创建时，会被添加到栈顶；当自动释放池销毁时，会从栈中移除
* 对于当前线程来说，会将自动释放的对象放入自动释放池的栈顶；在线程停止时，会自动释放掉与该线程关联的所有自动释放池

#### 每个线程都有与之关联的自动释放池堆栈结构，新的pool在创建时会被压栈到栈顶，pool销毁时，会被出栈，对于当前线程来说，
释放对象会被压栈到栈顶，线程停止时，会自动释放与之关联的自动释放池


#### 4.1 autorelease对象在什么时候释放？深入探讨

#### 程序运行启动时，RunLoop会注册两个Observer来管理和维护AutoreleasePool，
*  一个Observer用来检测进入RunLoop的状态(kCFRunLoopEntry)，此时会调用objc_autoreleasePoolPush方法向当前的AutoreleasePoolPage   
增加一个POOL_BOUNDARY标志创建自动释放池。

* 一个Observer用来检测RunLoop即将进入休眠状态(kCFRunLoopBeforeWaiting)和退出状态(kCFRunLoopExit),    
        检测到即将进入休眠状态时：会调用objc_autoreleasePoolPop() 和objc_autoreleasePoolPush() 方法.
        系统会根据情况从最后加入的对象一直往前清理直到遇到POOL_BOUNDARY标志
        
        在检测退出状态时: 会调用objc_autoreleasePoolPop() 方法释放自动释放池内对象
#### 所以autorelease的释放时机取决于RunLoop的运行状态，在RunLoop即将进入休眠和退出状态时，会释放AutoreleasePool自动释放池中所有的autorelease对象   

#### 4.1 AutoreleasePool自动释放池底层结构

        class AutoreleasePoolPage {
            //AutoreleasePoolPage对象内部有7个成员变量，每个占用8个字节
            magic_t const magic;     //用来校验 AutoreleasePoolPage 的结构是否完整  16字节
            id *next;                //指向了下一个能存放autorelease对象地址的区域，初始化时指向 begin()  8字节
            pthread_t const thread;  //指向当前线程，AutoreleasePool是和线程一一对应的，  8字节
            AutoreleasePoolPage * const parent;  //父节点，指向上一个AutoreleasePoolPage对象，第一个结点的parent值为nil  8字节
            AutoreleasePoolPage *child; //子节点，指向下一个AutoreleasePoolPage对象，最后一个结点的 child 值为 nil  8字节
            uint32_t const depth;       //代表深度，从 0 开始，往后递增 1   4字节
            uint32_t hiwat;             //4字节
        }


        void * objc_autoreleasePoolPush(void) {
            return AutoreleasePoolPage::push();
        }

        //判断是否有pool， 有则通过autoreleaseFast压栈【哨兵】对象 没有则通过autoreleaseNewPage方法创建；
        static inline void *push() {
            id *dest;
            if (DebugPoolAllocation) {  判断是否有pool
                // Each autorelease pool starts on a new pool page.
                //1.没有则新建并把哨兵POOL_BOUNDARY对象入栈
                dest = autoreleaseNewPage(POOL_BOUNDARY);
            } else {
                //2.有pool，则压栈一个POOL_BOUNDARY哨兵对象
                dest = autoreleaseFast(POOL_BOUNDARY);
            }
            return dest;
        }
        
        //1.1.新建page: 获取当前最新的page，若page存在则将对象压栈；若page不存在则创建新的page
        id *autoreleaseNewPage(id obj) {
            AutoreleasePoolPage *page = hotPage();   //获取当前最新的page，即当前可操作的page
            if (page) { //1.1.1如果存在，则压栈对象
                return autoreleaseFullPage(obj, page);
            }else {  //1.1.2如果不存在，则创建新页并将对象入栈
                return autoreleaseNoPage(obj);
            }
        }
        //1.1.1
        id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page) {
            // The hot page is full. 
            // Step to the next non-full page, adding a new page if necessary.
            // Then add the object to that page.
            //do-while遍历循环查找界面是否满了
            do {
                if (page->child) { //若当前page的下一个page(b)不为空，则将当前page的child指向下一个page(b),让page(b)作为当前可操作的page
                    page = page->child;
                }else { //若当前page的下一个page为nil，则需要建建一个page，作为当前可操作的page
                    page = new AutoreleasePoolPage(page);
                }
            } while (page->full());
            setHotPage(page); //设置为当前操作页（即当前可操作的page）
            return page->add(obj);  //将autorelease对象入栈
        }
        
        //1.1.2
        static __attribute__((noinline))
        id *autoreleaseNoPage(id obj) {
            AutoreleasePoolPage *page = new AutoreleasePoolPage(nil);  //新创建一个page，
            setHotPage(page);   //并设置该page为当前可操作的page
            if (pushExtraBoundary) {
                page->add(POOL_BOUNDARY); //然后将哨兵对象POOL_BOUNDARY压入栈中
            }
            return page->add(obj); //先将哨兵对象POOL_BOUNDARY压入栈中，然后将对象添加到page栈中
        }
        
        //2.1
        static inline id *autoreleaseFast(id obj) {
            AutoreleasePoolPage *page = hotPage();  获取当前操作页
            if (page && !page->full()) { //page不为nil且没有装满，则直接将autorelease对象添加到栈中
                return page->add(obj);
            } else if (page) { //若page装满了，则新建一个page,将autorelease对象添加到新创建的page栈中
                return autoreleaseFullPage(obj, page);
            } else { //在没有page的情况下，则新建一个page,将autorelease对象添加到新创建的page栈中
                return autoreleaseNoPage(obj);
            }
        }
        
        // ctxt是哨兵对象的地址
        void objc_autoreleasePoolPop(void *ctxt) {
            AutoreleasePoolPage::pop(ctxt);
        }


#### 4.2 哪些对象会放入到Autoreleasepool中？
1)非alloc/new/copy/mutablecopy 开始的方式初始化时。   

2)id的指针或对象的指针在没有显示指定时   

#### MRC环境下: 通过调用autorelease来延迟内存的释放；

#### ARC环境下: 以 alloc / init / new / copy / mutableCopy 开头的初始化方法，系统会在调用方法的外围 加上内存管理代码 retain / release；
以【其他】开头的初始化方法，系统会在【方法内部】自动加上【autorelease】方法，被注册到 AutoreleasePool 中，等到Pool dealloc时才释放



#### 4.3 工作原理：
1.系统会在 RunLoop 每个运行循环之前(entry进入/beforeWaiting休眠前)执行【autoreleasePoolPush】操作，会创建一个新的page,在当前
page的next位置插入一个【哨兵对象】并返回其内存地址 poolToken,表示新pool的开始位置

2.push【哨兵对象】/【autorelease对象】，都会调用autorelease Fast(id obj)方法来执行插入操作

3.当前Page存在且没满：直接添加至next指向位置

4.当前Page存在且已满：创建一个新的Page，添加至新的page中；

5.当前Page不存在：创建第一个Page，添加至新page中。

6.在runloop结束之前，执行pool的autoreleasePoolPop操作，传入poolToken，对【哨兵对象】之后添加的所有对象执行release

7.每个Page除了Page自身的成员变量外，剩下的空间用 begin 和 end 用标识，存放 autorelease对象 和 哨兵对象 的内存地址

8.当next指针作为游标指针：指向begin时，表示page为空；指向end时，标识page已满

9.当一个page的空间被占满时，会新建一个page对象，连接链表，后来的autoRelease对象在新的page加入

10.一个page第一页第一页最多可以存504个对象，第二页开始最多存 505个
     
   
     
     ⚠️⚠️⚠️MRC环境下查看自动释放池内存结构
        //************打印自动释放池结构************
        extern void _objc_autoreleasePoolPrint(void);

        int main(int argc, const char * argv[]) {
            @autoreleasepool {
                for (int i = 0; i < 5; i++) {
                    NSObject *objc = [[[NSObject alloc]init] autorelease];
                }
                //调用
                _objc_autoreleasePoolPrint();
            }
            return 0;
        }
        打印结果：
            objc[1658]: ##############
            objc[1658]: AUTORELEASE POOLS for thread 0x100094600
            objc[1658]: 6 releases pending.
            objc[1658]: [0x10080d000]  ................  PAGE  (hot) (cold)
            objc[1658]: [0x10080d038]  ################  POOL 0x10080d038  【哨兵】
            objc[1658]: [0x10080d040]       0x101404460  NSObject
            objc[1658]: [0x10080d048]       0x101404260  NSObject
            objc[1658]: [0x10080d050]       0x101404270  NSObject
            objc[1658]: [0x10080d058]       0x101404280  NSObject
            objc[1658]: [0x10080d060]       0x101404290  NSObject
            objc[1658]: ##############
            Program ended with exit code: 0
#### 4.4 AutoreleasePool原理(https://www.jianshu.com/p/7d89310531be)

1. 自动释放池的本质是一个AutoreleasePoolPage结构体对象，是一个栈结构存储的页，每一个AutoreleasePoolPage都是以双向链表的形式连接

2.自动释放池的压栈和出栈主要是通过结构体的构造函数和析构函数调用底层的objc_autoreleasePoolPush和objc_autoreleasePoolPop，
实际上是调用AutoreleasePoolPage的push和pop两个方法

3.每次调用push操作其实就是创建一个新的AutoreleasePoolPage，而AutoreleasePoolPage的具体操作就是插入一个POOL_BOUNDARY，
并返回插入POOL_BOUNDARY的内存地址。而push内部调用autoreleaseFast方法处理，主要有以下三种情况

        1>当page存在，且不满时，调用add方法将对象添加至page的next指针处，并next递增
        2>当page存在，且已满时，调用autoreleaseFullPage初始化一个新的page，然后调用add方法将对象添加至page栈中
        3>当page不存在时，调用autoreleaseNoPage创建一个hotPage，然后调用add方法将对象添加至page栈中
        
4.当执行pop操作时，会传入一个值，这个值就是push操作的返回值，即POOL_BOUNDARY的内存地址token。所以pop内部的实现就是
根据token找到哨兵对象所处的page中，然后使用 objc_release 释放 token之前的对象，并把next 指针到正确位置

#### 4.5 AutoreleasePool能否嵌套使用？

1.可以嵌套使用，其目的是可以控制应用程序的内存峰值，使其不要太高

2.可以嵌套的原因是因为自动释放池是以栈为节点，通过双向链表的形式连接的，且是和线程一一对应的

3.自动释放池的多层嵌套其实就是不停的pushs哨兵对象，在pop时，会先释放里面的，在释放外面的
     
     
#### 4.6 哪些对象可以加入AutoreleasePool？alloc创建可以吗？
 1.使用new、alloc、copy关键字生成的对象和retain了的对象需要手动释放，不会被添加到自动释放池中
 
 2.设置为autorelease的对象不需要手动释放，会直接进入自动释放池
 
 3.所有 autorelease 的对象，在出了作用域之后，会被自动添加到最近创建的自动释放池中

#### 4.7 子线程默认不会开启 Runloop，那出现 Autorelease 对象如何处理？不手动处理会内存泄漏吗
     
     子线程中原本是没有自动释放池autoreleasepool的，但是有两种情况下会自动创建自动释放池autoreleasepool
     1.子线程中获取了Runloop(获取runloop就代表开启了runloop,开启runloop就会创建自动释放池autoreleasepool)
     2.有Autorelease 对象时，系统也会自动创建自动释放池autoreleasepool
     
     
     子线程中如果创建了@autoreleasepool，产生的Autorelease对象就会交给自动释放池去管理；如果没有创建自动释放池，但是产生了Autorelease对象
     就会调用 autoreleaseNoPage 方法，该方法会自动创建一个hotpage(当前正在使用的 AutoreleasePoolPage),并调用 page->add(obj)将对象添加
     到 AutoreleasePoolPage 的栈中,也就是说你不进行手动的内存管理，也不会内存泄漏啦
     
     主线程的runloop是默认创建并开启的，会监听两种事件
     1.即将进入runloop：【此时会创建一个autoreleasepool】
     2.runloop即将休眠:【会释放autoreleasepool并创建一个新的autoreleasepool】;runloop即将退出：【会释放autoreleasepool】
     autoreleasepool在释放时，会对插入到pool中的对象发送release消息
     所以runloop每次迭代结束，autoreleasepool释放，aurelease对象释放
     
     线程和runloop是一一对应的，一个线程对应一个runloop,一个AutoreleasePool对应一个runloop,一个runloop可以包含多个AutoreleasePool
     线程1----runloop1----[AutoreleasePool,AutoreleasePool,AutoreleasePool...]
     线程2----runloop2----[AutoreleasePool,AutoreleasePool,AutoreleasePool...]
     线程3----runloop3----[AutoreleasePool,AutoreleasePool,AutoreleasePool...]
       
     
        
### 5.dealloc的整个过程
 dealloc对象销毁过程
 
 1⃣️._objc_rootDealloc
 
 2⃣️. rootDealloc
    拿到对象的isa指针判断
   [是优化过的isa/不存在弱引用/没有设置过关联对象/没有CPP析构函数/引用计数存储在isa指针内部而不是存储在SideTable结构中]
   若上面5个条件同时都满足，则执行free(this)直接销毁对象即可；若上面条件有一个不满足，则执行步骤3⃣️
   
 3⃣️. object_dispose
 
 4⃣️. objc_destructInstance
     条件1: hasCxxDtor
     如果有析构函数: 则执行object_cxxDestruct方法 该方法其中一个功能是对对象的属性/成员变量进行置nil或者说销毁的
     我们创建一个继承自NSObject的对象，如果写上属性，则编辑器会自动为该对象添加隐式方法.cxx_desctruct(若全是assign类型的属性则不会有该方法)
     cxx_desctruct该方法会在object_cxxDestruct中被调用，用来销毁属性或者说对象的属性值都会被置为nil
 
     条件2: hasAssociatedObjects
     如果有关联对象，则执行_object_remove_assocations(obj)销毁关联对象
     关联对象存储在一个全局的由AssociationsManager管理的哈希表AssociationsHashMap中
     AssociationsManager -----  [disguised_ptr_t: ObjectAssociationMap] (AssociationsHashMap)
                                  对应的objc                 |
                                                    [void * : ObjcAssociation] (ObjectAssociationMap)
                                            对应关联对象时设置的key      ｜
                                                               uintptr_t _policy(对应策略)
                                                                  id _value](对应值)
    关联对象销毁过程:通过对象在全局的哈希表AssociationsHashMap中找到对应的ObjectAssociationMap哈希表，并将其清除，
    然后再将ObjcAssociation中对应的策略和值也清空
 
 4⃣️.1⃣️ 执行clearDeallocating()
    条件1: 如果isa指针没有被优化过，则执行sidetable_clearDeallocating()处理引用计数
    全局的SideTables哈希表   [objc : SideTable]   (SideTables)
    
         struct SideTable {
             spinlock_t slock;         自旋锁：用于上锁/解锁SideTable
             RefcountMap refcnts;      引用计数哈希表（key为对象，value为引用计数）
             weak_table_t weak_table;  弱引用哈希表[key是对象地址: value是entry]
         }
        struct weak_table_t { 弱引用哈希表
            weak_entry_t *weak_entries;         //hash数组(动态数组)
            size_t    num_entries;              //hash数组中元素的个数
            uintptr_t mask;                     //hash数组长度-1，而不是元素的个数，一般是做位运算定义的值
            uintptr_t max_hash_displacement;    //hash冲突的最大次数(最大哈希偏移值)
        };
        entry也可以理解为是哈希表，存储一个对象的所有弱引用, [key:是弱引用地址(id*): value也是弱引用地址]
        对应关系是[referent weak指针的数组]
        struct weak_entry_t {
            DisguisedPtr<objc_object> referent;   被弱引用的对象
            weak_referrer_t *referrers   指向 referent 对象的weak指针数组。动态数组保存弱引用,存储弱引用指针地址的hash数组
        }
    
    拿到对象的地址通过hash算法从全局的SideTables哈希表中获取到SideTable，通过SideTable拿到里面的引用计数哈希表refcnts
    如果有弱引用表，则去处理weak_clear_no_lock(&table.weak_table, (id)this)
    接着遍历引用计数哈希表refcnts,然后清除该对象的引用计数

    条件2: 如果isa指针被优化过，并且[有弱引用或使用了sideTable来存储引用计数]，则执行clearDeallocating_slow()
    如果有弱引用表，则去处理weak_clear_no_lock(&table.weak_table, (id)this);
    如果SideTable存储了引用计数，则从引用计数表中擦除该对象的引用计数。
 
    处理弱引用对象的销毁
    拿到对象的地址通过hash算法从全局的SideTables哈希表中获取到SideTable，通过SideTable拿到里面的弱引用哈希表weak_table
    在弱引用哈希表weak_table中找到对象对应的弱引用数组*referrers，遍历存放弱引用的数组，若弱引用的地址指向该对象，则将该弱引用置为nil
    然后将该weak_entity_t从弱引用表中移除
 5⃣️. free(obj); 最后直接销毁对象


### 6.关联对象的原理
#### 关联对象的原理图

    objc_setAssociatedObject(id  _Nonnull object, const void * _Nonnull key,  
    id  _Nullable value, objc_AssociationPolicy policy)

    -----AssociationsManager-----
      AssociationsHashMap *_map
                            |
                            |
            ---------AssociationsHashMap---------  
            disguised_ptr_t : ObjectAssociationMap -----------> 
            disguised_ptr_t : ObjectAssociationMap        
            ...             : ...  
            对应object                   |
                                        |
                            ---ObjectAssociationMap---
                              void * : ObjcAssociation
                              void * : ObjcAssociation
                              ...    : ...     |
                              对应key           |
                                    ------ObjcAssociation------
                                        uintptr_t _policy   对应策略
                                        id _value           对应Value
#### 总结
1. 关联对象并不是存储在被关联对象本身的内存中(即关联对象不是存储在Person内存结构中的)
2. 关联对象存储在全局的统一由AssociationsManager管理的AssociationsHashMap哈希表中，AssociationsHashMap哈希表是以关联对象为key，
以ObjectAssociationMap哈希表为value来存储的，而ObjectAssociationMap哈希表中存储的是以关联的key作为key,
以ObjcAssociation类为value的哈希表结构，ObjcAssociation类结构中存储的是对应的value和策略的值
3. 设置关联对象为nil,就相当于是移除关联对象
4. 关联对象的移除是在类销毁时，即dealloc时，会去判断是否有关联对象，若有则调用_object_remove_assocations方法进行移除


### 7.git常用命令

     git config --global user.name ""  指定用户名
     git config --global user.email "" 指定邮箱
     git init 初始化版本库(把这个目录变成Git可以管理的仓库)
     git add  工作区修改添加到暂存区
     git commit 将暂存区文件提交到本地仓库
     git push： 将本地仓库内容提交到远程仓库
     
     git log: 查看提交的历史日志(commit历史数据)，以便确定要回退到哪个版本
     git status 查看工作区/暂存区/本地仓库状态
     git checkout -- file  回撤修改(撤销工作区的修改，还没有add)
     git reset HEAD file   回撤修改(add到暂存区，但还没有commit)，回撤的是把这次add的记录给清除掉，即没有这次add了，工作区状态回到了add前的状态，即修改还存在；
     如果修改都不想要了，再次执行 git checkout -- file即可
     git reset --hard HEAD^  回退版本到上一个版本(这里的版本指的是commit)，HEAD^上个版本 HEAD^^前两个版本  HEAD-100前100个版本(add并且commit了，想回退)
     git reset --hard 1094a 回退版本到指定的版本(1094a代表指定版本的commitId)
     git reflog 查看历史命令 以便确定要回到未来的哪个版本。
     （假如有三个commit，当通过git reset从cmmit3回到commit2后，这时HEAD当前版本指向的就是commit2，
     如果想再回到commit3,此时git log看不到cmmit3了，那么就用git reflog查看历史版本，可以找到commit3的commitId进行回退）
     
     git checkout -b dev  :创建分支dev并切换到dev分支
     git checkout dev     :切换到分支dev
     git merge dev        :合并dev分支到当前分支
     git branch -d dev    :删除分支dev
     git branch           :查看有哪些分支
     
     1.本地有项目了，并创建了一个git仓库，但又想在Github上创建仓库并实现和本地项目同步
     git remote add origin git@github.com:XXX/XXX.git  将本地仓库和远程仓库关联
     git push -u origin master  本地库的所有内容推送到远程库
     2. 本地没有项目，远程仓库有项目
     git clone git@github.com:XXX/XXX.git 从远程仓库克隆项目到本机上

### 8 KVO底层原理
     对一个对象的属性添加KVO后，runtime会动态生成一个NSKVONotifity_XXX的子类，并且让对象的isa指针指向这个全新的子类；
     当修改对象的属性时，会调用Foundation下的NSSetXXXValueAndNotify函数，这个函数内部会调用WillChangeValueForKey/父类原来的setter方法/didChangeValueForKey
     didChangeValueForKey方法内部会触发监听器的监听方法observeValueForKeyPath:ofObject:change:context:方法
     生成的这个子类内部实现了4个方法：KVOA方法/监听属性的setter方法/dealloc/class，实现class方法的作用就是对外屏蔽KVO的内部实现细节
#### 如何手动实现KVO？
     手动调用WillChangeValueForKey和didChangeValueForKey
#### KVO可以监听可变数组NSMutableArray吗?
#### 可以监听，实现方式有两种
    方式一:创建一个新类，将可变数组作为该类的属性，然后监听该属性的变化即可，记得必须该对象的mutableArrayValueForKey获取数组，
          然后进行数组的增删改查操作切记不能通过对象的点语法来获取数组，这种方式获取是无法监听到数组变化的
    方式二:直接在操作可变数组的前后添加willChangeValueForKey 和 didChangeValueForKey手动开启KVO，也能实现可变数组的监听



### 9.产生死锁的条件
1.主队列中添加同步任务(串行队列同步任务不会产生死锁)

        NSLog(@"---start");
        dispatch_queue_t queue = dispatch_get_main_queue();
        dispatch_sync(queue, ^{
            NSLog(@"111111");
        });
        NSLog(@"----end");
        
2.使用sync函数往当前串行队列中添加任务,会卡住当前的串行队列,产生死锁

        NSLog(@"---start");
        dispatch_queue_t queue = dispatch_queue_create("queue", DISPATCH_QUEUE_SERIAL); //串行队列
        dispatch_sync(queue, ^{
            NSLog(@"111111");
            //向当前串行队列中添加同步任务
            dispatch_sync(queue, ^{ //dispatch_sync立马在当前线程同步执行任务
                NSLog(@"22222");
            });
            NSLog(@"3333");
        });
        NSLog(@"----end");
        
### 10 Block是如何实现的？Block对应的数据结构是什么样子的？__block的作用是什么？它对应的数据结构又是什么样子的？

 1.Block是封装了函数调用和上下文环境的匿名函数，本质是一个OC对象，
 2。底层是一个结构体，包含了两个成员变量impl，desc,impl存放isa指针和block内函数的地址，desc描述了block结构体占用内存的大小，结构体里面还包含捕获的变量信息，
 如果捕获的是对象类型的变量，则desc成员结构体中除了包含block占用内存大小的信息，还会多出来两个方法copy方法和dispose方法，用来决定block对捕获的对象是强引用还是弱引用，说白了就是用来管理捕获对象的内存的
 3. block主要分为三种类型，global Block/stack Block/malloc Block,没有访问auto变量的都是global Block,即便block访问了static静态变量也是global Block；访问了auto变量的block是stack Block；对stack Block进行copy操作的就变成了malloc Block；
 4. block对auto自动变量和static局部变量可以捕获，对全局变量和全局静态变量是不会捕获的，对auto是值捕获，对static局部变量是指针捕获
 5. 无论MRC还是ARC环境下，对于栈stack Block，block对捕获的对象类型的auto变量，都不会产生强引用；如果是ARC环境下，如果捕获的对象外部是强引用，则block对捕获的对象是强引用；如果外部是弱引用，则block结构体对捕获的变量是弱引用
 6.ARC环境下，iOS会对以下情况，对栈block进行copy操作，使其成为堆Block，为什么要进行copy操作，原因就是栈block什么时候销毁我们是控制不了的，而堆Block什么时候销毁我们是知道的，栈Block访问外部变量容易导致不可预知的错误；【Block被强指针引用】【GCD中的Block】【cocoaAPI中出现的useingBlock】
 7.Block访问外部变量，只能访问不能修改，如果想要修改，则需要在外部变量前面添加__block标识，被__block标识的变量，编译器会将__block修饰的变量包装成一个对象(底层就是个结构体)，block底层内部结构会有个指针指向这个包装的结构体，然后通过指针修改结构体中的成员变量
 8. 解决循环引用方式：
 1. __weak修饰(弱引用): 指向的对象销毁时,会自动让指针置为nil
 2. __unsafe_unretained修饰(弱引用): 指向的对象销毁时,指针存储的地址值不变
 3. __block(必须调用block并在block内对访问的变量在不需要时置为nil)
 
 
 
 
#### 11. GCD中的Block是在堆上还是栈上？
#### 在堆上
    
    
#### 12. NSNotificaiton是同步还是异步的，如果发通知时在子线程，接收在哪个线程？
#### NSNotificaiton是同步执行的，如果发送的通知在子线程，则接收的通知方法也是在发送通知的那个子线程中接收的；如果多次调用postNotificationName发送通知，则也会多次收到通知消息


#### 13. NSCoding协议是干什么用的？
     一种编码协议，归档时和解档时需要依赖该协议定义的编码和解码方法。Foundation和Cocoa Touch中的大部分类都遵循了这个协议，一般被NSKeyedArchiver做自定义对象持久化时使用。
     数据持久化对于自定义类型的数据是无法存储的，必须通过序列化(编解码)才能存储

#### 14. NSOperation有哪些特性比着GCD有哪些优点，它有哪些API？

     NSOperation/NSOperationQueue 是对GCD的高度封装，使用步骤 1.创建操作 2.创建操作队列 3.将操作添加到操作队列中
     NSOperation提供了两个子类来创建操作：NSBlockOperation/NSInvocationOperation，
     也可以自定义继承自NSOperation的类来创建操作，需要重写main方法或start方法
    【1】在不使用NSOperationQueue操作队列的情况下，
     1.单纯使用NSBlockOperation创建操作(没有调用addExecutionBlock)，然后start,那么任务执行就是在当前线程中同步执行的
     2.如果通过addExecutionBlock方法继续添加添加操作，那么系统就会新开线程来执行添加的操作任务(具体开多少个线程由系统决定)，操作之间是异步执行的，但是第一个创建的NSBlockOperation操作仍然是当前线程中执行
     3.在没有操作队列NSOperationQueue参与下，不能添加操作之间的依赖（会crash）
    【2】操作NSOperation和操作队列NSOperationQueue结合情况下
     1.将操作添加到操作队列后，(操作)任务之间会异步执行
     2.操作之间可以设置依赖关系：谁依赖谁(谁在谁的后面执行),必须是先添加依赖关系，然后再将操作添加到队列中
     3.maxConcurrentOperationCount=1.则是串行队列
    【3】NSOperationQueue操作队列分为2种，主队列和自定义队列，主队列在主线程中执行任务，自定义队列在系统分配的子线程中执行
     
     特性：
          1.可以设置线程最大并发数量
          2.操作(任务)之间可以添加依赖，控制操作(任务)执行顺序；可以单个取消、暂停操作(任务)
          3.只有主队列和自定义队列，没有像GCD中的(串行队列/并发队列/主队列/全局并发队列)
          4.操作队列可以取消队列中的所有操作(任务)
     区别：1.NSOperation/NSOperationQueue是面向对象的，是对GCD的封装，所以效率上GCD更胜一筹；GCD是一套C语言的API
          2.NSOperation可以通过KVO监听操作(任务)的状态(取消/暂停/执行/完成)；GCD无法通过KVO进行判断
          3.NSOperation可以设置操作(任务)自身的优先级，但是优先级高的不一定先执行；GCD只能设置队列的优先级，无法在执行的block设置优先级；
     

#### 15.ARC方案的原理是什么？它是在什么时候做的隐式添加release操作？(https://www.jianshu.com/p/a40fafc6f824) 
     ARC自动引用计数，通过LLVM编辑器自动管理对应的引用计数，ARC开启时，无需手动键入retain/release,它是在编译阶段添加retain或者release代码的
     
     1.arm64架构之后，iOS的引用计数存储在对象优化过的isa指针中，isa指针利用位域技术来存储更多信息，isa指针占8个字节，共64位，
     用最后的19位来存储引用计数(引用计数-1),如果引用计数不够存储(最多存储255个)，会存储在全局的哈希数组SideTables中
     2.SideTables是一个64个元素长度的哈希数组，里面存储的元素类型都是SideTable，SideTables的hash键值就是一个对象obj的address，
     所以一个对象对应一个SideTable，一个SideTable可以对应多个对象
     3.SideTable底层是个结构体，里面存储了三个成员变量：自旋锁/弱引用表/引用计数表
     4.通过对象的地址在全局的哈希数组中找到SideTable，然后在SideTable中获取到引用计数表，然后通过对象的地址经过哈希函数找到
     引用计数表中的桶(其实就是桶数组中的元素，元素类型类似swift中的元素(对象,引用计数)),对引用计数进行加减
     5.引用计数表其实就是个数组，通过对象的地址经过哈希函数找到对应的引用计数值进行+1或-1操作，需要注意这个哈希表(数组)同样会存储哈希冲突的问题
     刚开始假如分配了10个元素的空间（buckets），有ABC三个对象，拿对象的地址通过哈希函数后找到数组的下标，如果下标对应的是空桶(bucket)则存储对象，假如是下标为0的桶存储了A对象，此时对象B如果哈希后的下标也是0，则发现不是空桶，则需要进行下一步哈希算法来查找合适的位置，假如是4，则下标4存储B对象的引用计数；依次类推
     假如对象A在下标为3的桶位置，如果对象A销毁，会将该位置标记为墓碑，如果有新的对象B进来，通过哈希算法获取的下标也是下标3(墓碑位置)，那么就继续进行哈希算法
     进行查找，如果找到了空桶，则证明对象B在引用计数表中不存在，此时就可以将存放墓碑的下标(下标3)的位置拿来存储对象B的引用计数了，这样就可以利用释放掉的空间了

#### 16  循环引用有哪些场景，如何避免？
     1.CADisplayLink/NSTimer会对target产生强引用，导致无法释放，可以通过NSProxy代理，或者NSTimer通过Block方式创建，
     若Block内部访问了target,则通过__weak标识
     2.使用Block时，某个类将block作为属性，并且block内部又访问了该类本身，就容易导致循环引用，解决方法有以下几种
        1),将访问的类本身用__weak标识，这样Block内部对本类对象就是弱引用;对象销毁时会自动置为nil
        2),将访问的类本身用__unsafe_unretained标识，这样Block内部对本类对象就是弱引用;对象销毁时，不会自动置为nil
        3)将访问的类本身用__block标识，然后在block内部记得设置为nil,然后调用Block即可
     3.委托代理(delegate),声明delegate时请用assign(MRC)或者weak(ARC)
     4.NSNotificationCenter，注册通知和移除通知要成对出现，否则所在的VC无法释放，导致循环引用；
       ⚠️这里需要区分情况
       1)用addObserver:selector:name:object:注册通知，在iOS9之后，我们可以不用手动移除通知，系统会帮我们做
       2)用addObserverForName:object:queue:usingBlock:(void (^)(NSNotification *note))block注册通知，方法会返回个Observer，用于移除通知，
     如果block内访问了当前页面信息(self),则会产生循环引用，导致当前VC无法释放，所以如果需要访问当前页面信息(self),则需要标记为__weak即可；
     同时同时⚠️在VC销毁dealloc中必须移除这个通知，因为这个注册通知方式，NSNotificationCenter也会对Observer引用着，Observer也是不会释放的
     验证流程就是第一个页面发送通知，第二页面注册通知，并有发送通知的触点，然后从第二个页面返回后，再次进入第二个页面，会收到通知，说明Observer并没有释放
     解决问题方式就是：在VC销毁时，移除到这个通知
     
             @property(nonatomic, strong) NSObject *observerName;
             __weak typeof(self) weakSelf = self;
             //返回一个Observer，系统持有
             self.observerName = [[NSNotificationCenter defaultCenter] addObserverForName:@"111" object:nil queue:NSOperationQueue.mainQueue usingBlock:^(NSNotification * _Nonnull note) {
                 NSLog(@"1111-----%@----%p",note.userInfo,weakSelf);
             }];
             -(void)dealloc {
                 [[NSNotificationCenter defaultCenter] removeObserver:self.observerName];
                 NSLog(@"---%s",__func__);
             }
         
     4.1
     如果postNotificationName是在主线程中发送的，则接受通知也是在主线程；若postNotificationName发送通知是在子线程中，则接收通知也是在该子线程中；
     注册通知addObserver如果在子线程中，则发送通知postNotificationName必须也在这个子线程中才能接收到通知消息，否则接收不到通知消息
     注册通知addObserver在主线程中，则发送通知postNotificationName可以在主线程也可以在子线程中，只是接收通知在对应的主线程或子线程中接收即可

#### 17 为什么当我们在使用block时外面是weak 声明一个weakSelf，还要在block内部使用strong再持有一下？
     block外面声明的__weak,是为了实现Block对对象的弱引用，block内使用__strong是为了保证block内使用过程中不会发生释放
     
    1.block外部声明__weak,block就会对这个对象是弱引用，避免循环引用
    int main(int argc, const char * argv[]) {
        @autoreleasepool {
            
            WGPerson *person = [[WGPerson alloc]init];
            person.age = 18;
            __weak WGPerson *weakPerson = person;
            person.personBlock = ^{
                NSLog(@"person age is %d",weakPerson.age);
            };
            person.personBlock();
        }
        return 0;
    }
    
    2.大括号结束后，person对象已经销毁了，而过2秒后，才开始执行打印信息“person age is %d”，此时对象销毁了，所以不会再有信息打印了
    
        - (void)viewDidLoad { 
            Person *person = [[Person alloc]init];
            person.age = 18;
            __weak Person *weakPerson = person;
            person.personBlock = ^{
                NSLog(@"1111");
                dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0*NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
                    NSLog(@"person age is %d",weakPerson.age);
                });
                NSLog(@"2222");
            };
            person.personBlock();
        }

        打印结果: 1111
                2222
                -[Person dealloc]

    3.解决上面问题的方式就是在block内使用__strong，来保证block内部在使用过程中，person对象不会销毁，Person对象中有block，对Block是强引用，Block内部对Person对象是弱引用，Block内部又有个block，这个block对弱引用对象是强引用，这样就可以避免person对象在block内使用过程中被销毁了
    
        -(void)viewDidLoad {
            [super viewDidLoad];
            Person *person = [[Person alloc]init];
            person.age = 18;
            __weak Person *weakPerson = person;
            person.personBlock = ^{
                __strong Person *strongPerson = weakPerson;
                NSLog(@"1111");
                dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0*NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
                    NSLog(@"person age is %d",strongPerson.age);
                });
                NSLog(@"2222");
            };
            person.personBlock();
        }
        打印结果: 1111
                2222
                person age is 18
                -[WGPerson dealloc]





#### 18.类方法是存储到什么地方的？类属性呢？
         类class属性，编译器不会生成类属性的setter/getter方法;⚠️必须我们自己实现，否则在使用的时候会报错
         @property(nonatomic, strong, class) NSString *name;
         
         对象属性，默认编译器会生成属性的setter/getter方法声明、实现、带下划线(_parentName)的成员变量
         @property(nonatomic, strong) NSString *parentName;

         类方法、类属性都存储在元类对象中

### 19.Objective-C运行时（runtime）机制了解吗？简单的说说对象调用方法的过程。

     OC是一个动态性很强的语言，允许很多操作推迟到运行时再进行，OC的动态性就是依靠Runtime支撑和实现的，Runtime是一套C语言的API，封装了很多动态性相关的函数
     对象调用方法的其实都是向该对象发送消息底层都是调用了objc_msgSend方法，调用方法的过程大致可以分为三个阶段
     1.消息发送阶段: 通过对象的isa指针找到类对象，然后在类对象中找到方法缓存列表cache，进行查找，cache方法缓存列表其实是一个哈希表，里面有个bucket，其实就是数组，存储这方法名SEL和方法实现的地址IMP，首先通过方法名&哈希表的长度(哈希函数)获取到bucket下标,找到对应的元素，然后对比方法名是否相同，如果相同，则返回对应的IMP方法实现进行调用；如果在方法缓存中没有找到，则到methodArr方法列表（二维数组）中查找，如果方法列表已经排好序了，则进行二分查找，如果是乱序的，则通过遍历查找，如果找到了，直接调用，然后将该方法存放到方法缓存列表中，如果没有找到，则通过类对象的superClass找到父类对象，然后在父类对象的方法缓存列表中继续查找，一次类推，如果一直到superClass为nil，都没有找到，则会进入动态方法解析阶段
     2.动态方法解析阶段:
     首先判断是否已经动态解析过，如果动态解析过了，则直接进入消息转发阶段，如果没有动态解析过，则判断对象是否实现了下面类方法，resolveInstanceMethod/resolveClassMethod，在该类方法中，可以通过RunTimeAPI动态添加方法到类对象的方法列表中，如果动态添加了方法，则会重新进入消息发送阶段；如果没有动态添加方法，则一样会标记为已经动态添加过了，然后重新走消息发送结算
     3.消息转发阶段]:
     首先看对象是否实现了forwardingTargetForSelector方法，在这个方法里面返回一个可以处理消息的对象；如果返回的有对象，并且可以处理，那么就调用方法处理即可；如果该方法没有返回一个有效的处理方法的对象，则会继续判断methodSignatureForSelector返回一个有效的方法签名；如果实现了，则再调用forwardInvocation:方法进行处理，如果都没有实现，则会报报一个经典的错误：unrecognize sender to selector

### 20.ios内存分区
         按照从低到高主要分为：
         [代码段]:程序编译后生成的代码都存放在这个位置
         [数据段]:
             字符串常量：存储字面值 俗称为常量区
             已初始化的全局变量，静态变量
             未初始化的全局变量和静态变量
         [堆区]:动态分配的内存区域，分配的内存地址越来越越大，需要我们程序员自己管理的
         [栈区]:函数的调用开销，局部变量等，内存分配和销毁又系统管理，不需要我们自己管理，内存分配的地址是越来越小


### 21.开发中遇到的crash

     1. 找不到方法的实现unrecognized selector sent to instance；
        1)解决方法就是给NSObject添加分类，hook消息转发阶段的系统方法methodSignatureForSelector和forwardInvocation,然后进行方法交换，
        判断不能处理方法时，动态添加一个方法实现
        2)可变属性(NSMutableArray)不能用copy修饰
     2. KVC造成
        (1)给不存在的key(属性),设置值value
        (2)key为nil(value为nil不会crash)
        解决方案: 利用iOS的反射机制来规避，key尽量采用NSStringFromSelector(@selector())，编译器会检查合法性，如果方法不存在或未实现会报警告
        重写类的setValue:forUndefinedKey和valueForUndefinedKey
     3.坏内存访问EXC_BAD_ACCESS：ARC之后，很少出现了，一般出现在
     [悬垂指针/野指针]：【对象没有被初始化】【访问的对象已经被释放掉】【访问没有实现的blcok】
     野指针：【unsafe_unretained修饰的对象释放后，不会自动置nil，变成野指针】【应该使用strong/weak修饰的对象，却错误的使用assign修饰，释放后不会自动置nil】【给类添加添加关联变量的时候，应该使用OBJC_ASSOCIATION_RETAIN_NONATOMIC修饰，却错误使用OBJC_ASSOCIATION_ASSIGN】
     4.KVO造成
     【观察者是局部变量】【重复移除观察者会导致crash-because it is not registered as an observer】【没有实现observeValueForKeyPath】
     5.数组越界
     6.NSMutableDictionary中setObject:forKey中object和key都不能为nil,可以使用KVC中的setValue:forKey:方法，
     这里value可以为nil,Key不能为nil
     7.多线程访问，【死锁】【子线程中更新UI】【多个线程同时释放一个对象】
     8.后台返回NSNull导致的崩溃，多见于Java做后台服务器开发语言，
     当我们给一个NSNull对象发送消息的话，可能会崩溃（null是有内存的），而发送给nil的话，是不会崩溃的
     9.assign修饰了对象类型，其实assign等价于_unsafe_unretained，不会对该对象的引用计数进行操作，
     在对象销毁时，不会自动置为nil，会导致野指针问题；下面的代码会导致crash
     
            @property(nonatomic, assign) NSString *name;
            self.name = [NSString stringWithFormat:@"%@",@"asdfasdfasdfasdf"];
            dispatch_async(dispatch_get_main_queue(), ^{
                NSLog(@"%@",self.name);
            });

    10.EXC_BAD_INSTRUCTION【死锁】
    
            //1. 主队列中添加同步任务---死锁
            NSLog(@"111");
            dispatch_sync(dispatch_get_main_queue(), ^{
                NSLog(@"222");
            });
            NSLog(@"333");
            
            //2. 串行队列中添加同步任务，会按照顺序执行，因为外面信息是在主队列中执行，而内部任务是在串行队列中执行的，不会造成死锁
            NSLog(@"111");
            //同步队列
            dispatch_queue_t queue = dispatch_queue_create("serialQueue", DISPATCH_QUEUE_SERIAL);
            dispatch_sync(queue, ^{
                NSLog(@"222");
            });
            NSLog(@"333");

            //3. 向当前的串行队列中，添加同步任务，会导致死锁(这里当前的串行队列中是有任务的)--死锁
            NSLog(@"111");
            //同步队列
            dispatch_queue_t queue = dispatch_queue_create("serialQueue", DISPATCH_QUEUE_SERIAL);
            dispatch_sync(queue, ^{
                NSLog(@"222");
                dispatch_sync(queue, ^{
                    NSLog(@"-------");
                });
                NSLog(@"222----end");
            });
            NSLog(@"333");

### 22. 内存泄漏/内存溢出/野指针/空指针问题
     1⃣️【内存泄漏】:
     是指申请的内存空间使用完毕之后未回收；动态分配内存的对象，在使用完后没有被系统回收内存，导致对象一直占据着内存，属于内存管理出错；
     发生场景:(1)对象间的循环引用 (2)block的循环引用 (3)delegate 的循环引用(要用weak修饰delegate)
     (4)CADisplayLink/NSTimer会对target产生强引用 (5)通知的循环引用 iOS9之前注册通知要记得移除通知
     (6)大次数循环导致的内存爆增（循环加载引起内存峰值） (7)非OC对象(CoreFoundation框架下的CI/CG/CF等开头的类对象，需要我们手动释放)内存处理
     (8)使用地图
     排查方法
     1.通过Xcode的Analyze静态分析（Static Analysis - Analysis Policy -> Analyze During ‘Build’ -> YES 每次build都静态分析）
     2.通过Xcode -> Open Developer Tool -> Instruments -> Leaks 动态分析

     
    2⃣️【野指针】:
     野指针[悬挂指针]，出现的原因是因为【指针没有赋值】【指针指向的对象已经释放了, 比如指向僵尸对象】
     野指针可能会指向一块垃圾内存,给野指针发送消息会导致程序崩溃
     排查方法:
     一般出现EXC_BAD_ACCESS错误的原因都是悬挂指针导致的，但具体哪个指针不明确，想获取更多的crash信息，需要启动NSZombieEnabled
     Edit Scheme -> Run -> Diagnostics -> Memory Management -> Zombie Objects
     
    3⃣️【僵尸对象】:
     已经被销毁的对象(不能再使用的对象),内存已经被回收的对象,引用计数为0对象被释放后就变成僵尸对象了
     
    【指针指向的对象已经释放/回收，这个指针就叫野指针，这个被释放的对象就是僵尸对象】
     
    4⃣️【空指针】:是一个没有指向任何内存的指针,空指针是有效指针,值为nil,NULL,Nil,0等,给空指针发送消息不会报错,不会响应消息
     NSString *str; NSString *str2 = nil;都表示空指针
     
    5⃣️【NSNull】:继承自NSObject,一个单例对象，用于表示不允许空值的集合对象中的空值,即一个集合对象中的空值对象
     1.集合对象中不能添加nil,但是可以添加NSNull对象
     NSMutableArray *arr = [NSMutableArray new];
     [arr addObject:nil];              arr.count = 0
     [arr addObject:[NSNull null]];    arr.count = 1
     
     2.对nil发消息不会crash,因为objc_msgSend返回的是0什么也不会做
       对NSNull对象发送消息，会crash,因为通过NSNull对象的isa指针找到NSNull类对象，类对象只有null方法，没有其他方法，
       所以会报找不到方法的错误：unrecognized selector sent to instance
     
     
    6⃣️【内存溢出】:
     当程序在申请内存时，没有足够的内存空间供其使用,比如申请了一个int,但给它存了long才能存下的数，那就是内存溢出
     
### 23.iOS渲染流程和原理
### 22. 离线化是如何实现的，离线资源更新逻辑是怎么确定的？数据表现如何？
### 23. 启动优化怎么做的，分别做了什么 ？数据表现如何？二进制重排、缺页中断
### 24. 包体积优化都做了哪些工作，如何实现的，对业务有入侵吗？
### 25. 编译优化都做了哪些事情？工具链优化了什么？为什么构建编译速度能提升？cocoapods 插件优化了哪些？
### 26. alloc/init/new区别
    alloc主要三个功能： 底层调用也是objc_rootAlloc->callAlloc...等方法
        1.先计算出需要的内存空间大小
        2.向系统申请开辟内存，返回地址指针
        3.关联到相应的类
        
    init底层调用的就是objc_rootInit，把自己传进去并且返回了自己；其实这里就是一种抽象工厂设计模式的体验，没有任何实现，
    但是如果你继承NSObject的话，可以重写init传入一些值作一些初始化操作
    _objc_rootInit(id obj) {
        return obj;
    }
    
    new: 底层其实也是调用了alloc底层的callAlloc方法，所以和alloc方法一样的，[Class new] 完全等价于 [[Class alloc] init]
    ⚠️注意: 使用new时，因为它只会走系统的 callAlloc init 方法，所以如果你重写了init 方法，它是不走的;
    简单说就是一个类中如何重写了init方法，比如initWithXXX(并非系统的init),那么new方法创建对象时是不会调用这个重写的初始化方法的；
    如果一个类重写的init方法就是-(instancetype)init，那么new是会调用这个方法的
        + (id)new {
            return [callAlloc(self, false/*checkNil*/) init];
        }

### 27.iOS专业术语：
    APM(Application Performance Management):应用性能管理
    APM是一套监控和管理应用程序性能的工具和技术，旨在确保应用程序运行平稳、响应迅速并且提供良好的用户体验
        1.性能监控： 实时监控应用的各种性能指标，如启动时间、响应时间、内存使用、CPU 使用等。
        2.崩溃报告： 捕获应用崩溃信息，并提供详细的崩溃日志和堆栈追踪，帮助开发者快速定位和修复问题。
        3.网络监控： 监控网络请求的情况，包括请求时间、数据量、成功率和错误率等。
        4.用户行为分析： 跟踪用户在应用中的行为路径，帮助分析用户流失和交互问题。
        5.资源使用监控： 监控应用的内存、CPU 和电池使用情况，确保资源利用率高效且不影响用户体验
    常用的 APM 工具
        Firebase Performance Monitoring：
        New Relic Mobile：
        Instabug：
        AppDynamics：
        Dynatrace：
    网易云音乐APM自研的监控覆盖了 OOM、ANR、Jank 卡顿、CPU 发热、UI 假死等场景；崩溃监控中崩溃堆栈是其最为核心的信息；因此堆栈是 APM 项目中最基础也是最重要的模块（https://zhuanlan.zhihu.com/p/652081317）
    性能异常的堆栈和崩溃型堆栈也存在很大区别
        崩溃堆栈是在问题发生时抓取全线程堆栈
        性能异常的监控很多时候不能准确抓取到当时的调用栈，需要利用统计学手段去猜问题场景最有可能的堆栈
    卡顿检测：通过一个单独的线程不断轮询检测 Main Runloop 的耗时情况，超时则认为发生卡顿，我们定义超时时间为3帧即 50ms
        
    OOM(Out of Memory)内存不足:是指应用程序使用了过多的内存，超过了设备的内存限制，导致操作系统强制关闭应用程序以释放资源，
    它会导致用户体验极差，应用突然崩溃
    常见的导致 OOM 的原因：
        1.内存泄漏(Memory Leak)导致内存无法被正确释放: 如循环引用
        2.大文件处理:加载或处理过大的文件（如图像、视频）会消耗大量内存。如果未对这些文件进行适当的内存管理，会导致 OOM
        3.数据缓存: 应用中缓存了大量的数据，例如图片缓存，未能及时清理不再需要的数据
        4.过多的后台任务： 同时运行过多的后台任务或线程，也会占用大量的内存资源
    如何避免 OOM:
        1.优化内存使用： 尽量减少不必要的内存分配，及时释放不再使用的对象
        2.使用自动释放池： 在处理大量临时对象时，使用 autoreleasepool 块来及时释放内存
        3.检测和修复内存泄漏： 使用 Xcode 的内存调试工具（如 Instruments 中的 Leaks 和 Allocations）检测和修复内存泄漏
        4.优化图片处理： 对于大图像，使用缩略图或分片加载，避免一次性加载过大的图像
        5.合理管理缓存： 定期清理缓存数据，避免缓存过多导致内存不足。
        6.后台任务优化： 控制后台任务的数量和内存使用，避免过多的并发任务
    
    I/O(input and output)操作:Linux中对数据流的操作叫IO，
    I/O分为以下三种，因为内存很快，所以一般说的I/O指的就是  磁盘I/O 和 网络I/O 
        磁盘I/O： 
        应用程序与存储设备（如硬盘、SSD等）之间的数据交换。这种操作通常涉及到文件的读写，如保存用户数据、读取应用设置等。磁盘I/O操作相对较慢，因此常常需要优化以提高效率‌
        网络I/O:
        应用程序与网络设备（如服务器、其他设备等）之间的数据交换。这包括数据的上传和下载，如用户上传照片到云端、下载应用更新等。网络I/O操作受到网络速度和稳定性的影响，因此也需要进行相应的优化‌
        内存I/O
        指应用程序与系统内存之间的数据交换。这通常涉及到缓存数据的读写操作，如渲染界面、处理计算任务等。由于内存访问速度非常快，通常不会成为性能瓶颈，但大规模数据处理时仍需注意‌
    
    ANR:是指UI线程无响应的情况，此时UI线程由于某种原因被阻塞，不执行任何新提交的主线程队列任务，
    基于这个特点，监控原理则是通过定时向 main_queue中发送任务修改 ack值，每次轮训检测 ack的值是否发生修改来判断主线程是否发生了ANR
    常见的ANR场景有
        死锁（CPU占用低）
        死循环（CPU占用高）
        大任务等
        
    内存异常: 主要包含OOM、大内存对象和巨量小内存对象三类异常
        OOM: 属于崩溃型异常
        大内存对象: 运行时异常内存分配
        巨量小内存对象: 运行时异常内存分配
    

    
## 传值方式
#### Block: 一对一；注重结果信息的传递，比如成功还是失败，并不需要知道进行了多少或者其他额外的信息；更加简洁
#### Delegate: 一对一；注重过程信息的传递，比如发起网络，可能需要知道请求开始了吗？是否接收到数据？是否接收完数据等；实现繁琐
需要定义协议方法/代理对象实现协议/建立代理关系才能通信，非常严格的语法
#### Notification: 一对多；多个控制器都需要知道一个事件时，和Block比起来也有点繁琐，需要创建通知设置观察者/发送通知/接收通知/移除通知；
一般用于相隔页面跳转之间的数据传递


    

### 内存管理
### 1.面试题
#### 1.1. 使用CADisplayLink、NSTimer有什么注意点
#### CADisplayLink、NSTimer会对targe产生强引用，如果target又对它们产生强引用，那么就会发生循环引用
    @interface WGMainObjcVC()
    @property(nonatomic, strong) CADisplayLink *link;
    @property(nonatomic, strong) NSTimer *timer;
    @end

    @implementation WGMainObjcVC
    - (void)viewDidLoad {
        [super viewDidLoad];
        
        //CADisplayLink其实也是个定时器，区别就是不需要设置时间，保证调用频率和屏幕的刷帧频率一致，60FPS
        //self.link = [CADisplayLink displayLinkWithTarget:self selector:@selector(linkTest)];
        //[self.link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode];
        
        //开启定时器方式一
        //self.timer=[NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(test) userInfo:nil repeats:YES];
        //[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSDefaultRunLoopMode];
        //开启定时器方式二
        self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(test)  
        userInfo:nil repeats:YES];
    }

    -(void)test {
        NSLog(@"%s",__func__);
    }

    -(void)dealloc {
        //[self.link invalidate];
        [self.timer invalidate];
    }
    
    打印结果： -[WGMainObjcVC test]
             -[WGMainObjcVC test]
             ......
#### 即使页面销毁了，定时器中的任务仍然会调用，因为self强引用了CADisplayLink/NSTimer,而CADisplayLink/NSTimer又强引用了target:self,导致了循环引用。
#### 解决方案一： 利用Block的方式创建定时器，然后通过__weak弱引用来解决循环引用问题
    //这种创建定时器的方式利用__weak不能解决循环引用问题
    //因为无论target:的参数传递self还是weakSelf，都是传递个指针给target,
    //而NStimer/CADisplayLink内部都会对传递进来的target参数进行强引用的，__weak是用来解决Block循环引用的。
    __weak typeof(self) weakSelf = self;
    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:weakSelf selector:@selector(test)  
    userInfo:nil repeats:YES];
    
    //利用Block方式创建定时器，利用__weak是可以解决循环引用问题的
    __weak typeof(self) weakSelf = self;
    //NSTimer强引用者Block，而Block对self是弱引用的，所以可以解决循环引用问题
    self.timer=[NSTimer scheduledTimerWithTimeInterval:1.0 repeats:YES block:^(NSTimer * _Nonnull timer){
        [weakSelf test];
    }];
#### 解决方案二：新建一个对象(让对象来弱引用self)，作为NSTimer/CADisplayLink的target参数，那么这个对象就要实现定时器的任务，为了让self实现定时器任务，在这个对象内部进行消息转发，将消息转发给self来解决循环引用问题
    //WGTargetProxy.h文件
    @interface WGTargetProxy : NSObject
    @property(nonatomic, weak) id target;
    +(instancetype)proxyWithTarget:(id)target;
    @end
    
    //WGTargetProxy.m文件
    @implementation WGTargetProxy
    +(instancetype)proxyWithTarget:(id)target {
        WGTargetProxy *proxy = [[WGTargetProxy alloc]init];
        proxy.target = target;
        return proxy;
    }
    //转发消息给target
    - (id)forwardingTargetForSelector:(SEL)aSelector {
        return self.target;
    }
    @end
    
    //利用添加的对象来作为target,target对self进行弱引用，然后在添加的对象中，对方法进行消息转发，转发给self
    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:[WGTargetProxy proxyWithTarget:self]  
    selector:@selector(test) userInfo:nil repeats:YES];
    
#### 解决方案三: 创建一个继承自NSProxy的类，然后直接进行消息转发.NSProxy类似于NSObject，是基类，主要用来做消息转发。效率高，因为它不是继承自NSObject的，所以当调用一个不存在的方法时，避免了去父类中查找的过程，而是直接进行消息转发
    //WGTargetProxy.h文件
    @interface WGTargetProxy : NSProxy
    @property(nonatomic, weak) id target;
    +(instancetype)proxyWithTarget:(id)target;
    @end

    //WGTargetProxy.m文件
    @implementation WGTargetProxy
    +(instancetype)proxyWithTarget:(id)target {
        //继承自NSProxy类的对象没有init方法
        WGTargetProxy *proxy = [WGTargetProxy alloc];
        proxy.target = target;
        return proxy;
    }
    - (void)forwardInvocation:(NSInvocation *)invocation {
        [invocation invokeWithTarget:self.target];
    }
    -(NSMethodSignature *)methodSignatureForSelector:(SEL)sel {
         return [self.target methodSignatureForSelector:sel];
    }
    @end

    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:[WGTargetProxy proxyWithTarget:self]  
    selector:@selector(test) userInfo:nil repeats:YES];
#### ⚠️知识点：如果是继承自NSProxy的对象，如果调用这个对象的isKindOfClass,那么就是会进入消息转发，会让这个对象的target去执行。例如：
    //继承自NSProxy
    WGTargetProxy *proxy1 = [WGTargetProxy1 proxyWithTarget:self];
    //继承自NSObject
    WGTargetProxy *proxy2 = [WGTargetProxy2 proxyWithTarget:self];
    NSLog(@"继承自NSProxy---%d\n 继承自NSObject---%d\n",  
    [proxy1 isKindOfClass:[self class]],[proxy2 isKindOfClass:[self class]]);

    打印结果：继承自NSProxy---1
            继承自NSObject---0
    
#### 1.2 NSTimer为什么不准时？有什么方法来保证定时器的准时哪？
#### 因为NSTimer是依赖于RunLoop的，如果RunLoop的任务过重，即NSTimer事件需要等待RunLoop处理其他的事情，处理完了才会来处理NSTimer事件，所以才会导致NSTimer不准时。想保证定时器任务的准时，可以使用GCD定时器，因为GCD定时器是不依赖Runloop的，它是直接和系统内核挂钩的
#### 1.3 GCD定时器
    
    @interface WGMainObjcVC()
    //必须强引用这个定时器，否则定时器是不会工作的
    @property(nonatomic, strong) dispatch_source_t timer;
    @end

    @implementation WGMainObjcVC
    - (void)viewDidLoad {
        [super viewDidLoad];
        NSLog(@"-------begin-------");
        //创建队列:主队列就是在主线程下，非主队列都是在子线程中
        dispatch_queue_t queue = dispatch_get_main_queue();
        //1. 创建定时器
            参数1：源的类型 
            参数2/参数3: 直接传递0即可 
            参数4:设置定时器运行的队列
        self.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);
        //2. 设置时间
            参数1: 设置哪个定时器  
            参数2: 开始时间，必须是dispatch_time(参数1,开始的时间) NSEC_PER_SEC：纳秒
            参数3: 间隔多长时间执行一次定时器任务  
            参数4: 误差，设置为0即可
        NSTimeInterval start = 3.0;
        NSTimeInterval interval = 1.0;
        dispatch_source_set_timer(self.timer,  
                        dispatch_time(DISPATCH_TIME_NOW, start * NSEC_PER_SEC),
                        interval * NSEC_PER_SEC,
                        0);
        //3. 设置定时器回调方法
        dispatch_source_set_event_handler(self.timer, ^{
            NSLog(@"1111--current Threaad:%@",[NSThread currentThread]);
        });
        //设置定时器回调方法二：通过Block方式
        //dispatch_source_set_event_handler_f(self.timer, timerTest);
        //4. 启动定时器
        dispatch_resume(self.timer);
    }
    
    //typedef void (*dispatch_function_t)(void *_Nullable);
    void timerTest(void* paramer) {
        NSLog(@"1111--current Threaad:%@",[NSThread currentThread]);
    }

    @end
    
    打印结果: 16:00:23.706883+0800 -------begin-------
    16:00:26.708723+0800  1111--current Threaad:<NSThread: 0x2825a20c0>{number = 1, name = main}
    16:00:27.708869+0800  1111--current Threaad:<NSThread: 0x2825a20c0>{number = 1, name = main}
    16:00:28.708798+0800  1111--current Threaad:<NSThread: 0x2825a20c0>{number = 1, name = main}
    16:00:29.708184+0800  1111--current Threaad:<NSThread: 0x2825a20c0>{number = 1, name = main}
    当页面返回时，定时器打印任务结束
#### 分析：我们通过GCD创建的定时器，是不依赖于RunLoop的，所以它的定时时间是准确的，那么如果我们在页面中添加个滚动视图去触摸滚动时，定时器任务是不会停止的，因为GCD创建的定时器和RunLoop没有任何关系，不会存在像NSTimer运行在RunLoopMode导致的实效问题；GCD创建的定时器不存在循环引用的问题，因为GCD内部已经做了处理了。GCD创建的定时器既可以同步执行也可以异步执行

#### 1.4 项目中利用GCD封装定时器
#### 详情见工程项目中的**WGGCDTimer**
    
### 2.介绍下内存的几大区域
#### 2.1 iOS内存布局,后续自己验证
     低地址   
       |   [保留地址]
       |   [代码段(_TEXT)]: 编译之后的代码
       |   [数据段(_DATA)]: 
       |           字符串常量: 比如 NSString *str = @"123"
       |           已初始化数据:已初始化的全局变量、静态变量
       |           未初始化数据:未初始化的全局变量、静态变量
       |   [堆(heap)] : 通过alloc、malloc、calloc等动态分配的空间,分配的内存地址越来越大
       |               堆分配地址是由低到高
       |   [栈(stack)]: 函数调用开销,函数中的局部变量(不管是否初始化)都是放在栈上的,分配的内存地址越来越小
       |               栈分配地址是由高到低
       |   [内核区]
       |
     高地址
#### 2.2   Tagged Pointer技术
#### 从64bit开始,iOS引入了Tagged Pointer技术,用来优化NSNumber、NSDate、NSString等小对象的存储.
1.  在没有使用Tagged Pointer技术前,NSNumber等对象就是普通的OC对象,需要动态分配内存,维护引用计数等,NSNumber的指针存储的是堆中NSNumber对象的地址值; 
2. 使用Tagged Pointer技术后, NSNumber指针里面存储的数据变成了: Tag(类型标记)+Data(值),也就是直接将数据存储到了指针中

        // 这两行代码完全一样
        NSNumber *number = [NSNumber numberWithInt:10];
        NSNumber *number = @10; 

        //没有使用 Tagged Pointer技术前
        0x10010101                     内存地址: 0x10010101
        number       ------------->    NSNumber对象
                                       存储值10
        //使用 Tagged Pointer技术后
        number = 0xb0000a1   (a代表10 1代表类型)
3. 当指针(Tagged Pointer)不够存储数据时,才会使用动态分配内存的方式来存储数据
4. objc_msgSend能识别Tagged Pointer,比如NSNumber的intValue方法,直接从指针提取数据,节省了以前的调用开销
5. 如何判断一个指针是否是Tagged Pointer? iOS平台,最高有效位是1(第64位); Mac平台,最低有效位是1

        
#### 2.2.1 有关Tagged Pointer面试题
    // 下面两种方式会出现什么问题
    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
    for (int i = 0; i < 1000; i++) {
        dispatch_async(queue, ^{
            self.name = [NSString stringWithFormat:@"abcdefghijk"];
        });
    }

    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
    for (int i = 0; i < 1000; i++) {
        dispatch_async(queue, ^{
            self.name = [NSString stringWithFormat:@"abc"];
        });
    }


    @interface WGMainObjcVC()
    @property(nonatomic, copy) NSString *name;
    @end

    @implementation WGMainObjcVC
    - (void)viewDidLoad {
        [super viewDidLoad];

        dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
        for (int i = 0; i < 1000; i++) {
            dispatch_async(queue, ^{
                self.name = [NSString stringWithFormat:@"abcdefghijk"];
            });
        }
    }
    运行直接报错: Thread 4: EXC_BAD_INSTRUCTION (code=EXC_I386_INVOP, subcode=0x0)
#### 分析, 我们知道self.name实际上调用的是name属性的setter方法,ARC环境下,是系统帮我们添加了release/retain操作,实际在MRC环境下setter方法的伪代码如下, 案例中是多个线程中调用name属性的setter方法,那么就存在同一时间多个线程调用[_name release]方法,即_name可能会被释放多次,所以就会到导致错误(坏内存访问),而无论修饰符是strong还是copy,都会执行[_name release]这句代码,
    -(void)setName:(NSString *)name {
        if (_name != name) {  //如果传进来的属性值和之前不一样,就先将旧值release,然后在赋值
            [_name release];
            _name = [name retain];   //name属性修饰符是strong
            //_name = [name copy];   //name属性修饰符是copy
        }
    }
#### 解决方案: 
* 方案一: 将修饰name属性的nonatomic非原子属性改为atomic原子属性,这样在setter方法时就会有加锁解锁,就可以保证线程访问安全,即同一时间只有一个线程访问. (不推荐)如果其他地方也调用了self.name,而加锁解锁会消耗性能,所以不推荐使用
* 方案二: 直接在对name属性赋值的前后进行加锁/解锁操作即可

        dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
        for (int i = 0; i < 1000; i++) {
            dispatch_async(queue, ^{
                self.name = [NSString stringWithFormat:@"abc"];
            });
        }
        NSString *str1 = [NSString stringWithFormat:@"abcdefghijk"];
        NSString *str2 = [NSString stringWithFormat:@"abc"];
        NSLog(@"str1: ----%@ str2:---- %@",[str1 class],[str2 class]);
        
        正常运行并打印
        str1: ----__NSCFString str2:---- NSTaggedPointerString
        
#### 分析: 因为字符串值是abc, 直接是用Tagged Pointer技术存储的,所以它不是OC对象,不会去调用属性name的setter方法；
#### 针对NSString,有以下三种类型
1. __NSCFString: 对象类型，存储在堆中
2. __NSCFConstantString: 常量字符串，存储在数据区
3. NSTaggedPointerString: 内容被直接存储在指针中，可以当作一种伪对象：stringWithFormat方式创建的字符串(数字，英文字母)长度小于等于9，又被优化成TaggedPointer，若大于9个字符，则会成为对象类型，存储在堆中
        
#### 2.3 Tagged Pointer源码分析

    objc_release(id obj){
        if (!obj) return;
        //在realse销毁对象时,如果对象是TaggedPointer直接返回,不做销毁操作,因为它并不是一个OC对象
        if (obj->isTaggedPointer()) return;  
        return obj->release();
    }
    
    objc_object::isTaggedPointer() {
        return _objc_isTaggedPointer(this);
    }
    
    #if OBJC_MSB_TAGGED_POINTERS   //iOS开发,将1向左移63位(指针的最高有效位是1,就是TaggedPointer)
    #define _OBJC_TAG_MASK (1UL<<63)  
    #else  //Mac开发(指针的最低有效位是1,就是TaggedPointer)
    #define _OBJC_TAG_MASK 1UL
    
    //如果 指针&_OBJC_TAG_MASK = _OBJC_TAG_MASK 就是TaggedPointer
    _objc_isTaggedPointer(const void * _Nullable ptr) {
        return ((uintptr_t)ptr & _OBJC_TAG_MASK) == _OBJC_TAG_MASK;
    }
        
### 3. OC对象内存管理
#### 3.1 在iOS中,利用**引用计数**来管理OC对象中的内存;
* 一个新创建的OC对象,引用计数默认是1,当引用计数减为0时,OC对象就会销毁,释放其占用的内存空间;
* 调用retain会让OC对象的引用计数+1,调用release会使对象的引用计数-1;
* 当调用alloc、new、copy、mutableCopy方法返回了一个对象,在不需要这个对象时,需要调用release或autorelease来释放
* 想拥有某个对象,就让它的引用计数+1; 不想再拥有某个对象,就让它的引用计数-1


#### 接下来我们关闭ARC(Build Settings -> Objective-C Automatic Reference Counting ->NO(默认是YES,即ARC)),在MRC下验证

        //WGPerson.m文件
        @implementation WGPerson
        -(void)dealloc {
            [super dealloc];
            NSLog(@"----%s",__func__);
        }
        @end

        int main(int argc, const char * argv[]) {
            @autoreleasepool {
                //内存泄漏: 该释放的对象没有释放
                //WGPerson *p = [WGPerson new];
                WGPerson *p = [[WGPerson alloc]init];
                NSLog(@"%ld", [p retainCount]);
                [p release];
            }
            return 0;
        }

        打印结果: 1
                -----[WGPerson dealloc]
#### 每次创建一个OC对象,都需要在不使用时,调用release进行释放; 另外还有一个释放对象的方法autorelease,该方法好处就是开发者不需要去担心调用对象的方法/属性是在release方法前还是后的问题, 如果使用release进行释放,在release方法后是不能对对象进行操作的,因为对象已经销毁了,再调用对象的属性/方法会报错, 而

        WGPerson *p = [[[WGPerson alloc]init] autorelease];
        NSLog(@"%ld", [p retainCount]);
        
        打印结果: 1
                -----[WGPerson dealloc]
#### 3.2 在OC中各个对象之间是有联系的(WGPerson对象拥有WGDog狗对象),所以涉及到MRC下内存管理方法总结,一般在MRC下我们写setter方法和销毁对象方法是这样的

    @interface WGPerson : NSObject
    {
        WGDog *_dog;
    }
    -(void)setDog:(WGDog *)dog;
    -(WGDog *)dog;
    @end

    @implementation WGPerson
    //MRC下,判断不是同一个对象,先对原来的对象进行release,然后再对传进来的对象进行retain
    -(void)setDog:(WGDog *)dog {
        if (_dog != dog) {
            [_dog release];
            _dog = [dog retain];
        }
    }
    -(WGDog *)dog {
        return _dog;
    }

    -(void)dealloc {
        [_dog release];
        _dog = nil;
        //上面两行代码也可以换成下面的,调用的是setDog方法
        self.dog = nil
        //父类的dealloc放到最后
        [super dealloc];
        NSLog(@"----%s",__func__);
    }
    @end

#### 3.3 在MRC环境下,   @synthesize 属性 = _属性名称; 会自动生成成员变量和属性的setter/getter实现
    @interface WGPerson : NSObject
    //MRC下声明属性,之前仅仅是声明了属性的setter/getter方法,后面编译器做了优化,也对属性的setter/getter方法做了实现
    @property(nonatomic, assign) int age;
    @end

    @implementation WGPerson
    //自动生成成员变量和属性的setter/getter实现,后面编译器做了优化,也对属性的setter/getter方法做了实现,所以后面也可以不用写了
    @synthesize age = _age;
    @end
    
    
    @property(nonatomic, assign) int age;
    @property(nonatomic, retain) WGDog *dog;
    
    在MRC下系统帮我们生成了对应的setter方法如下,但是不会生成dealloc方法,dealloc方法还是需要我们手动去写的
    -(void)setAge:(int)age {
        _age = age;
    }

    -(void)setDog:(WGDog *)dog {
        if (_dog != dog) {
            [_dog release];
            _dog = [dog retain];
        }
    }
#### 可以看出assign/retain的区别,assign针对的是基本数据类型,它的setter方法是直接赋值;而retain修饰是针对对象的,它的setter方法会先对旧的对象进行release,然后再对新的对象进行retain,会使引用计数+1

#### 在MRC下只要不是alloc、new、malloc开头的创建对象,都不需要手动去调用release,例如下面的,因为它们在调用对用的创建方法时,系统已经帮我们做了autorelease操作 
        NSMutableArray *arr = [NSMutableArray array];
        NSDictionary *dic = [NSDictionary dictionary];

#### 3.4 copy 和 mutableCopy
#### 拷贝的目的: 就是产生一个副本.跟源对象互不影响.修改了源对象,不影响副本对象; 修改了副本对象,不影响源对象. iOS提供了两种拷贝方法: 
1. copy: 不可变拷贝,产生不可变副本; 
2. mutableCopy: 可变拷贝, 产生可变副本;

#### 3.4.1 在MRC环境下,当我们通过alloc、new、copy、mutableCopy等方法产生的对象,我们需要负责释放的,如下
    //通过这种方式创建的字符串,在MRC下,系统已经帮我们自动插入了autorelease,所以不需要我们再手动调用releas方法了
    //注意:这里如果写的字符串值比较小,就会用到TaggedPointer计数,那么它的引用计数值会是-1,不利于我们观察对象的引用计数
    //NSString *str0 = [NSString stringWithFormat:@"123sdfasdfsfsf"];
    NSString *str1 = [[NSString alloc]initWithFormat:@"123sdfasdfsfsf"];
    NSString *str2 = [str1 copy];
    NSMutableString *str3 = [str1 mutableCopy];

    NSLog(@"\nstr1:%p\nstr2:%p\n:str3:%p\n",str1,str2,str3);
    [str3 release];
    [str2 release];
    [str1 release];

    打印结果: str1:0x102045a90
            str2:0x102045a90
            :str3:0x102046150
#### 分析,为什么str1和str2的地址值是一样的? copy不是产生了副本对象吗? 原因就是源对象str1是不可变的,而通过copy后产生的副本对象也是不可变的,根据拷贝的准则: 修改源对象/副本对象不影响副本对象/源对象, 因为源对象本身就是不可变的,所以根本无法修改,为了节省空间,所以系统将str2的指针也指向了str1指针所指向的内容, 如果此时对str1或者str2赋新的值,那么它们的地址就会变成不一样的,因为拷贝的准则,所以系统会为str1和str2分配不同的地址空间


#### 3.4.2 深拷贝和浅拷贝
* 深拷贝: 内容拷贝,产生新的对象
* 浅拷贝: 指针拷贝,没有产生新的对象

        //源对象不可变
        NSString *str1 = [[NSString alloc]initWithFormat:@"123"]; 
        NSString *str2 = [str1 copy];                    //浅拷贝,没有产生新的对象
        NSMutableString *str3 = [str1 mutableCopy];      //深拷贝,产生新的对象

        //str1引用计数1;str2和str1指向同一个对象,所以此时的[str1 copy]就相当于[str1 retain],使引用计数+1;
        //str3引用计数1

        //源对象可变
        NSMutableString *str1 = [[NSMutableString alloc]initWithFormat:@"123"];
        NSString *str2 = [str1 copy];                    //深拷贝,产生了新的对象
        NSMutableString *str3 = [str1 mutableCopy];      //深拷贝,产生了新的对象

#### 3.4.3 总结: 数组、字典与字符串仍然适用上面的方法
                             copy                         mutablecopy
       NSString              NSString-浅拷贝               NSMutableString-深拷贝 
       NSMutableString       NSString-深拷贝               NSMutableString-深拷贝
       NSArray               NSArray-浅拷贝                NSMutableArray-深拷贝
       NSMutableArray        NSArray-深拷贝                NSMutableArray-深拷贝
       NSDictionary          NSDictionary-浅拷贝           NSMutableDictionary-深拷贝
       NSMutableDictionary   NSDictionary-深拷贝           NSMutableDictionary-深拷贝


#### 3.4.4 案例分析
#### 在MRC环境下,下面声明的属性会自动生成对应的setter方法
        @interface WGPerson : NSObject
        @property(nonatomic, assign) int age;
        @property(nonatomic, retain) WGDog *dog;
        @property(nonatomic, copy) NSArray *arr;
        @end

        -(void)setAge:(int)age {
            _age = age;
        }
        -(void)setDog:(WGDog *)dog {
            if (_dog != dog) {
                [_dog release];
                _dog = [dog retain];
            }
        }
        -(void)setArr:(NSArray *)arr {
            if (_arr != arr) {
                [_arr release];
                _arr = [arr copy];
            }
        }
#### 下面代码是否有问题
        @interface WGPerson : NSObject
        @property(nonatomic, copy) NSMutableArray *arr;
        @end
        
        int main(int argc, const char * argv[]) {
            @autoreleasepool {
                WGPerson *p = [[WGPerson alloc]init];
                p.arr = [[NSMutableArray alloc]init];
                [p.arr addObject:@"123"];
                [p.arr addObject:@"456"];
                [p release];
            }
            return 0;
        }
        
        //MRC下系统为arr生成的setter方法实现
        -(void)setArr:(NSArray *)arr {
            if (_arr != arr) {
                [_arr release];
                _arr = [arr copy];
            }
        }
#### 分析: 上面代码会报错,因为声明的可变数组arr用的是copy修饰,它底层的setter方法调用的是copy方法,那么返回的数组对象就是不可变的,所以在进行[p.arr addObject:]方法调用时会报错:-[__NSArray0 addObject:]: unrecognized selector sent to instance 0x101801070, 那么可不可以用mutableCopy来修饰arr哪? 答案是肯定不可以,因为mutableCopy压根都不能用来作为属性修饰符. 所以总结一句话: 开发过程中不要用copy来修饰一个可变的数组,而是要修饰一个不可变的数组,这样开发过程中一旦调用了addObject方法,编译器就会直接检查然后报错

#### 3.4.5 OC对象的copy操作
#### OC对象如果想实现copy操作,那么需要实现NSCopying协议中的copyWithZone方法
        @interface WGPerson : NSObject<NSCopying>
        @property(nonatomic, copy) NSMutableArray *arr;
        @end

        -(id)copyWithZone:(NSZone *)zone {
            WGPerson *p = [[WGPerson allocWithZone:zone] init];
            p.arr = self.arr;
            return p;
        }

        int main(int argc, const char * argv[]) {
            @autoreleasepool {
                WGPerson *p = [[WGPerson alloc]init];
                WGPerson *p1 = [p copy];
            }
            return 0;
        }

#### 3.5 **引用计数**存储方式
#### 在64bit中,引用计数可以直接存储在优化过的isa指针中,也可以存储在SideTable类中,见Runtime源码
        struct SideTable {
        spinlock_t slock;
        RefcountMap refcnts;       是一个存放着对象引用计数的散列表
        weak_table_t weak_table;
        ......
        }
        
#### 找到retainCount方法,我们详细看下引用计数是如何获取的
    - (NSUInteger)retainCount {
        return ((id)self)->rootRetainCount();
    }
    
    objc_object::rootRetainCount() {
        //判断是否是TaggedPointer,如果是直接返回(之前验证过,如果是TaggedPointer,那么引用计数就是-1)
        if (isTaggedPointer()) return (uintptr_t)this;  
        sidetable_lock();
        isa_t bits = LoadExclusive(&isa.bits);
        ClearExclusive(&isa.bits);
        if (bits.nonpointer) {    //优化过的isa指针
            uintptr_t rc = 1 + bits.extra_rc;
            if (bits.has_sidetable_rc) {//如果引用计数不是存储在isa中,而是存储在sideTable结构中
                rc += sidetable_getExtraRC_nolock();
            }
            sidetable_unlock();
            return rc;
        }
        sidetable_unlock();
        return sidetable_retainCount();
    }
    
    objc_object::sidetable_getExtraRC_nolock() {
        assert(isa.nonpointer);
        //通过key获取到一个value(对象的地址作为Key)
        SideTable& table = SideTables()[this];  
        // 将对象的地址this传给散列表,获取到对象对应的引用计数,然后返回
        RefcountMap::iterator it = table.refcnts.find(this);
        if (it == table.refcnts.end()) return 0;
        else return it->second >> SIDE_TABLE_RC_SHIFT;
    }
#### 查看release方法源码
    -(void) release {
        _objc_rootRelease(self);
    }

    _objc_rootRelease(id obj) {
        assert(obj);
        obj->rootRelease();
    }

    objc_object::rootRelease() {
        return rootRelease(true, false);
    }

    //简化后的
    objc_object::rootRelease(bool performDealloc, bool handleUnderflow) {
        if (isTaggedPointer()) return false;
        bool sideTableLocked = false;
            if (slowpath(!newisa.nonpointer)) {//如果不是优化过的isa指针,那么就从sideTable里找
                ClearExclusive(&isa.bits);
                if (sideTableLocked) sidetable_unlock();
                return sidetable_release(performDealloc);
            }
    }
        
    objc_object::sidetable_release(bool performDealloc) {
        //以对象的地址为key,从SideTables散列表中找到一个value
        SideTable& table = SideTables()[this];
        bool do_dealloc = false;
        table.lock();
        RefcountMap::iterator it = table.refcnts.find(this);
        if (it == table.refcnts.end()) {
            do_dealloc = true;
            table.refcnts[this] = SIDE_TABLE_DEALLOCATING;
        } else if (it->second < SIDE_TABLE_DEALLOCATING) {
            // SIDE_TABLE_WEAKLY_REFERENCED may be set. Don't change it.
            do_dealloc = true;
            it->second |= SIDE_TABLE_DEALLOCATING;
        } else if (! (it->second & SIDE_TABLE_RC_PINNED)) {
            it->second -= SIDE_TABLE_RC_ONE;    //减操作
        }
        table.unlock();
        //一旦上面引用计数-1,就有可能会减为0,所以就需要判断是否需要dealloc,如果需要,  
        就通过objc_msgSend发送dealloc消息
        if (do_dealloc  &&  performDealloc) {
            ((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_dealloc);
        }
        return do_dealloc;
    }
#### 查看retain方法源码
    -(id) retain {
        return _objc_rootRetain(self);
    }

    _objc_rootRetain(id obj){
        assert(obj);
        return obj->rootRetain();
    }

    objc_object::rootRetain() {
        return rootRetain(false, false);
    }
        
    //简化后的
    objc_object::rootRetain(bool tryRetain, bool handleOverflow) { 
        if (isTaggedPointer()) return (id)this;
            //如果不是优化过的isa指针,那么就从sideTable里找
            if (slowpath(!newisa.nonpointer)) {  
                ClearExclusive(&isa.bits);
                if (!tryRetain && sideTableLocked) sidetable_unlock();
                if (tryRetain) return sidetable_tryRetain() ? (id)this : nil;
                else return sidetable_retain();
            }
    }
    
    objc_object::sidetable_retain()
        //以对象的地址为key,从SideTables散列表中找到一个value
        SideTable& table = SideTables()[this];
        table.lock();
        size_t& refcntStorage = table.refcnts[this];
        if (! (refcntStorage & SIDE_TABLE_RC_PINNED)) {
            refcntStorage += SIDE_TABLE_RC_ONE;   //加操作
        }
        table.unlock();
        return (id)this;
    }
#### 3.6 weak指针的实现原理
        @implementation Person
        -(void)dealloc {
            NSLog(@"%s---",__func__);
        }
        @end

        - (void)viewDidLoad {
            [super viewDidLoad];
            NSLog(@"begin");
            {
                Person *person = [[Person alloc]init];
            }
            NSLog(@"end");
        }
        打印结果: begin
                -[Person dealloc]---
                end
#### 一旦出了{},person对象就会被销毁
    - (void)viewDidLoad {
        [super viewDidLoad];
        __strong Person *person1;    //__strong可以不写,因为默认都是强引用
        __weak Person *person2;
        __unsafe_unretained Person *person3;
        NSLog(@"begin");
        {
            Person *person = [[Person alloc]init];
            //1. person1是强引用,所以出了{},person对象并不会销毁,而是在viewDidLoad方法执行结束后销毁
            //所以打印结果是: begin  -->   end   --> -[Person dealloc]---
            //person1 = person;
            
            //2. person2是弱引用,所以出了{},person对象就销毁了
            //所以打印结果是: begin  -->   -[Person dealloc]---   -->   end
            //person2 = person;
            
            //3. person3也是弱引用,所以出了{},person对象就销毁了
            //所以打印结果是: begin  -->   -[Person dealloc]---   -->   end
            person3 = person;
            
            //4.__weak和__unsafe_unretained都是弱指针,区别就是__weak弱引用在对象销毁时,会对对象自动置为nil;  
            而__unsafe_unretained弱引用在对象销毁时,不会对对象自动置为nil,会出现野指针问题,即虽然对象销毁了,  
            但是它的内存仍然存在,如果继续访问该对象,会导致坏内存访问
        }
        NSLog(@"end");
    }
#### 要想知道weak的原理,即对象销毁后,系统是如何对销毁的对象自动置为nil的,我们需要查看dealloc方法源码
    - (void)dealloc {
        _objc_rootDealloc(self);
    }

    _objc_rootDealloc(id obj) {
        assert(obj);
        obj->rootDealloc();
    }

    objc_object::rootDealloc() {
        if (isTaggedPointer()) return;  // fixme necessary?
        if (fastpath(isa.nonpointer  &&             //是否是优化过的isa指针
                     !isa.weakly_referenced  &&     //是否有弱引用表(取反)
                     !isa.has_assoc  &&             //是否有关联对象(取反)
                     !isa.has_cxx_dtor  &&          //是否有C++的析构函数(取反)
                     !isa.has_sidetable_rc)) {      //是否有sideTable(取反)
            assert(!sidetable_present());
            free(this);  //如果上面条件成立,直接释放,不需要其他查询,释放效率会更快
        } else {
            object_dispose((id)this);
        }
    }
        
    object_dispose(id obj) {
        if (!obj) return nil;
        objc_destructInstance(obj);    
        free(obj);   //释放对象前,先去忙其他事情(objc_destructInstance方法)
        return nil;
    }
    
    void *objc_destructInstance(id obj) {
        if (obj) {
            // Read all of the flags at once for performance.
            bool cxx = obj->hasCxxDtor();
            bool assoc = obj->hasAssociatedObjects();
            // This order is important.
            if (cxx) object_cxxDestruct(obj);            //清除成员变量
            if (assoc) _object_remove_assocations(obj);  //移除关联对象
            obj->clearDeallocating();                    //将指向当前对象的弱指针置为nil
        }
        return obj;
    }
        
    objc_object::clearDeallocating() {
        //是否是优化过的isa指针,如果不是(就是普通的isa指针),直接调用sidetable_clearDeallocating方法
        if (slowpath(!isa.nonpointer)) {  
            // Slow path for raw pointer isa.
            sidetable_clearDeallocating();
        } else if (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) {  
            //判断是否有弱引用表
            // Slow path for non-pointer isa with weak refs and/or side table data.
            clearDeallocating_slow();
        }
        assert(!sidetable_present());
    }
        
    objc_object::clearDeallocating_slow(){
        //弱引用表也是一个散列表, 将对象的地址作为key,找到对应的value值,
        SideTable& table = SideTables()[this];
        table.lock();
        if (isa.weakly_referenced) {  //如果是弱引用表
            weak_clear_no_lock(&table.weak_table, (id)this);
        }
        if (isa.has_sidetable_rc) {
            table.refcnts.erase(this);
        }
        table.unlock();
    }
        
    weak_clear_no_lock(weak_table_t *weak_table, id referent_id)  {
        objc_object *referent = (objc_object *)referent_id;
        //根据对象的地址(key)找出对应的东西weak_entry_t
        weak_entry_t *entry = weak_entry_for_referent(weak_table, referent);
        ......
        //将找到的东西weak_entry_t从表中移除
        weak_entry_remove(weak_table, entry);
    }
    
    weak_entry_for_referent(weak_table_t *weak_table, objc_object *referent) {
        //将弱引用对象的地址 & weak_table->mask = 索引 (哈希表操作)
        size_t begin = hash_pointer(referent) & weak_table->mask;
    }
#### 总结: weak实现原理:将弱引用指针存到哈希表中,当弱引用对象销毁时,取出当前对象对应的弱引用表,将弱引用表中存储的弱引用都清楚掉并且置为nil

#### 3.7 ARC帮我们做了什么
1. ARC其实就是LLVM+RunTime系统相互协助的一个结果,
2. ARC利用LLVM编译器自动帮我们生成了release、retain、autorelease代码 
3. 像弱引用这样的存在,是需要运行时Runtime来支持的,由Runtime监控到对象销毁后,利用RunTime来销毁对象的


#### 3.8 autorelease原理
#### 在MRC环境下,我们探究下源码
    int main(int argc, const char * argv[]) {
        @autoreleasepool {
            WGPerson *p = [[[WGPerson alloc]init] autorelease];
        }
        return 0;
    }

    转为C++代码
    int main(int argc, const char * argv[]) {
        /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; 
            WGPerson *p = ((WGPerson *(*)(id, SEL))(void *)objc_msgSend)((id)  
            ((WGPerson *(*)(id, SEL))(void *)objc_msgSend)  
            ((id)((WGPerson *(*)(id, SEL))(void *)objc_msgSend)
            ((id)objc_getClass("WGPerson"),  
            sel_registerName("alloc")), sel_registerName("init")), 
            sel_registerName("autorelease"));
        }
        return 0;
    }
    简化为
    {   
        __AtAutoreleasePool __autoreleasepool; 
        WGPerson *p = [[[WGPerson alloc]init] autorelease];
    }
#### 找到对应的结构体
    struct __AtAutoreleasePool {
        //C++构造函数,在创建结构体时调用
        __AtAutoreleasePool() { 
            atautoreleasepoolobj = objc_autoreleasePoolPush();
        }
        //C++析造函数,在结构体销毁时调用
        ~__AtAutoreleasePool() {
            objc_autoreleasePoolPop(atautoreleasepoolobj);
        }
        void * atautoreleasepoolobj;
    };
    
    {   
    //定义了局部变量,就会创建结构体__AtAutoreleasePool,所以会调用对应的构造函数,调用objc_autoreleasePoolPush  
        __AtAutoreleasePool __autoreleasepool;   
        WGPerson *p = [[[WGPerson alloc]init] autorelease];
    }//当出了{}大括号,局部变量会销毁,所以调用析构函数,调用objc_autoreleasePoolPop方法
#### 分析, 一旦调用autorelease,会生成对应的结构体,刚开始时调用objc_autoreleasePoolPush方法,当结束时调用objc_autoreleasePoolPop方法,接下来我们通过RunTime源码来探究这两个方法及它的底层结构

        
#### 3.8.1 自动释放池的底层数据结构
1. 自动释放池的底层数据结构是__AtAutoreleasePool、AutoreleasePoolPage.
2. 调用autorelease的对象最终都是通过AutoreleasePoolPage对象来管理的
3. 每个AutoreleasePoolPage对象占用4096个字节的内存,除了用来存放它内部的成员变量(7个成员变量占56个字节),剩下的空间(4040个字节)用来存放autorelease对象的地址
4. 所有的AutoreleasePoolPage对象通过双向链表的形式连接在一起

        // push方法和AutoreleasePoolPage有关系
        objc_autoreleasePoolPush(void) {
            return AutoreleasePoolPage::push();
        }
        
        //简化后的
        class AutoreleasePoolPage  {  
            magic_t const magic;
            //存放 下一个能存放autorelease对象 的地址
            id *next;
            
            pthread_t const thread;
            //存放上一个AutoreleasePoolPage对象的地址,如果是第一个对象,则为nil
            AutoreleasePoolPage * const parent;
            
            //存放下一AutoreleasePoolPage对象的地址,如果是最后一个对象,则为nil
            AutoreleasePoolPage *child;  
            uint32_t const depth;
            uint32_t hiwat;
        }
        
        id * begin() { //存放autorelease对象的开始地址
            return (id *) ((uint8_t *)this+sizeof(*this));
        }

        id * end() {  //存放autorelease对象的结束地址
            return (id *) ((uint8_t *)this+SIZE);  //SIZE = 4096个字节
        }
#### 假如我们有1000个autorelease对象需要存储,它的存储过程是怎样的,1000个autorelease对象,用AutoreleasePoolPage对象来存储的,一个AutoreleasePoolPage对象存储4040个字节,而一个对象的地址占用8个字节,也就是需要8000个字节的空间来存储,那么就需要2个AutoreleasePoolPage对象才能存储的下
        for (int i = 0 ; i < 1000; i++) {
            WGPerson *p = [[[WGPerson alloc]init] autorelease];
        }
#### 3.8.2 存储过程
1. 当调用push时(此时next指针指向的就是可以存放对象的地址),会将**POOL_BOUNDARY**入栈,并且返回其存放的内存地址(此时next指针指向的就是挨着POOL_BOUNDARY地址的下一个地址空间),存放的位置假如说存放的是第一个AutoreleasePoolPage对象开始存放autorelease对象的开始地址

        atautoreleasepoolobj = objc_autoreleasePoolPush();
        假如存放POOL_BOUNDARY的地址为0x1038,那么atautoreleasepoolobj的地址就是0x1038

2. 当第一个对象调用autorelease方法时,会将第一个对象的地址存放在和POOL_BOUNDARY地址挨着的下一个内存空间
3. 依次循环存储,当第一个AutoreleasePoolPage的存储空间(4040个字节)占满时,就会继续创建第二个AutoreleasePoolPage对象来存储
4. 当循环结束时,会调用objc_autoreleasePoolPop方法,调用Pop方法时传入一个**POOL_BOUNDARY**的内存地址,然后会从最后一个入栈的对象开始,发送release方法,直到遇到**POOL_BOUNDARY**的地址,**POOL_BOUNDARY**其实就是一个标记

        //将POOL_BOUNDARY的地址传给pop方法
        objc_autoreleasePoolPop(atautoreleasepoolobj);

        #define POOL_BOUNDARY nil
        
        static inline void *push() {
            id *dest;
            if (DebugPoolAllocation) {
                // Each autorelease pool starts on a new pool page.
                dest = autoreleaseNewPage(POOL_BOUNDARY);
            } else {
                dest = autoreleaseFast(POOL_BOUNDARY);
            }
            assert(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);
            return dest;
        }
        
#### 3.8.3 利用**extern void _objc_autoreleasePoolPrint(void)**函数可以查看自动释放池的情况
    int main(int argc, const char * argv[]) {
        @autoreleasepool {
            WGPerson *p1 = [[[WGPerson alloc]init] autorelease];
            WGPerson *p2 = [[[WGPerson alloc]init] autorelease];
            //_objc_autoreleasePoolPrint();
            @autoreleasepool {
                for (int i = 0; i < 500; i++) {
                    WGPerson *p3 = [[[WGPerson alloc]init] autorelease];
                }
                //_objc_autoreleasePoolPrint();
                @autoreleasepool {
                    WGPerson *p4 = [[[WGPerson alloc]init] autorelease];
                    WGPerson *p5 = [[[WGPerson alloc]init] autorelease];
                }
                _objc_autoreleasePoolPrint();
            }
        }
        return 0;
    }
        
    打印内存: objc[68116]: ##############
    objc[68116]: AUTORELEASE POOLS for thread 0x1000aa5c0
    objc[68116]: 4 releases pending.
    objc[68116]: [0x101006000]  ................  PAGE  (hot) (cold) //cold冷,存满的page
    objc[68116]: [0x101006038]  ################  POOL 0x101006038
    objc[68116]: [0x101006040]       0x100539370  WGPerson
    objc[68116]: [0x101006048]       0x100539180  WGPerson
    objc[68116]: [0x101006050]  ################  POOL 0x101006050
    objc[68116]: ##############
    Program ended with exit code: 0
#### 分析:  PAGE  (full) (cold): cold冷,表示存满的page; PAGE (hot):hot热,表示当前使用的page

#### 3.9 autorelease对象在什么时候释放
    - (void)viewDidLoad {
        [super viewDidLoad];
        NSLog(@"%@",[NSRunLoop currentRunLoop]);
    }
    
    "<CFRunLoopObserver 0x600000538be0 [0x7fff80617cb0]>{valid = Yes, activities = 0x1,  
    repeats = Yes, order = -2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x7fff4808bf54),  
    context = <CFArray 0x600003a50810 [0x7fff80617cb0]>{type = mutable-small, count = 1,  
    values = (\n\t0 : <0x7fbdb8803040>\n)}}",
    
    "<CFRunLoopObserver 0x600000538c80 [0x7fff80617cb0]>{valid = Yes, activities = 0xa0,  
    repeats = Yes, order = 2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x7fff4808bf54),  
    context = <CFArray 0x600003a50810 [0x7fff80617cb0]>{type = mutable-small, count = 1,  
    values = (\n\t0 : <0x7fbdb8803040>\n)}}"
    
    //RunLoop的状态
    typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {
       kCFRunLoopEntry = (1UL << 0),                即将进入RunLoop (十进制1)
       kCFRunLoopBeforeTimers = (1UL << 1),         即将处理Timers (十进制2)
       kCFRunLoopBeforeSources = (1UL << 2),        即将处理Sources (十进制4)
       kCFRunLoopBeforeWaiting = (1UL << 5),        即将进入休眠 (十进制32)
       kCFRunLoopAfterWaiting = (1UL << 6),         刚从休眠中唤醒 (十进制64)
       kCFRunLoopExit = (1UL << 7),                 即将推出RunLoop (十进制128)
       kCFRunLoopAllActivities = 0x0FFFFFFFU
    };
#### 在打印信息中,我们可以发现有两个_wrapRunLoopWithAutoreleasePoolHandler函数,这两个函数和自动释放池有关. 这两个函数中分别对应的有activities = 0x1(十进制1) 和 activities = 0xa0(十进制160),这代表监听的RunLoop的状态,activities = 0x1监听的是即将进入RunLoop的状态kCFRunLoopEntry,activities = 0xa0(十进制160)监听的是kCFRunLoopBeforeWaiting-32(休眠之前)和kCFRunLoopExit-128(退出)

#### 总结
1. iOS在主线程的RunLoop中注册了2个Observer
2. 第一个Observer监听了kCFRunLoopEntry事件(即将进入RunLoop),会调用objc_autoreleasePoolPush()方法
3. 第二个Observer监听了两个事件: 

        kCFRunLoopBeforeWaiting事件(RunLoop进入休眠前),会调用objc_autoreleasePoolPop()、objc_autoreleasePoolPush()
        kCFRunLoopExit事件(RunLoop即将退出),会调用objc_autoreleasePoolPop()方法
4. autorelease对象可能是在某次RunLoop循环中,RunLoop休眠之前调用的release方法进行销毁的

#### 3.10 方法里有局部对象,出了方法会立刻释放吗?
#### 这个问题应该是考察ARC环境下的,主要就是看下ARC帮我们做了什么,是自动调用了autorelease方法(出了方法体可能还不会销毁,而是等到RunLoop循环中,休眠之前才进行销毁)还是调用了release方法(出了方法立刻释放)

        - (void)viewDidLoad {
            [super viewDidLoad];
            Person *p = [[Person alloc]init];
        }

        -(void)viewWillAppear:(BOOL)animated {
            [super viewWillAppear:animated];
            NSLog(@"----%s",__func__);
        }

        -(void)viewDidAppear:(BOOL)animated {
            [super viewDidAppear:animated];
            NSLog(@"----%s",__func__);
        }
        
        打印结果: -[Person dealloc]---
                -----[WGMainObjcVC viewWillAppear:]
                -----[WGMainObjcVC viewDidAppear:]

#### 分析,我们大胆猜测,ARC环境下,应该是局部变量一旦出了方法体, ARC就会帮我们自动调用对象的release方法,所以局部变量出了方法,是会立刻销毁的




#### 上面是MJExtension总结

## 内存管理

### 一 自动释放池AutoreleasePool  https://www.jianshu.com/p/9c8139fc3100
#### 1 自动释放池简介
#### Autorelease机制是为了延时释放对象, OC对象的生命周期取决于引用计数, 有两种方式可以释放对象: (1)直接调用release释放(2)调用autorelease将对象加入自动释放池中。而自动释放池用来存放那些需要在某个时刻(当次的RunLoop事件循环将要结束的时候会释放掉)释放的对象,如果没有自动释放池而给对象发送autorelease消息,控制台会报错,但一般我们不需要担心自动释放池的创建问题,系统会自动创建一些线程,例如主线程和GCD中的线程,都默认拥有自动释放池,每次执行“事件循环”(event loop)时，就会将自动释放池清空,简单说就是在当次的RunLoop将要结束的时候调用objc_autoreleasePoolPop，并push进来一个新的AutoreleasePool

#### 2. 自动释放池的底层结构 https://www.jianshu.com/p/afdf1e081fa2
####  1.1 自动释放池的底层结构是以栈为节点，以双向链表形式组合而成的一个数据结构。通俗讲自动释放池是以多个AutoreleasePoolPage为结点，通过链表的方式串连起来的结构，这一整串就是自动释放池,即每个自动释放池都是由若干个AutoreleasePoolPage组成的双向链表结构。每个AutoreleasePoolPage对象占用4096个字节,除了存放它内部的成员变量,剩下的用来存放autorelease对象的地址,所有的AutoreleasePoolPage对象通过双向链表的形式连接在一起

#### 1.2 AutoreleasePoolPage中的parent、child指针分别指向上一个和下一个page,当前page的空间被占满(每个AutorelePoolPage的大小为4096字节)时，就会新建一个AutorelePoolPage对象并连接到链表中，后来的 Autorelease对象也会添加到新的page中；另外，当next== begin()时，表示AutoreleasePoolPage为空；当next == end()，表示AutoreleasePoolPage已满。

    class AutoreleasePoolPage {
        #define EMPTY_POOL_PLACEHOLDER ((id*)1)  //空池占位
        #define POOL_BOUNDARY nil                //边界对象(即哨兵对象）
        magic_t const magic; //校验AutoreleasePagePoolPage结构是否完整
        id *next;            //指向新加入的autorelease对象的下一个位置，初始化时指向begin()
        pthread_t const thread;  //当前所在线程，AutoreleasePool是和线程一一对应的
        AutoreleasePoolPage * const parent; //双向链表中指向父节点page，第一个结点的parent值为nil
        AutoreleasePoolPage *child;         //双向链表中指向子节点page，最后一个结点的child值为nil
        uint32_t const depth;               //链表深度，节点个数
        uint32_t hiwat;                     //数据容纳的一个上限
    }
        
#### 1.3 哨兵对象(边界对象)(POOL_BOUNDARY)的作用
        #define POOL_BOUNDARY nil
#### 边界对象其实就是nil的别名,作用也就是为了起到一个标识的作用,每当自动释放池初始化调用objc_autoreleasePoolPush方法时，总会通过AutoreleasePoolPage的push方法，将POOL_BOUNDARY放到当前page的栈顶，并且返回这个边界对象;而在自动释放池释放调用objc_autoreleasePoolPop方法时，又会将边界对象以参数传入，这样自动释放池就会向释放池中对象发送release消息，直至找到第一个边界对象为止


#### 3 自动释放池释放
        @autoreleasepool {
            id obj = [[NSObject alloc]init];
        }
        编辑器会将上面的代码转为, 整个程序中push和pop的操作都是一一对应的
        void *atautoreleasepoolobj = objc_autoreleasePoolPush(void)
        id obj = [[NSObject alloc]init];
        objc_autoreleasePoolPop(atautoreleasepoolobj)
        
#### 下面我们通过Runtime源码了解下详细的方法含义
#### 3.1 push的调用方法
    //调用方法1
    void * _objc_autoreleasePoolPush(void) {
        return objc_autoreleasePoolPush();
    }
    //调用方法2
    void * objc_autoreleasePoolPush(void) {
        return AutoreleasePoolPage::push();
    }
    //调用方法3
    static inline void *push() {
        id *dest;
        if (DebugPoolAllocation) { // Each autorelease pool starts on a new pool page.
            dest = autoreleaseNewPage(POOL_BOUNDARY);
        } else {
            dest = autoreleaseFast(POOL_BOUNDARY);
        }
        return dest;
    }
    //调用方法4
    //这个函数的作用就是，找到最顶层的一个AutoreleasePoolPage对象，如果没有那就创建一个；
    //如果找到了，判断他是否已经装满了full()，因为一个AutoreleasePoolPage只有4096个字节大小，
    //如果满了那就会调用autoreleaseNoPage()创建一个AutoreleasePoolPage对象并添加add；
    //如果没满则直接执行add(obj)。
    static inline id *autoreleaseFast(id obj) {
        //hotPage()函数会对应线程去取自动释放池，这里也可以看出释放池和线程是一一对应的关系
        AutoreleasePoolPage *page = hotPage();
        if (page && !page->full()) {
        //obj是一个POOL_BOUNDARY对象(哨兵对象)，并不是我们的autorelease的对象
        //每次执行push操作时都会插入一个哨兵对象，并且把哨兵对象的地址作为返回值返回了,pop函数需要用到这个  
        哨兵对象的地址，对应的每次pop都是寻找到上一个哨兵对象，对期间所有的autorelease对象执行一次release操作。
            return page->add(obj);
        } else if (page) {
            return autoreleaseFullPage(obj, page);
        } else {
            return autoreleaseNoPage(obj);
        }
    }
#### 观察上述代码，每次调用push其实就是创建一个新的AutoreleasePool，在对应的AutoreleasePoolPage中插入一个POOL_BOUNDARY,并且返回插入的POOL_BOUNDARY的内存地址。push方法内部调用的是autoreleaseFast方法，并传入边界对象(POOL_BOUNDARY)。hotPage可以理解为当前正在使用的AutoreleasePoolPage。自动释放池最终都会通过page->add(obj)方法将边界对象添加到释放池中，而这一过程在autoreleaseFast方法中被分为三种情况：
1. 当前page存在且不满,调用page->add(obj)方法将对象添加至page的栈中，即next指向的位置
2. 当前page存在但是已满,调用autoreleaseFullPage初始化一个新的page，调用page->add(obj)方法将对象添加至page的栈中
3. 当前page不存在时,调用autoreleaseNoPage创建一个hotPage，再调用page->add(obj) 方法将对象添加至page的栈中

#### 3.2 Pop函数
#### AutoreleasePool的释放调用的是objc_autoreleasePoolPop方法，此时需要传入边界对象作为参数。这个边界对象正是每次执行objc_autoreleasePoolPush方法返回的对象atautoreleasepoolobj；
    //调用方法1
    void _objc_autoreleasePoolPop(void *ctxt) {
        objc_autoreleasePoolPop(ctxt);
    }
    //调用方法2:
    void objc_autoreleasePoolPop(void *ctxt) {
        AutoreleasePoolPage::pop(ctxt);
    }
    //调用方法3: 核心方法 向栈中的对象发送release消息，直到遇到第一个哨兵对象
    void releaseUntil(id *stop)  {
        while (this->next != stop) { //一直遍历
            // Restart from hotPage() every time, in case -release 
            // autoreleased more objects
            AutoreleasePoolPage *page = hotPage();
            // fixme I think this `while` can be `if`, but I can't prove it
            //如果当前page中的autorelease对象已释放完毕则会重新遍历父结点的page，直到找到传递来的哨兵对象为止
            while (page->empty()) {
                page = page->parent;
                setHotPage(page);
            }
            page->unprotect();
            id obj = *--page->next;
            memset((void*)page->next, SCRIBBLE, sizeof(*page->next));
            page->protect();

            if (obj != POOL_BOUNDARY) {
                objc_release(obj);
            }
        }
        setHotPage(this);
        #if DEBUG
        // we expect any children to be completely empty
        for (AutoreleasePoolPage *page = child; page; page = page->child) {
            assert(page->empty());
        }
        #endif
    }
#### 首先根据传入的边界对象地址找到边界对象所处的page；然后选择当前page中最新加入的对象一直向前清理，可以向前跨越若干个page，直到边界所在的位置；清理的方式是向这些对象发送一次release消息，使其引用计数减一；另外，清空page对象还会遵循一些原则：
1. 如果当前的page中存放的对象少于一半，则子page全部删除；
2. 如果当前的page存放的多余一半,(意味着马上将要满),则保留一个子page,节省创建新page的开销;


#### 4. autorelease方法
#### autorelease方法最终也会调用上面提到的autoreleaseFast方法,将当前对象加到AutoreleasePoolPage中。
autorelease函数和push函数一样，关键代码都是调用autoreleaseFast函数向自动释放池的链表栈中添加一个对象，不过push函数入栈的是一个边界对象，而autorelease函数入栈的是一个具体的Autorelease的对象。


#### 5. 自动释放池(autoreleasepool)作用
1. 延迟对象的释放时间
2. 合理运用自动释放池，可以降低程序的内存峰值
3. 可以避免无意间误用那些在清空池之后已被系统回收的对象, 如果用了编辑器会提示的

#### 5.1 @autoreleasepool的作用可以用来降低内存峰值,先看一个面试题
        //面试题: 修改代码中的错误
        for (int i = 0; i < 10000; i++) {
            NSString *str = @"Zhang San";
            str = [str lowercaseString];
            str = [str stringByAppendingString:@"Li Si"];
            NSLog(@"%@",str);
        }
        
#### 分析: stringByAppendingString方法可能会创建一个临时对象,这个临时对象很可能会放在自动释放池中,即便临时对象在调用完方法后就不再使用了，它们也依然处于存活状态,等待系统稍后进行回收,但自动释放池却要等到该线程执行下一次事件循环时才会清空,这就意味着在执行for循环时，会有持续不断的新的临时对象被创建出来，并加入自动释放池。要等到结束for循环才会释放。在for循环中内存用量会持续上涨，而等到结束循环后，内存用量又会突然下降,为了优化性能,我们可以这么解决,通过这种方式可以发现尽管字符串在不断地创建，但由于得到了及时的释放，堆内存始终保持在一个很低的水平。

    for (int i = 0; i < 10000; i++) {
        //在循环中自动释放的对象就会放在这个池，而不是在线程的主池里面
        @autoreleasepool {
            NSString *str = @"Zhang San";
            str = [str lowercaseString];
            str = [str stringByAppendingString:@"Li Si"];
            NSLog(@"%@",str);
        }
    }
#### 5.2 避免无意间误用那些在清空池之后已被系统回收的对象,
        @autoreleasepool {
            id obj = [[NSObject alloc]init];
        }
        [self useObject:obj];
        在编译时就会基于错误警告，因为obj出了自动释放池就不可用了。
#### 6 总结
####  自动释放池排布在栈中，对象受到autorelease消息后，系统将其放入栈顶的池里;自动释放池的机制就像“栈”。系统创建好池之后，将其压入栈中，而清空自动释放池相当于将池从栈中弹出。在对象上执行自动释放操作，
就等于将其放入位于栈顶的那个池;
    
#### 7.AutoreleasePool与NSThread、NSRunLoop的关系
#### 7.1 RunLoop和NSThread的关系
1. RunLoop与线程是一一对应关系,每个线程(包括主线程)都有一个对应的RunLoop对象,其对应关系保存在一个全局的Dictionary里；
2. 主线程的RunLoop默认由系统自动创建并启动；而其他线程在创建时并没有RunLoop，若该线程一直不主动获取，就一直不会有RunLoop；
3. 苹果不提供直接创建RunLoop的方法；所谓其他线程Runloop的创建其实是发生在第一次获取的时候，系统判断当前线程没有RunLoop就会自动创建；
4. 当前线程结束时，其对应的Runloop也被销毁；

#### 7.2 RunLoop和AutoreleasePool的关系
#### 主线程的NSRunLoop在监测到事件响应开启每一次event loop之前，会自动创建一个autorelease pool，并且会在event loop结束的时候执行drain操作，释放其中的对象。

#### 7.3 Thread和AutoreleasePool的关系
#### 包括主线程在内的所有线程都维护有它自己的自动释放池的堆栈结构。新的自动释放池被创建的时候，它们会被添加到栈的顶部，而当池子销毁的时候，会从栈移除。对于当前线程来说，Autoreleased对象会被放到栈顶的自动释放池中。当一个线程线程停止，它会自动释放掉与其关联的所有自动释放池。

#### 8. AutoreleasePool在线程上的释放时机
#### 8.1 主线程上自动释放池的使用过程如下
1. App启动后，苹果在主线程RunLoop里注册了两个Observer
2. 第一个Observer监视的事件是Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush()创建自动释放池
3. 第二个Observer监视了两个事件

        BeforeWaiting(准备进入休眠)时调用_objc_autoreleasePoolPop()和_objc_autoreleasePoolPush()释放旧的池并创建新池；
        Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop()来释放自动释放池。
4. 在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop创建好的AutoreleasePool环绕着，所以不会出现内存泄漏，开发者也不必显示创建AutoreleasePool了;

6. 程序启动到加载完成后，主线程对应的RunLoop会停下来等待用户交互
7. 用户的每一次交互都会启动一次运行循环，来处理用户所有的点击事件、触摸事件。
8. RunLoop检测到事件后，就会创建自动释放池;
9. 所有的延迟释放对象都会被添加到这个池子中;
10. 在一次完整的运行循环结束之前，会向池中所有对象发送release消息，然后自动释放池被销毁;

#### 8.2 AutoreleasePool子线程上的释放时机
#### 子线程默认不开启RunLoop,那么其中的延时对象该如何释放呢?依然要从Thread和AutoreleasePool的关系来考虑：每一个线程都会维护自己的 Autoreleasepool栈，所以子线程虽然默认没有开启RunLoop，但是依然存在AutoreleasePool，在子线程退出的时候会去释放autorelease对象。所以，一般情况下，子线程中即使我们不手动添加自动释放池，也不会产生内存泄漏。

### 9. AutoreleasePool需要手动添加的情况
#### 尽管ARC已经做了诸多优化，但是有些情况我们必须手动创建AutoreleasePool，而其中的延时对象将在当前释放池的作用域结束时释放.苹果文档中说明了三种情况，我们可能会需要手动添加自动释放池：
1. 编写的不是基于UI框架的程序，例如命令行工具；
2. 通过循环方式创建大量临时对象；
3. 使用非Cocoa程序创建的子线程；

#### https://www.jianshu.com/p/7bd2f85f03dc

    

#### 1.方法调用四种种方式
1. [testObject testMethod];
2. [self perform(<#T##aSelector: Selector!##Selector!#>, with: <#T##Any!#>)]
3.  1) 通过方法调用者创建方法签名,
     2) 然后通过方法签名生成NSInvocation对象
     3) 设置方法调用者，方法选择器，方法参数
     4) 执行并获取返回值
     
            方法一
            [self eat];
            方法二
            [self performSelector:@selector(eat)];
            方法三
            [self loadMethod];

            -(void)loadMethod {
                //1.通过方法调用者创建方法签名
                NSMethodSignature *sign = [[self class] instanceMethodSignatureForSelector:@selector(eat)];
                //2.通过方法签名生成NSInvocation
                NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:sign];
                //3.设置方法调用者和方法选择器
                invocation.target = self;
                invocation.selector = @selector(eat);
                //4.有参数的话设置参数 设置的参数必须从2开始；因为0和1 已经被self ,_cmd 给占用了
            //    NSString *foodName = @"面条";
            //    [invocation setArgument:&foodName atIndex:2];
                //5.执行
                [invocation invoke];
                //6.判断方法返回是否有返回值
                NSUInteger signLength = sign.methodReturnLength; //方法签名返回值长度
                id returnValue;
                if (signLength == 0) {
                    //NSLog(@"该方法没有返回值");
                }else {
                    //这里默认所有返回值均为OC对象
                    if (strcmp(sign.methodReturnType, "@") == 0) {
                        [invocation getReturnValue:&returnValue];
                    }
                }
            }

            -(void)eat {
                NSLog(@"被调用了");
            }
4. 创建个数组，并将对象放到数组中，然后调用KVC中的valueForKey:方法，将方法作为Key传递进去，这样就可以给对象发送消息了，即实现了方法调用
#### 2. 递归写算法1到100的和；时间复杂度是多少？递归缺点？不用递归能实现吗？时间复杂度能否降低到O(1)
    /*
    递归方法时间复杂度：O(n),
    递归缺点就是效率低：
    递归是函数调用，每次函数调用都需要在内存栈中分配空间来保存参数、返回地址以及临时变量，而往栈中压入数据和弹出数据都
    需要时间调用栈可能会溢出，每一次函数调用会在内存栈中分配空间，每个进程的栈的容量是有限的，当调用的层次太多时，
    就会超出栈的容量，从而导致栈溢出
    */
    private func getSum(value: Int) -> Int {
        guard value > 0 else {
            return 0
        }
        return value + getSum(value: value-1)
    }
    //非递归方法 时间复杂度O(n)
    private func getSum1(value: Int) -> Int {
        guard value > 0 else {
            return 0
        }
        var resultTotal = 0
        for i in 1...value {
            resultTotal += i
        }
        return resultTotal
    }
    //不用递归的方式：时间复杂度O(1)
    private func getSum2(value: Int) -> Int {
        guard value > 0 else {
            return 0
        }
        return (1+value)*value/2
    }
#### 3.property的作用是什么，有哪些关键词，分别是什么含义？
#### 用property可以直接调用属性，不需要我们再写set/get方法，系统已经帮我们实现了，@property的实质就是生成 _var +set +get方法(成员变量+set/get方法，添加实例变量有个前提，就是对象还没有同名的成员变量；如果我们同时自定义了属性的set和get方法，那么就不会再生成实例变量了)；property有两个对应的词，@synthesize和@dynamic
1. @synthesize：(1)ARC下很少使用了，因为都会生成set/get方法；在 MRC 下只有@synthesize name这样，编译器才会自动合成name的set/get存取方法;(2)如果不喜欢生成的实例变量名称，可以@synthesize  newName = name,即给实例变量起个别名，但是name的存取方法不会改变的。但一般不建议这么用
2. @dynamic：(1)告诉编译器,属性的setter/getter方法由用户自己实现，编辑器不再自动生成且不要自动生成对应的成员变量，即便我们没有手动实现，编辑阶段也不会报错，因为编辑器认为我们运行过程中会实现，但是如果我们确实没有实现并且调用了，那么运行就会报错“-[XXX setStr:]: unrecognized selector sent to instance 0x10040af10”;(2)如果我们子类中声明(重写)了和父类相同的属性名，编辑器就会警告，因为它不知道该在父类还是子类中实现set/get方法，如果在子类的.m文件中@dynamic name；那么系统就不会再为子类生成set/get方法了，这样就可以明确了
3. 如果@synthesize和@dynamic都没写，那么默认的就是@syntheszie var = _var;

#### 4. NSString、NSArray、NSDictionary应该如何选关键词？
#### 首先我们先看下面有关NSString的例子
    //.h文件
    @interface WGMainObjcVC : UIViewController
    @property(nonatomic, strong) NSString *nameStrong;
    @property(nonatomic, copy) NSString *nameCopy;
    @end
    //.m文件
    - (void)viewDidLoad {
        [super viewDidLoad];
        NSString *str = @"iphone";
        str = @"sdfasdfasdfasdf";
        self.nameCopy = str;
        self.nameStrong = str;
        str = @"123";
        NSLog(@"str:%@-地址:%p---nameStrong:%@-地址:%p---nameCopy:%@-地址:%p", 
        str, str, _nameStrong, _nameStrong, _nameCopy, _nameCopy);
    }
    当源字符串(str)是不可变的NSString类型，打印结果
    str:123-地址:0x109253658---nameStrong:sdfasdfasdfasdf-地址:0x109253638---
    nameCopy:sdfasdfasdfasdf-地址:0x109253638
        
    总结: copy或strong修饰的属性的内存地址都是一样的，都是指向了str的内存地址，而str的引用计数此时
    就是3，copy或strong修饰的属性并没有拷贝一份，所以nameCopy和nameStrong会随着str的改变而改变，即都进行了浅拷贝
    
    NSMutableString *str = [NSMutableString stringWithString:@"iphone"];
    self.nameCopy = str;
    self.nameStrong = str;
    [str appendString:@"X"];
    NSLog(@"str:%@-地址:%p---nameStrong:%@-地址:%p---nameCopy:%@-地址:%p",
    str, str, _nameStrong, _nameStrong, _nameCopy, _nameCopy);
    
    当源字符串(str)是可变的NSMutableString类型，打印结果
    str:iphoneX-地址:0x600003b1c900---nameStrong:iphoneX-地址:0x600003b1c900---
    
    nameCopy:iphone-地址:0x961fde0267f16d72
    总结：strong修饰的属性地址和源字符串的地址一样，即修饰的属性只是使str的引用计数+1，而内存地址依旧指向源字符串，
    所以会随着str的改变而改变(进行了浅拷贝)；
    
    而copy修饰的属性是（进行了深拷贝并生成了一个新的对象，nameCopy就指向了这个新对象）直接拷贝了一份str的内容，
    两者内存地址是不一样的，所以即便str改变了，copy修饰的属性也不会改变
        
#### 总结，综上所属，一般我们声明NSString类型属性的时候，如果不希望属性中途被改变(因为来源可能是NSMutableString)，那么选择copy可以进行深拷贝；如果我们确定来源是不可变的NSString类型，那么使用Strong或者copy都可以，但是，但是推荐使用Strong,因为copy修饰的NSString在进行set操作时，底层进行了这样的判断if ([str isMemberOfClass: [NSString class]])，如果来源是可变的，就进行一次深拷贝，如果是不可变的就和strong修饰一样，进行一次浅拷贝，如果项目中用的比较多的话，可能会影响性能；深拷贝就是拷贝的内容，浅拷贝就是拷贝的地址

        @interface WGMainObjcVC : UIViewController

        @property(nonatomic, strong) NSArray *arrStrong;
        @property(nonatomic, copy) NSArray *arrCopy;

        @end

        NSArray *arr = @[@"12",@"sdfa"];
        self.arrStrong = arr;
        self.arrCopy = arr;
        NSLog(@"arr:%@-地址:%p\narrStrong:%@-地址:%p\narrCopy:%@-地址:%p",
        arr, arr, _arrStrong, _arrStrong, _arrCopy, _arrCopy);

        打印结果：
        arr:(12, sdfa)-地址:0x600003177020
        arrStrong:(12, sdfa)-地址:0x600003177020
        arrCopy:(12,sdfa)-地址:0x600003177020
         
        分析：当源数组是不可变数据时，copy和strong修饰的属性的地址都指向了arr,其实就是都进行了浅拷贝，即指针拷贝
      
        NSMutableArray *arr = [NSMutableArray arrayWithArray:@[@"12",@"sdfa"]];
        self.arrStrong = arr;
        self.arrCopy = arr;
        [arr addObject:@"000"];
        NSLog(@"arr:%@-地址:%p\narrStrong:%@-地址:%p\narrCopy:%@-地址:%p",
        arr, arr, _arrStrong, _arrStrong, _arrCopy, _arrCopy);
        
        打印结果:
        arr:(12,sdfa,000)-地址:0x600001018d50
        arrStrong:(12,sdfa,000)-地址:0x600001018d50
        arrCopy:(12,sdfa)-地址:0x600001eb6560
        
#### 分析：当源数组是NSMutableArr时，使用Strong进行的是浅拷贝，即进行内容地址的拷贝，所以Strong修饰的属性的地址和str是一样的，会随着str值的改变而改变；而copy修饰的属性进行的是深拷贝，即进行的是内容的拷贝，即将拷贝的内容赋值给了新的对象，所以它不会随着str值改变而改变；声明NSArray时，如果不希望它中途被改变，并且来源可能是NSMutableArray时，要使用copy来修饰，进行一次深拷贝，即拷贝源的内容，而地址是用新的内存地址，这样数组内容就不会随源数组的改变而改变了；如果确定源数组是不可变的NSArray类型，那么使用copy和strong效果是一样的，都进行了一次浅拷贝，即内存地址都是一样的，但建议使用strong，因为copy修饰的NSArray在进行set时多了一层判断，if ([str isMemberOfClass: [NSArray class]])，比较消耗性能；如果来源是可变的，那么使用copy修饰的话就会进行一次深拷贝
* 1.copy修饰NSArray:如果源数组是不可变的，则内存地址和源数组内存地址是一样的，即进行的是浅拷贝，会随着源数据的改变而改变；如果源数组是可变的，则进行的是深拷贝，即将源数组的内容拷贝一份，赋值给新的内存地址，不会随着源数据的改变而改变
* 2.Strong修饰的NSArray，无论源数据是可变的还是不可变的，进行的都是浅拷贝，即内存地址和源数据的内存地址是一样的
        
#### 需要注意的就是下面的情况，如果源数组是可变的NSMutableArray类型，那么使用Copy，确实进行了深拷贝，但是目标数组中的元素的内存地址和源数组中元素的内容地址仍然是一样的，如果改变了源数组中元素的内容，目标数组中的值也是会被改变的

    WGTestModel *mode1 = [[WGTestModel alloc]init];
    mode1.name = @"zhangsan";
    mode1.age = 18;
    NSMutableArray *arr = [NSMutableArray arrayWithObjects:mode1, @"8888", nil];
    self.arrStrong = arr;
    self.arrCopy = arr;
    NSLog(@"arr:%@-地址:%p\narrStrong:%@-地址:%p\narrCopy:%@-地址:%p",
    arr, arr, _arrStrong, _arrStrong, _arrCopy, _arrCopy);

    打印结果:arr:( "<WGTestModel: 0x600003091320>", 8888 )-地址:0x600003e44900
                arrStrong:("<WGTestModel: 0x600003091320>",8888)-地址:0x600003e44900
                arrCopy:("<WGTestModel: 0x600003091320>",8888)-地址:0x600003091340
    分析: 从打印结果中可以看出arrCopy的内存地址和源数组的内容地址确实不一样，即进行了深拷贝，但是它里面元素的内容地址
    源数组中元素的内存地址是一样的，那么我们修改源数组中元素的内容，那么目标数组arrCopy中的元素是也会改变的
    
    WGTestModel *mode1 = [[WGTestModel alloc]init];
    mode1.name = @"zhangsan";
    mode1.age = 18;
    NSMutableArray *arr = [NSMutableArray arrayWithObjects:mode1, @"8888", nil];
    self.arrStrong = arr;
    self.arrCopy = arr;
    //修改源数组arr中元素mode1中的内容
    mode1.name = @"lisi";
    mode1.age = 20;
    NSLog(@"arr:%@-地址:%p\narrStrong:%@-地址:%p\narrCopy:%@-地址:%p-元素内容:name:%@-age:%d",
    arr, arr, _arrStrong, _arrStrong, _arrCopy, _arrCopy,mode1.name,mode1.age);
        
    打印结果
    arr:("<WGTestModel: 0x60000324e3c0>",8888)-地址:0x600003c99dd0
    arrStrong:("<WGTestModel: 0x60000324e3c0>",8888)-地址:0x600003c99dd0
    arrCopy:("<WGTestModel: 0x60000324e3c0>",8888)-地址:0x60000324e3e0-元素内容:name:lisi-age:20

    分析：可以发现如果改变源数组中元素的内容，那么copy修饰的数组虽然进行了深拷贝，但是它里面元素的内容也会随着改变，那么如何避免那？
#### 想要避免上面情况，就需要将数组元素中的模型类实现NSCopying和NSMutableCopying协议
        //.h文件
        @interface WGTestModel : NSObject
        @property(nonatomic, strong) NSString *name;
        @property(nonatomic, assign) int age;
        @end

        //.m文件
        @interface WGTestModel()<NSCopying, NSMutableCopying>
        @end
        @implementation WGTestModel

        -(id)copyWithZone:(NSZone *)zone {
            WGTestModel *model = [[[self class] allocWithZone:zone] init];
            model.name = [self.name copyWithZone:zone];
            model.age = self.age;
            return model;
        }
        -(id)mutableCopyWithZone:(NSZone *)zone {
            return [self copyWithZone:zone];
        }
        @end

        WGTestModel *mode1 = [[WGTestModel alloc]init];
        mode1.name = @"zhangsan";
        mode1.age = 18;
        NSMutableArray *arr = [NSMutableArray array];
        NSMutableArray *tempArr = [NSMutableArray arrayWithObjects:mode1, nil];
        for (WGTestModel *model in tempArr) {
            [arr addObject:[model copy]];
        }
        self.arrStrong = arr;
        self.arrCopy = arr;
        //修改源数组arr中元素mode1中的内容
        mode1.name = @"lisi";
        mode1.age = 20;

        NSLog(@"arr:%@-地址:%p\narrStrong:%@-地址:%p\narrCopy:%@-地址:%p-元素内容:%@",
        arr, arr, _arrStrong, _arrStrong, _arrCopy, _arrCopy,((WGTestModel *)_arrCopy[0]).name);
              
        打印结果:
        arr:("<WGTestModel: 0x600003e5e1c0>")-地址:0x6000030134e0
        arrStrong:("<WGTestModel: 0x600003e5e1c0>")-地址:0x6000030134e0
        arrCopy:("<WGTestModel: 0x600003e5e1c0>")-地址:0x600003c40620-元素内容:zhangsan
#### 同理对于NSDictionary也是一样的

#### 5. copy和muteCopy有什么区别，深复制和浅复制是什么意思，如何实现深复制？
#### 首先我们要知道copy特点：修改源对象(副本对象)的属性和行为，不会影响副本对象(源对象)。一个对象可以通过copy或者muteCopy来创建一个副本对象
    NSString *str1 = @"123";
    NSString *strCopy = [str1 copy];
    NSString *strMutaCopy = [str1 mutableCopy];
    NSLog(@"str1:%@-%p\nstrCopy:%@-%p\nstrMutaCopy:%@-%p",
    str1,str1, strCopy, strCopy, strMutaCopy, strMutaCopy);
    
    打印结果: str1:123-0x1060fa618
            strCopy:123-0x1060fa618
            strMutaCopy:123-0x600000817000

    总结:copy进行的是浅拷贝，拷贝的是str1的地址；mutableCopy进行的是深拷贝，拷贝的是str1的内容到另一个新的内容地址中

#### 因为copy进行的是浅拷贝，那么修改str1的值，按理说strCopy值也会随着改变，因为浅拷贝拷贝的是内存地址，那么我们验证一下
    NSString *str1 = @"123";
    NSLog(@"str1:%@-%p",str1, str1);
    NSString *strCopy = [str1 copy];
    NSString *strMutaCopy = [str1 mutableCopy];
    str1 = @"666";  
    NSLog(@"str1:%@-%p\nstrCopy:%@-%p\nstrMutaCopy:%@-%p",
    str1,str1, strCopy, strCopy, strMutaCopy, strMutaCopy);
    
    打印结果: str1:123-0x100b59618
            str1:666-0x100b59658
            strCopy:123-0x100b59618
            strMutaCopy:123-0x600000d0fb40
    我们会发现当改变源对象str1的时候，strCopy的值并没有改变,并且对str1重新赋值的时候，str1又进行了浅拷贝，
    即str1的内存地址改变了；这种情况就得用使用copy的特点来解释了，修改源对象或者副本对象，并不会改变副本对象或者源对象；
#### copy是浅拷贝，即不同的指针(str1和strCopy)指向了同一个地址，那么为什么修改str1的内容，strCopy却没有变化，不是指向了同一个地址吗？并且修改str1后，str1的内存地址就也改变了？首先当执行[str1 copy]时，str1和strCopy都是不可变的，指向了同一个内存空间中的@“123”，为了性能优化，系统没必要提供新的内存空间，只生成另一个指针，指向同一块内容空间就行；当str1 = @"666"重新给str1赋值时，因为之前的内容不可变，还有互不影响的原则，所以系统会重新开辟一个内存空间


#### 问题2: 数组拷贝
    NSArray *arr = @[@"123"];
    NSArray *arrCopy = [arr copy];
    NSMutableArray *arrMutaCopy = [arr mutableCopy];
    NSLog(@"arr:%@-%p\narrCopy:%@-%p\narrMutaCopy:%@-%p",
    arr,arr, arrCopy, arrCopy,arrMutaCopy,arrMutaCopy);
    打印结果: arr:(123)-0x600001efa800
            arrCopy:(123)-0x600001efa800
            arrMutaCopy:(123)-0x6000012aa070
            
    分析：copy进行的是浅拷贝，因为内存地址和源数组内存地址一样；mutableCopy进行的深拷贝，拷贝了内容后重新赋值给新的内存地址
     
    NSArray *arr = @[@"123"];
    NSLog(@"arr:%@-%p",arr,arr);
    NSArray *arrCopy = [arr copy];
    NSMutableArray *arrMutaCopy = [arr mutableCopy];
    arr = @[@"666"];
    NSLog(@"arr:%@-%p\narrCopy:%@-%p\narrMutaCopy:%@-%p",
    arr,arr, arrCopy, arrCopy,arrMutaCopy,arrMutaCopy);
    
    打印结果:arr:(123)-0x60000015ead0
           arr:(666)-0x60000015eb00
           arrCopy:(123)-0x60000015ead0
           arrMutaCopy:(123)-0x600000df8030
    分析:当修改arr后，arrCopy的值并没有随着arr的改变而改变，遵循copy的特点，源数据改变并不能改变目标数据；
    而改变arr值后arr的地址改变了，因为之前的arr和copy指针指向了同一个内存地址，并且都是不可变的，那么系统为了性能，
    就重新开辟新的内存空间来存放新设置的值

#### 浅拷贝，不拷贝对象本身，仅仅是拷贝指向对象的指针。深拷贝，是直接拷贝整个对象内存到另一块内存中。 有什么看法？浅拷贝，不拷贝对象本身，仅仅是拷贝指向对象的指针。不够严谨，在一些特殊情况下，还是会拷贝整个对象内存到另一块内存中。
#### 总结：
1. 用copy修饰的 或者赋值的 变量肯定是不可变的。
2. 用copy赋值，要看源对象是否是可变的，来决定拷贝指针，还是也拷贝对象到另一块内存空间
3. 对象之间mutableCopy赋值，肯定会拷贝整个对象内存到另一块内存中，即进行了深拷贝
4. 对象之间赋值之后，再改变，遵循互不影响的原则

#### 6. 用runtime做过什么事情？runtime中的方法交换是如何实现的？
#### 7. 讲一下对KVC合KVO的了解，KVC是否会调用setter方法？
#### 8. __block有什么作用
#### 1.对于自动变量的值，在Block内是无法修改的，因为Block使用外部变量的时候，是在Block内创建了一个新的变量来接收这个外部变量的值，而对于static变量，在Block内是可以被修改的，因为在Block内存储的是static变量的指针，Block内是可以通过指针来修改静态变量的。而__block的作用就是允许在Block内修改外部自动变量的值，__block会把Block外部变量的地址从栈区放到堆区，这样在Block内就可以修改外部变量的值了；
#### 2. __block本身无法解决循环引用问题，但是我们可以手动在Block中将obj=nil置空来解决循环引用问题
#### 9. 说一下对GCD的了解，它有那些方法，分别是做什么用的？
#### GCD主要是用来处理多线程任务的，涉及到队列任务的概念，队列分为串行队列/并发队列/主队列/全局队列，而主队列是系统创建的串行队列，全局队列是系统创建的并发队列，任务又分为同步任务/异步任务，通过队列和任务的组合，将创建的任务放到队列里面来执行任务的；GCD中会涉及到GCD组DispatchGroup的概念，组就是将多个任务放在组中，实现异步调用的。
1. GCD组notify方法：当GCD组中所有的任务都完成后，才通知后续的任务执行，一般用于任务间依赖，例如任务C的完成依赖于任务A任务B的完成，该方法不会阻塞当前线程
2. GCD组wait方法：如果我们想控制组内任务的执行顺序，就可以使用该方法来实现，例如任务A-wait()-任务B-wait...该方法会阻塞当前线程
3. GCD中的信号量来显示任务间依赖，signal方法使信号量+1，wait(信号量为0时，阻塞wait后的任务执行，直到信号量值大于0)
4. 如果GCD中组的任务嵌套了异步任务，那么可以通过使用GCD组中的enter和leave方法来控制异步任务的完成，从而来真正控制组内任务的同步

#### 10. 对二叉树是否了解？

#### 11. ARC和MRC的区别，iOS是如何管理引用计数的，什么情况下引用计数加1什么情况引用计数减一？
#### 12. 在MRC下执行[object autorelease]会发生什么，autorelease是如何实现的？
#### 13. OC如何实现多继承？
#### 14. 对设计模式有什么了解，讲一下其中一种是如何使用的。
#### 15. 有没有哪个开源库让你用的很舒服，讲一下让你舒服的地方。
#### 16. 一张100*100，RGBA的png图像解压之后占多大内存空间。
#### 17. 题目：给定一个个数字arr，判断数组arr中是否所有的数字都只出现过一次。有没有办法进行优化?
#### 18. 给定一个Int型数组，用里面的元素组成一个最大数，因为数字可能非常大，用字符串输出。例如：输入: [3,30,34,5,9]，输出: 9534330

#### 19. 项目中有这么一个方法func findfile(dir: String suffix: String) -> [String] ，可以通过输入文件夹目录，和后缀检索出所需的文件。例如需要在某个文件中检索txt文件或者mp4文件，那就传入dir和suffix就行了。现在又有一些需求，例如需要检索utf8格式的txt或者h264编码的mp4，也会有一些例如查找最近一周更新过的文件这样的需求，你如何优化这个类，让它满足这些情况？


#### 20. 如果子视图超出父视图范围，那么点击子视图和父视图重叠位置时，哪个视图会响应事件？如果点击子视图超出父视图位置，会响应事件吗？如果不能响应事件如何做？如果我们希望点击父视图的区域时响应父视图事件，点击子视图时，响应子视图事件，怎么做？

#### 问题1：点击子视图和父视图重叠的位置时，子视图能响应事件而父视图不能，因为点击屏幕,首先调用RunLoop的source1(基于端口的系统事件)来唤醒RunLoop，然后RunLoop会将事件交给source0来处理，source0会把点击时生成的UIEvent事件交给UIApplication,然后通过UIWindow->VC的View->...>bigsupView->subView进行寻找最佳响应者，在找的过程中，找到bigsupView时，判断点击点在bigsupView上，然后继续找到subView，发现点击点subView上，所以事件就交给subView来处理了，所以subView能响应事件，而bigsupView不能响应事件,
#### 问题2：点击子视图超出父视图的位置时，子视图和父视图都不影响事件，因为在响应链中寻找最佳响应者时，找到bigsupView时，判断点击点不在bigsupView上，直接就返回了不再向下一级的subView寻找了，所以子视图和父视图都不会响应事件
#### 问题3: 如果点击超出父视图的子视图区域，想让子视图响应事件的话，就两种解决方式
1. 方式一：自定义bigsupView，并在bigsupView的类中重写系统的方法- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event，并设置为YES，该方法作用就是当响应链中找到父视图WGBigView时，判断点击点是否在WGBigView上，设置为YES，就表示点击点在父视图上，然后才会继续去subView中找，这样子视图就可以响应事件了

        public class WGBigView : UIView {
           //方式一：
           public override func point(inside point: CGPoint, with event: UIEvent?) -> Bool {
               return true
           }
        }
   
   2. 方式二: 继续方案一种的demo,在父视图WGBigView中重写系统方法- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event;在这个方法中遍历父视图WGBigView的子视图，如果点击点在子视图的范围内，就返回这个子视图作为最佳响应者，这样子视图就可以响应事件了
   
          public class WGBigView : UIView {
              //方法二：
              public override func hitTest(_ point: CGPoint, with event: UIEvent?) -> UIView? {
                    let view = super.hitTest(point, with: event)
                    if view == nil { //如果WGBigView的父视图没有找到最佳响应者，就遍历WGBigView的子视图
                        for sub in self.subviews {
                            //将当前点击的点从当前视图的坐标系中换算到sub的坐标系中
                            let point = sub.convert(point, from: self)
                            //判断点击点是否在sub的范围之内，如果在就返回这个子视图作为最佳响应者
                            if sub.bounds.contains(point) {
                                return sub
                            }
                        }
                    }
                    return view
                }
            }
#### 问题4，简单描述就是父视图范围在子视图范围内包含着，然后点击父视图范围响应父视图，点击父视图其他范围但是这个范围还在子视图中时，响应子视图事件。方案就是重写WGBigView类中的系统方法hitTest，然后先判断点击位置是否在父视图范围，如果在直接返回，如果不在再去遍历子视图

            public class WGBigView : UIView {
                public override func hitTest(_ point: CGPoint, with event: UIEvent?) -> UIView? {
                    //首先判断点是否在self上，如果在就响应事件，如果不在就继续下面的判断
                     if self.bounds.contains(point) {
                         return self
                     }
                     for sub in self.subviews {
                         let subPoint = sub.convert(point, from: self)
                         if sub.bounds.contains(subPoint) {
                             return sub
                         }
                     }
                    return nil
                }
            }
#### 21. swift中class和struct区别
1. class是引用类型; struct是值类型
2. 在初始化时，struct可直接把属性放在默认的构造器函数中进行赋值，而class则不能
3. 对class或者struct进行赋值(=)时，struct会拷贝一份完整的数据内容给新的变量(开辟了新的内存空间)，改变旧变量并不会影响新变量的内容；而class进行赋值(=)时，并不会拷贝一份完整的数据内容给新的变量，只是增加了原变量内存地址的引用(就是多个变量指向了同一块内存地址，并不会开辟新的内存空间)
4. class中的方法可以修改属性的值，而struct中的方法如果要修改属性的值，需要在方法前添加mutating关键字
5. class可以继承； struct不可继承
6. struct比class更**轻量级**，struct内存分配在**栈空间**; class内存分配在**堆空间**

#### 21.1 struct作为数据模型的注意点：
* 优点:
1. 安全性：Struct是用值类型传递的，它们没有引用计数。
2. 不存在内存泄露: 没有引用数，所以不会因为循环引用导致内存泄漏
3. 速度快:值类型通常以栈的形式分配内存空间的
4. 线程安全: 值类型是自动线程安全的,无论从哪个线程去访问你的Struct，都非常简单。
* 缺点:
1. 混合开发(OC+swift)时，OC代码中无法调用Swift的Struct,因为在OC中调用swift代码，需要swift中对象继承自NSObject
2. 不能继承
3. NSUserDefaults: Struct不能被序列化成NSData对象。
#### 建议:如果模型较小，并且无需继承、无需储存到NSUserDefault或者无需Objective-C使用时，建议使用 Struct。
#### 21.2 为什么访问struct会比class快？
1. 栈内存空间是在程序启动时，系统事先分配的，使用过程中系统不干预；在编译时分配空间
2. 堆是用的时候才向系统申请的，用完了需要交还；申请和交还的过程开销就大了；在运行时分配空间
3. 堆在分配和释放时都要调用函数（MALLOC,FREE)，分配时会到堆空间去寻找足够大小的空间，都需要花费一定时间，而栈却不需要这些
4. 访问堆的一个具体单元，需要两次访问内存，第一次得取得指针，第二次才是真正得数据，而栈只需访问一次。


### 22 语言组织
1. runloop相关
runloop其实就是内部维护了一个事件循环来保证程序持续运行，监听事件等，主线城的runloop是系统自动创建并开启的，子线程runloop默认是没有的
只有在获取的时候系统才会创建子线程的Runloop，iOS中runloop获取可以通过CFRunloop和NSRunloop，CFRunloop是Core Foundation框架下的基于C语言的API，
是线程按钮的；NSRunloop是对CFRunloop的封装，提供了面向对象的API，是线程不安全的，RunLoop包含4种运行模式，其中常见的就是Default/trucking/Common
三种运行模式，其中common其实就是个占位模式，trucking优先级比Default优先级高，Runloop内部包含若干个model,每个model包含若干
个source0/source1/timers/observer/ source0用于处理交互触摸事件 source1是基于port端口的线程间通信 timers是处理定时器事件
 observer主要就是监听runloop在当前model下的运行状态，运行状态有6个(即将进入runloop/即将处理timer/即将处理source/即将休眠/即将从休眠唤醒/退出)，
runloop同一时间只能有一个model运行，如果model不存在或者model种不存在source/timer/observer那么runloop就会退出主线程runloop不会
退出和销毁 子线程的runloop在子线程销毁的时候会销毁 runloop是存储在系统全局的NSDictionary字典中，以线程作为key,以runloop作为value存储的
线程和runloop是一一对应的关系
    
    
### 23 atomic和@synchronized区别
* atomic内部是一个自旋锁，即等待锁的线程会一直处于等待状态，比较消耗性能
* atomic也不一定是线程安全的，只有在读取和设置即调用属性的setter/getter方法才是线程安全的
* @synchronized底层其实是递归锁，递归锁允许同一个线程对一把锁进行重复加锁，而不会产生死锁
* @synchronized底层的递归锁其实内部是调用了objc_sync_enter/objc_sync_exit方法
    
### 24.手写读写锁

    //方式一: 调用读写锁的API
    @property(nonatomic, assign) pthread_rwlock_t lock;
    //初始化读写锁
    pthread_rwlock_init(&_lock, NULL);

    -(void)__read{
        pthread_rwlock_rdlock(&_lock);  //读 - 加锁
        sleep(1.0);
        NSLog(@"%s",__func__);
        pthread_rwlock_unlock(&_lock); //读 - 解锁
    }

    -(void)__write {
        pthread_rwlock_wrlock(&_lock);  //写 - 加锁
        NSLog(@"%s",__func__);
        pthread_rwlock_unlock(&_lock); //写 - 解锁
    }
    
    //方式二: 通过栅栏函数
    //1. 手动创建的并发队列
    self.queue = dispatch_queue_create("myqueue", DISPATCH_QUEUE_CONCURRENT);
    for (int i = 0; i < 10; i++) {
        [self read];
        [self write];
    }
    
    -(void)read {
        dispatch_async(self.queue, ^{   //2.读时
            sleep(1);
            NSLog(@"read");
        });
    }
    -(void)write {
        //3.写时: 调用dispatch_barrier_async函数
        dispatch_barrier_async(self.queue, ^{  
            sleep(1);
            NSLog(@"write");
        });
    }
    
### 24.NSNotificationCenter 跨线程及底层结构是怎样的？
####  NSNotificationCenter通知中心底层是一个结构体，里面存储了wildCard链表/name表/nameless表，根据通知名称name和携带对象object
来决定具体操作那么链表或表结构的，NSNotificationCenter发送通知和接收通知都在同一个线程中，跨线程调用的话可以使用通知队列NotificationQueue来
达到异步通知的效果，但其实并不是异步通知，而是延迟了发送通知的时机，通知队列底层需要借助runloop实现
    
### 25.自旋锁和互斥锁怎么选择？
* 自旋锁：等待锁的线程会处于忙等状态，比较消耗系统资源；
* 互斥锁: 等待锁的线程会处于休眠状态，直到锁释放
 互斥锁：等待锁的线程会处于休眠状态
 使用场景：
 1. 预计线程等待锁的时间很长
 2. 单核处理器
 3. 临界区有IO(文件读写)操作
 4. 临界区代码复杂或者循环最大
 5. 临界区竞争非常激烈
 
 自旋锁：等待锁的线程会一直处于忙等状态
 使用场景：
 1. 预计线程等待锁的时间很短(锁内的代码或者任务花费很少的时间,就可以用自旋锁,因为时间短,所以就不需要用互斥锁先进入睡眠,再唤醒,这样也比较消耗性能)
 2. 加锁的代码(临界区)经常被调用,但竞争情况不激烈(很少的线程来抢夺资源)
 3. CPU资源不紧张
 4. 多核处理器

### 26 NSTimer、CADisplayLink、dispatch_source_t 的优劣
#### 这三种都是定时器，但使用过程还是有区别的
1. NSTimer
* 优点: 使用方便、广泛使用
* 缺点: NSTimer的计时依赖于RunLoop,如果RunLoop在执行耗时操作，NSTimer会被延时触发，导致计时不够精确‌
* NSTimer会强引用目标对象，如果处理不当，可能会导致内存泄漏‌

2. CADisplayLink
* CADisplayLink基于屏幕刷新率，通常每秒刷新60次，适合需要高精度定时任务的场景，如动画和视频播放‌
* 与屏幕刷新同步‌：CADisplayLink的调用与屏幕刷新同步，不需要关心具体的延迟时间，适合UI相关的动画和显示内容‌
* ‌使用场景有限,CADisplayLink主要用于UI相关的任务，不适合所有类型的定时任务‌
* 依赖屏幕刷新率‌：CADisplayLink的触发频率受限于设备的屏幕刷新率，不适合需要独立频率的定时任务‌
3. dispatch_source_t
* ‌高精度和高效率‌：dispatch_source_t基于GCD（Grand Central Dispatch），不依赖RunLoop，可以提供高精度的定时任务，适合需要高精度计时的场景‌
‌* 独立于RunLoop‌：dispatch_source_t不依赖于RunLoop，可以在后台线程中独立运行，适合需要后台执行的任务‌
* 使用复杂‌：相比NSTimer和CADisplayLink，dispatch_source_t的使用更为复杂，需要一定的学习成本‌
* ‌资源消耗‌：虽然dispatch_source_t提供了高精度和独立性，但其资源消耗也相对较高，不适合所有场景‌

#### NSTimer适合简单的定时任务，但精度较低且可能引起内存泄漏
#### CADisplayLink适合UI相关的动画和显示内容，精度高且与屏幕刷新同步
#### ‌dispatch_source_t适合需要高精度和独立执行的任务，但使用复杂且资源消耗较高

### 27. NSMutableArray alloc 和 NSMutableArray alloc init区别
1. 在ARC环境下两种方式在内存管理上没有区别；     
2. 在非ARC环境下alloc init需要手动管理内存；而array方式则会自动管理内存(放在自动释放池中)

#### 延伸: alloc一个对象 和 alloc init区别
#### 







