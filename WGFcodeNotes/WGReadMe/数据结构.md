## 数据结构
#### 什么是数据结构?计算机存储以及组织数据的方式;简单理解为,有一堆数据,它们之间有些特殊的关系

#### 1. 数据结构逻辑上的分类
1. 集合结构: 一个集合中有多个元素,元素与元素之间没有任何关系-->**NSSet、NSMutableSet**
2. 线性结构: 一条线上有很多元素（直线、曲线），元素与元素之间是一对一的关系-->**NSArray、NSMutableArray**
3. 树形结构: 想象成金字塔的一种结构，其元素之间是一对多的关系
4. 图形结构: 无穷、无边、无向，任意图形，其元素之间是多对多的关系

#### 2. 数据结构存储上的分类
1. 顺序存储结构: 存储单元内存地址是连续的
2. 链式存储结构: 存储单元内存地址可以是连续的，也可以是不连续的。它不要求逻辑上相邻的元素在物理位置上也相邻

#### 3. 常见的数据结构
* 线性表(数组、栈、队列、链表、哈希表)
* 树
* 图


## 线性表
#### 线性表就是多个具有相同特性的数据元素(节点)组成的有序、有限的集合; 当线性表的节点个数为0时,称为空表; 线性表第一个节点称为**首节点**,最后一个元素称为**尾节点**

####  线性表的存储结构有两种
* 线性表的顺序存储结构: 用一组地址连续的存储单元依次存储线性表的数据元素, 例如**数据** 
* 线性表的链式存储结构: 用一组任意的存储单元存储线性表中的数据元素，它的存储单元可以是连续的，也可以是不连续的


#### 1. 线性表-数组
#### 数组是顺序存储的,数组中的元素存储在一块连续的内存地址中,数组是直接通过下标来查找、删除、插入元素的; 数组是**查询快、增删慢**的数据结构,查询直接通过下标查询即可,查询任意数据耗时相同,时间复杂度为O(1); 但是如果删除元素的话,要先将原始数据删除,同时删除元素后面的每个元素前移,删除效率低; 添加数据时,添加元位置后的每个元素后移,再添加元素,添加效率极低

#### 2 线性表-栈
#### 栈可以理解为只能在一端进行插入、删除的数据结构,栈的特点就是**先进后出**,或者叫做**后进先出**,例如我们生活中盛放物品的箱子,先放进去的最后才能拿出来,后放进去的可以最先拿出来, 主要涉及到**压/进栈**和**弹/出栈**, 栈低是封闭的,栈顶是开放的,即只能在栈顶进行数据操作; 出栈和进栈只会影响到最后一个元素

#### 3 线性表-队列
#### 队列在iOS中是一种常见的数据结构,例如NSOpeartionQueue、GCD中的各种队列,其特点就是**先进先出**,或者叫**后进后出**,例如我们生活中的排队买票,先进去买票的先出来,后进去的后出来; 主要涉及到**入队列**和**出队列**, 入队列的方向称为后端,出队列的方向称为前端

#### 4 线性表-链表
#### 链表是在物理上非连续、非顺序的数据结构,由若干个节点组成, 主要分为两种
1. 单向链表: 每个节点有两部分组成,一部分是存放数据的变量data; 一部分是指向下一个节点的指针next

        头节点                                                                        ^节点指向空地址表示结束
        [head+地址11] ---> [数据13+地址35] ---> [数据4+地址9] ---> [数据19+地址289] ---> ...... ---> [数据23+^]
2. 双向链表:  除了**data**和**next**指针,还有指向前置节点的 prev 指针
#### 链表是一种**增删快、查询慢**的数据结构(对比数组来说的),查询数据必须从头开始查找,链表查找的时间复杂度为O(n); 链表数据在内存中是随机存储,即每个节点分布在内存的不同位置,依靠**next**指针关联起来; 链表中的数据只能按照指针的方向进行顺序访问; 适合插入、删除操作比较频繁的场景

#### 5 线性表-哈希表
#### 哈希表也叫散列表,本质上是一个数组,提供了键(key)和值(value)的映射关系,这里有两个重要的概念
1. 哈希函数: 通过哈希函数,可以把字符串或其它类型的**Key**,转化成数组的下标**index**
2. 哈希冲突: 不通的**Key**通过**哈希函数**获得的下标有可能相同
#### 哈希表的基本操作
1. 写操作: 在表中插入新的键值对
2. 读操作: 通过给定的**Key** 在哈希表中查找对应的**Value**

#### 5.1 哈希冲突解决方案
       例如 h(k)=k%7, h(0)=h(7)=h(14)=...
1. 开放寻址法: 如果哈希函数返回的位置已经有值,则可以向后查找新的位置来存储这个值,这种方式一般不采用,主要是hash表满了,就没有空间了
2. 拉链法: 哈希表每个位置都连接一个链表，当冲突发生时，冲突的元素将被加到该位置链表的最后。查找的时候，先找到hash函数计算的位置，再在链表里找

#### 6. 线性表性能对比
            查找        更新      插入     删除
    数组     O(1)       O(1)     O(n)    O(n)
    链表     O(n)       O(1)     O(1)    O(1)
    栈       -           -       O(1)    O(1)
    队列                         O(1)    O(1)
    哈希表   O(1)       O(1)      O(1)    O(1)
    


## 二叉树
#### 二叉树是树形结构的一种重要类型，在实际开发中许多问题的数据结构都可以抽象成二叉树，并且其存储结构和算法都比较简单，所以开发中二叉树相当重要。那么二叉树最主要的特点就是每个结点最多有两颗子树，且有左右之分，分别为左子树和右子树。二叉树是N个有限元素的集合，该集合或者为空、或者由一个称为根（root）的元素及两个不相交的、被分别称为左子树和右子树的二叉树组成。
## 二叉树分类
### 1.满二叉树
#### 如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树
### 2.完全二叉树
#### 若设二叉树的高度为a(总共有a层)，除了最后一层a层外，其他1到a-1层的结点数都达到了最大个数，而a层有叶子结点，并且叶子结点都是从左到右依次排布的，可以排不满，但是必须是从左到右的顺序排序的；如果排满了这个数也就变成满二叉树了。所以我们可以说满二叉树一定是完全二叉树，但是完全二叉树不一定是满二叉树
### 3.二叉查找树（二叉搜索树/排序二叉树）
#### 所有子树上面左子树的值都比根结点上的值要小，所有子树上面右子树的值都比根结点上的值要大，任意结点的左右子树又都是二叉查找树。通过中序遍历二叉查找树可以得到一个有序的集合(递增)
### 4. 平衡二叉树
#### 满足查找二叉树的条件；它左右两个子树的高度差的绝对值不超过1，并且左右子树又都是平衡二叉树；当修改/新增/删除结点上的值时，它会通过左旋/右旋的方式使二叉树保持平衡，最坏的时间复杂度是O(log2n)。常见的平衡二叉树有AVL树、红黑树等

### 5. AVL树
#### 首先它本身是一个二叉查找树；带有平衡条件：每个结点的左右子树的高度之差的绝对值（平衡因子）最多为1。也可以说AVL树本质是一个带有平衡功能的查找树，增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。

### 6.红黑树
#### 满足二叉查找树的特点；节点是红色或者是黑色的；根结点一定是黑色的；每个叶子结点都是黑色的(叶子是NIL节点,NIL代表空结点)；每个红色节点必须有两个黑色节点。最重要的是对于每个结点，从该结点到子孙叶结点的所有路径包含相同数目的黑节点


## 二叉树存储方式
#### 二叉树存储方式主要是数组和链表两种存储方式，用数组存和访问速度快，但插入/删除操作就比较费时了。实际中更多的是用链来表示二叉树的。

## 二叉树遍历
### 二叉树遍历方式分为：
#### 1. 前序遍历：根结点->左子树->右子树
#### 2. 中序遍历：左子树->根结点->右子树
#### 3. 后序遍历: 左子树->右子树->根结点
#### 4. 层序遍历：按照层级顺序

## 代码实现二叉树基本操作
