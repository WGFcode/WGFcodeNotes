#### 1. 单例
#### 1.1单例的创建
        //.h文件
        @interface Person : NSObject
        +(instancetype)shareInstance;
        @end
        
        //.m文件
        static Person *p = nil;
        //单例方式一 也是线程安全的，不过苹果建议使用方式二GCD方式来创建单例，效率更高
        +(instancetype)shareInstance {
            @synchronized (self) {
                p = [[Person alloc]init];
            }
            return p;
        }
        // 单例方式二
        +(instancetype)shareInstance {
            static dispatch_once_t onceToken;
            dispatch_once(&onceToken, ^{
                p = [[Person alloc]init];
            });
            return p;
        }

        - (void)viewDidLoad {
            [super viewDidLoad];
            Person *p1 = [Person shareInstance];
            Person *p2 = [Person shareInstance];
            Person *p3 = [[Person alloc]init];
            Person *p4 = [Person new];
            NSLog(@"\np1: %p\np2: %p\np3: %p\np4: %p\n",p1, p2, p3, p4);
        }
        打印结果：p1: 0x600003960350
                p2: 0x600003960350
                p3: 0x600003960370
                p4: 0x600003960390

#### 我们发现通过shareInstance创建的Person对象的内存地址是一样的，而通过alloc/new方式创建的对象是个新的地址，为什么会不一样，难道单例创建的方式不对吗？其实我们只要通过shareInstance方法来创建对象就可以保证对象的唯一性，但是团队中可能有人会用初始化的方式来创建和访问，如何解决？

#### 我们知道创建对象一般分两步，1：alloc为了给对象分配内存；2：init是为了初始化对象。通过alloc+init方式创建对象时，实际调用的是allocWithZone方法来分配内存，所以为了保证单例对象只会创建一个，我们需要重写这个方法
        //.h文件
        @interface Person : NSObject
        +(instancetype)shareInstance;
        @end

        //.m文件
        static Person *p = nil;
        +(instancetype)shareInstance {
            static dispatch_once_t onceToken;
            dispatch_once(&onceToken, ^{
                p = [[Person alloc]init];
            });
            return p;
        }
        //保证通过Person的alloc+init方法创建的对象也能保证只创建了一个对象
        + (instancetype)allocWithZone:(struct _NSZone *)zone {
            static dispatch_once_t onceToken;
            dispatch_once(&onceToken, ^{
                p = [super allocWithZone:zone];
            });
            return p;
        }
        
        现在的打印结果: p1: 0x600000f94580
                     p2: 0x600000f94580
                     p3: 0x600000f94580
                     p4: 0x600000f94580
                     
#### 如果我们使用拷贝来创建对象copy、mutableCopy，为了保证单例创建的对象是唯一的，我们一般还需要重写copyWithZone、mutableCopyWithZone方法，但是这里有个条件，就是必须遵守NSCopying协议的类才能使用copy, 遵守NSMutableCopying协议的类才能使用mutableCopy，
        //.h文件
        @interface Person : NSObject<NSCopying, NSMutableCopying>
        +(instancetype)shareInstance;
        @end

        //.m文件
        static Person *p = nil;
        +(instancetype)shareInstance {
            static dispatch_once_t onceToken;
            dispatch_once(&onceToken, ^{
                p = [[Person alloc]init];
            });
            return p;
        }
        //保证通过Person的alloc+init方法创建的对象也能保证只创建了一个对象
        + (instancetype)allocWithZone:(struct _NSZone *)zone {
            static dispatch_once_t onceToken;
            dispatch_once(&onceToken, ^{
                p = [super allocWithZone:zone];
            });
            return p;
        }
        //保证通过copy创建的对象也是唯一的一个对象
        -(id)copyWithZone:(NSZone *)zone {
            return [Person shareInstance];
        }
        //保证通过mutableCopy创建的对象也是唯一的一个对象
        -(id)mutableCopyWithZone:(NSZone *)zone {
            return [Person shareInstance];
        }
#### 1.2 单例的销毁
#### 由于实际业务的需要，我们需要销毁单例，比如我们登录成功后的用户信息使用的是单例，当退出的时候，需要将用户信息的单例给销毁掉
        //.h文件
        @interface Person : NSObject
        +(instancetype)shareInstance;
        +(void)cleanInstance;
        @end
        
        //.m文件
        static Person *p = nil;
        static dispatch_once_t onceToken;
        +(instancetype)shareInstance {
            dispatch_once(&onceToken, ^{
                p = [[Person alloc]init];
            });
            return p;
        }
        //销毁单例，必须把static dispatch_once_t onceToken;写在函数的最外面，作为一个全局的静态变量
        +(void)cleanInstance {
            // 只有置成0,GCD才会认为它从未执行过.它默认为0,这样才能保证下次再次调用shareInstance的时候,再次创建对象.
            onceToken = 0;
            p = nil;
        }

#### 1.3 单例的优缺点
* 优点
1. 提供了应用唯一的实例对象，规范化统一管理资源，即提供了对唯一实例的受控访问。
2. 不用再频繁地创建和销毁对象，从而提高了系统的性能和节约系统资源。
3. 单例对象可以做到按需创建对象或加载资源，以节省不必要的内存。
4. 避免对共享资源的多重占用
* 缺点
1. 单例从创建后到彻底关闭程序前都会一直存在，如果过多的创建单例无疑浪费系统资源和影响系统效率。
2. 由于单利模式中没有抽象层接口，因此单例类很难再进行扩展。
3. 单例类的职责过重，在一定程度上违背了“单一职责原则”。
4. 单例对象长时间不被利用，系统有可能会认为是垃圾而被回收，这将导致当前单例对象状态的丢失。
