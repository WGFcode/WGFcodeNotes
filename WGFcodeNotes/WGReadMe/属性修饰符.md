## 属性修饰符
#### 一 iOS中属性修饰符主要有以下几种
1. copy
2. assign
3. strong
4. weak
5. readonly
6. readwrite
7. automic
8. nonautomic
9. retain

#### 如果按照ARC和MRC来区分的话，主要方式如下
    ARC: assign/retain/copy/readwrite/readonly/nonatomic/atomic
    MRC: assign/strong/weak/copy/readwrite/readonly/nonatomic/atomic

#### 1. assign修饰符
#### assign修饰符一般用来修饰基本数据类型(NSInteger/CGFloat/Int/Float/Double等)，被assign修饰的属性的setter方法是直接赋值的，不会进行任何retain操作,在MRC和ARC下都可以使用assign, 它的setter方法如下
        直接进行赋值操作
        -(void)setAge:(NSInteger)age {
            _age = age;
        }
#### 如果用assign修饰对象类型会如何那？
        @interface WGMainObjcVC()
        @property(nonatomic, assign) Person *p1;
        @end

        @implementation WGMainObjcVC
        - (void)viewDidLoad {
            [super viewDidLoad];
            
            self.p1 = nil;
            {
                Person *p0 = [[Person alloc]init];
                //p1是用assign修饰的，所以既不持有对象的强引用也不持有对象的弱引用
                self.p1 = p0;
                NSLog(@"p1的地址是：%@---p0的地址是:%@",self.p1, p0);
            }
            NSLog(@"p1的地址是：%@",self.p1);
        }
        @end
        
        打印结果: p1的地址是：<Person: 0x600003438430>---p0的地址是:<Person: 0x600003438430>
               编辑可以通过，但是在运行的时候会报错，报错信息如下
               message sent to deallocated instance 0x600003438430
#### 分析: 出了代码块后，p0因为超出作用域，所以会被销毁，那么p0指针指向的对象也会被销毁，而p1和p0指向了同一块内存，所以此时p1指针指向的对象也就跟着被销毁了，此时p1就是个野指针
* 野指针：指针指向的对象/内容已经被销毁了，即指针指向了一块“垃圾内存”；给野指针发销毁会crash的，野指针并不是nil指针
* 空指针：指的是没有存储任何内存地址的指针；给空指针发消息不回报错的；
* 僵尸对象： 一个OC对象引用计数为0被释放后就变成僵尸对象了，僵尸对象的内存已经被系统回收，虽然可能该对象还存在，数据依然在内存中，但僵尸对象已经是不稳定对象了，不可以再访问或者使用，它的内存是随时可能被别的对象申请而占用的。
#### 总结：assign一般用来修饰基本数据类型，如果修饰对象，会出现野指针的问题；assign和weak的区别：就是weak在对象销毁的时，会自动将对象置为nil，而assign不会从而导致野指针问题（对象销毁了，指针指向了一个垃圾内存）

#### 2. automic(原子属性)和nonautomic(非原子属性)
#### automic原子属性是线程安全的，即多线程访问能够保证数据的完整性，为什么是线程安全的？因为系统在automic属性的setter方法中添加了自旋锁来保证多线程访问的安全性，但是这样就耗费了系统资源。automic原子属性并不都是线程安全的，因为automic属性只有在setter/getter方法中是原子操作，是安全的，但是在setter/getter方法外不是原子操作的，例如++/--运算符情况下
#### nonautomic非原子属性，不是线程安全的，因为系统没有在属性的setter方法中添加自旋锁，它的特点是多线程并发访问性能高但不安全，所以nonatomic要注意多线程间通信的线程安全，项目中我们仍然会大量使用nonautomic非原子属性的原因也是因为访问性能高

        Runtime源代码 
        id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic) {
            if (offset == 0) {
                return object_getClass(self);
            }

            // Retain release world
            id *slot = (id*) ((char*)self + offset);
            if (!atomic) return *slot;

            // Atomic retain release world
            spinlock_t& slotlock = PropertyLocks[slot];
            slotlock.lock();   //加锁
            id value = objc_retain(*slot);
            slotlock.unlock();  //解锁
            
            // for performance, we (safely) issue the autorelease OUTSIDE of the spinlock.
            return objc_autoreleaseReturnValue(value);
        }

        using spinlock_t = mutex_tt<LOCKDEBUG>;
        class mutex_tt : nocopy_t {
            os_unfair_lock mLock;  //这是iOS10之后用到的互斥锁
        }
#### iOS 10之前automic是用的自旋锁, iOS 10之后使用的是os_unfair_lock，这是一把互斥锁！(因为自旋锁会导致优先级反转问题)，那么自旋锁和互斥锁的区别是什么那？
* 自旋锁: 自旋锁会忙等: 所谓忙等，即在访问被锁资源时，调用者线程不会休眠，而是不停循环在那里，直到被锁资源释放锁。自旋锁的优点在于，因为自旋锁不会引起调用者睡眠，所以不会进行线程调度，cpu时间片轮转等耗时操作。所有如果能在很短的时间内获得锁，自旋锁的效率远高于互斥锁,缺点在于，自旋锁一直占用CPU，他在未获得锁的情况下，一直运行－－自旋，所以占用着CPU，如果不能在很短的时 间内获得锁，这无疑会使CPU效率降低。自旋锁不能实现递归调用。
* 互斥锁: 互斥锁会休眠: 所谓休眠，即在访问被锁资源时，调用者线程会休眠，此时cpu可以调度其他线程工作。直到被锁资源释放锁。此时会唤醒休眠线程。互斥锁可以传入不同参数，实现递归锁

#### 3. retain
#### MRC下使用的，会是引用计数+1，但在ARC下已经被舍弃了，改用strong来修饰了,如果我们在ARC环境的工程中想让某些文件支持MRC，可以在Build Phaes—>Compile Sources—>XXX文件 找到对应文件配置 -fno-objc-arc来支持MRC

        setter方法释放旧对象，retain新对象
        -(void)setName:(NSString *)name {
            if (_name != name) {
                [_name release];
                _name = [name retain];
            }
        }
        
#### 4. strong
#### ARC环境下才使用的，对应MRC环境下的retain。表示对对象的强引用，对象的引用计数+1，只要有一个strong指针指向对象，该对象就不会被销毁，ARC 下不显式指定任何属性关键字时，基本数据默认的关键字是 atomic、readwrite、assign，普通的OC对象: atomic、readwrite、strong。


#### 5. readonly/readwrite
#### readonly声明你的属性是只读的，并且告诉编译器不用自动生成setter方法；当你尝试给一个readonly的属性赋值时，会Xcode提示错误； readwrite声明的属性是可读可写的，编译器会自动生成setter/getter方法；readwrite是默认的；

#### 关于属性的setter/getter方法问题
#### 一般我们声明@property属性时，系统会自动为我们生成对应的成员变量(也叫实例变量)+setter方法+setter方法，当我们使用@dynamic XXX，此时系统就不会生成XXX对应的setter/getter方法，如果我们自己又没有手动实现setter/getter方法，那么在调用存取方法时程序运行就会crash（编译期不会报错）；@synthesize XXX = _XXX,当我们@dynamic和@synthesize都没有写时，@property默认是@synthesize XXX = _XXX，@synthesize表示如果属性没有手动实现setter和getter方法，编译器会自动加上这两个方法，如果我们手动实现了setter/getter，那么系统就不会再自动生成setter/getter
        @interface Person : NSObject
        @property(nonatomic, strong) NSString *name;
        @end
        
        //@dynamic 告诉编辑器不自动生成name属性的getter和setter方法
        @implementation Person
        @dynamic name;   
        @end

        - (void)viewDidLoad {
            [super viewDidLoad];
            Person *p = [[Person alloc]init];
            //程序编译期不会报错，但在运行时会报错：因为@dynamic的声明，系统没有生成对应的setter/getter方法
            //reason: '-[Person setName:]: unrecognized selector sent to instance 0x600001d6a9a0'
            p.name = @"zhangsan";
        }


#### 6. weak 


#### 7. copy

