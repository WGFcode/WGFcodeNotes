## 分类和扩展

### 一.分类
#### 1. 分类就是在不改变原类的情况下,为原类添加方法、属性,分类是运行在编辑期的,而扩展是运行在运行期
        //Person类
        @interface Person : NSObject
        @property(nonatomic, strong) NSString *name;
        -(void)eat;
        @end
        
        @implementation Person
        -(void)eat {
            NSLog(@"Person am eating");
        }
        @end
        
        //Person扩展
        @interface Person (PersonCategory)
        //在扩展里面声明属性,编辑器会警告的,如果外部调用这个属性,编辑器就会报错,说找不到这个属性
        @property(nonatomic, strong)NSString *teachName;
        -(void)sleep;
        @end
        
        @implementation Person (PersonCategory)
        -(void)sleep {
            NSLog(@"PersonCategory am sleeping");
        }
        @end
#### 通过上面我们知道,分类里面不能添加属性,那么如果我们想添加属性怎么办? 答案是可以的,但是需要通过RunTime的关联属性来为扩展添加属性,这样外部用Person实例对象就可以通过点语法正常访问属性了
        //1.导入objc/runtime.h头文件
        #import <objc/runtime.h>
        @implementation Person (PersonCategory)
        
        //2. 利用RunTime重写teachName属性的getter/setter方法
        -(NSString *)teachName {
            return objc_getAssociatedObject(self, @"teachName");
        }

        -(void)setTeachName:(NSString *)teachName {
            objc_setAssociatedObject(self, @"teachName", teachName, OBJC_ASSOCIATION_COPY_NONATOMIC);
        }

        -(void)sleep {
            NSLog(@"I am sleeping");
        }
        @end
#### 2.分类为什么不能添加属性? 
#### 通过上面的例子,我们知道分类不能添加属性,只能利用RunTime特性来添加,那么iOS中为什么不能给分类添加属性?我们先来看下分类的底层实现
        表示一个指向分类的结构体的指
        typedef struct objc_category *Category;
        struct objc_category {
            char * _Nonnull category_name                            OBJC2_UNAVAILABLE; //分类名称
            char * _Nonnull class_name                               OBJC2_UNAVAILABLE; //类名称
            struct objc_method_list * _Nullable instance_methods     OBJC2_UNAVAILABLE; //实例方法列表
            struct objc_method_list * _Nullable class_methods        OBJC2_UNAVAILABLE; //类方法列表
            struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE; //分类所实现的协议列表
        }  
#### 分类底层结构体中没有属性列表、成员变量列表,这也就是分类中不能添加属性(和成员变量)的原因, 分类是在运行时,才会将分类中的数据合并到类信息中

#### 3. 如果分类和原类中声明并实现了相同的方法(方法名),为什么首先调用的是分类的方法?

        //Person类
        @interface Person : NSObject
        @property(nonatomic, strong) NSString *name;
        -(void)eat;
        @end

        @implementation Person
        -(void)eat {
            NSLog(@"Person am eating");
        }
        @end
        
        //Person扩展
        @interface Person (PersonCategory)
        -(void)eat;
        @end

        @implementation Person (PersonCategory)
        -(void)eat {
           NSLog(@"PersonCategory am eating");
        }
        @end
        
        Person *p = [[Person alloc]init];
        [p sleep];
        
        打印结果: PersonCategory am eating
#### 为什么优先调用分类中的方法,而不是原类中的方法,那么我们需要先了解分类的加载过程,
1. 通过RunTime加载某个类中所有分类(Category)中的数据
2. 把Category的方法、属性、协议数据，合并到一个大数组中,后面参与编译的Category数据，会在数组的前面,
3. 将合并后的分类数据（方法、属性、协议），插入到类原来数据的前面, 所以优先调用的是分类中方法
