//
//  WGSort.h
//  ZJKBank
//
//  Created by 白菜 on 2021/12/1.
//  Copyright © 2021 buybal. All rights reserved.
//
/*
 1.排序算法的稳定性: 如果相等的2个元素，在排序前后，相对位置保持不变，那么就是稳定的排序算法
 对自定义对象的排序，稳定性会影响最终的排序效果，
 稳定排序:冒泡排序
 2. 排序分类
            最好          最坏          平均        稳定性    空间复杂度
  冒泡排序   O(n)        O(n^2)        O(n^2)       YES       O(1)
  选择排序   O(n^2)      O(n^2)        O(n^2)       YES       O(1)
  插入排序   O(n)        O(n^2)        O(n^2)       YES       O(1)
  归并排序   O(nlogn)    O(nlogn)      O(nlogn)     YES       O(n)
  快速排序   O(nlogn)    O(n^2)        O(nlogn)      NO       O(logn)
  希尔排序   O(n)       O(n^(4/3)~n^2) 取决步长序列    NO       O(1)
  堆排序     O(nlogn)   O(nlogn)       O(nlogn)      NO       O(1)
  基数排序   O(d*(n+k))  O(d*(n+k))     O(d*(n+k))   YES      O(n+k)
  桶排序     O(n+k)      O(n+k)         O(n+k)       YES      O(n+k)
  计数排序   O(n+k)      O(n+k)         O(n+k)       YES      O(n+k)
 冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序属于比较排序
 */
#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

@interface WGSort : NSObject

/********************************冒泡排序*******************************
 冒泡排序
第一步: 从头开始比较每一对相邻的元素，如果第1个比第二个大，就交换它们的位置，执行完一轮后，最末尾那个元素就是最大的元素
第二步: 忽略第一步中找到的最大元素，重复执行第一步，直到全部元素有序
最坏、平均时间复杂度O(n^2)，最好的时间复杂度是O(n),属于稳定排序算法
*/
/// 冒泡排序1 -正常
-(void)sort_maopao1;
/// 冒泡排序2 - 优化1: 如果是已经排好序的数据，那么一轮循环后，应该终止排序
-(void)sort_maopao2;
/// 冒泡排序3 - 优化2: 如果数据序列尾部已经局部有序，可以记录最后一次交换的位置，来减少比较次数
-(void)sort_maopao3;




/********************************选择排序*******************************
 选择排序
第一步: 从序列中找出最大的那个元素，然后与最末尾的元素交换位置，执行完第一轮后，最末尾的元素就是最大的元素
第二步: 忽略第一步中找到的最大元素，重复执行第一步
选择排序的交换次数要远远少于冒泡排序，平均性能优于冒泡排序
最好、最坏、平均时间复杂度O(n^2),空间复杂度O(1),属于稳定排序算法
选择排序优化方案: 使用堆来找最大值
*/
/// 选择排序
-(void)sort_select;




/********************************插入排序*******************************
 插入排序（类似于扑克牌的排序）
第一步: 在执行过程中，插入排序会将序列分为两部分: 头部是已经排好序的，尾部是待排序的
 第二步: 从头开始扫描每一个元素，每当扫描到一个元素，就将它插入到头部合适的位置，使得头部数据依然保持有序
逆序对:数组 [2,3,8,6,1]的逆袭对有5对[2,1],[3,1],[8,6],[8,1],[6,1]
插入排序的时间复杂度与序列的逆序队数量成正比关系，逆序对的数量越多，插入排序的时间复杂度越高
当逆序对的数量极少时，插入排序的效率特别高，速度甚至比O(logn)级别的快速排序还要快
最坏、平均时间复杂度O(n^2)，最好的时间复杂度是O(n),空间复杂度O(1),属于稳定排序算法
*/
/// 插入排序-正常
-(void)sort_insert1;

/// 插入排序-优化1
-(void)sort_insert2;

///插入排序的优化方案二中需要用到二分搜索，先了解下二分搜索思路
/* 二分搜索
 如何确定一个元素在数组中的位置？
 如果是无序数组，从第0位置开始遍历去查找，时间复杂度是O(n)
 如果是有序数组，可以使用二分搜索，最坏的时间复杂度是O(logn)
 二分搜索思路：假设在[begin,end)范围内搜索某个元素V，mid = (begin + end) / 2,mid位置的元素值是m
    如果v < m,去[begin, mid)范围内二分搜索
    如果v > m,去[mid + 1, end)范围内二分搜索
    如果v = m,直接返回mid
 */
/// 查找V在有序数组array中的位置 返回位置下标
-(int)binarySearchWithElement:(int)element inArr:(NSMutableArray *)arr;


/* 在元素V的插入过程中，可以先二分搜索出合适的位置，然后再将元素V插入
    0   1   2   3   4   5    6     7
    2   4   8   8   8   12   14
要求二分搜索返回的插入位置：第一个大于V的元素位置 ，如果V=5，返回下标2；如果V=15，返回7；如果V=1，返回0；如果V=8，返回5
 */
/// 插入排序-优化2-二分搜索优化
-(void)sort_insert3;




/********************************归并排序*******************************
1. 不断的将当前序列平均分割成2个子序列，直到不能再分割(序列中只剩一个元素)
2. 不断的将2个子序列合并成一个有序序列，直到最终只剩下1个有序序列
待排序4   3   2   1
     【4 3】      【2 1】
    【4】【3】   【2】 【1】
     【3 4】       【1 2】
         【1 2 3 4】
*/




/********************************快速排序*******************************
 快速排序（类似于扑克牌的排序）
第一步: 从序列中选择一个轴点(pivot)元素
    假设每次选择0位置作为轴点元素
第二步: 利用轴点(pivot)将序列分割成2个子序列
    将小于pivot的元素放在pivot左边(前面)
    将大于pivot的元素放在pivot右边(后面)
    等于pivot的元素放在那边都可以
第三步:对序列进行【第一步】【第二步】操作，直到不能再分割为止(子序列中只剩下一个元素)
快速排序的本质就是：逐渐将每个元素都转为轴点元素
最好、平均时间复杂度O(nlogn)，最坏的时间复杂度是O(n^2),由于递归调用的缘故空间复杂度O(logn),属于不稳定排序算法
*/
/// 快速排序
-(void)sort_quick;




/********************************希尔排序*******************************
 希尔排序把序列看成是一个矩阵，分成m列，逐列进行排序，因此希尔排序也被称为递减增量排序
    m从某个整数逐渐减为1，当m = 1时，整个序列将完全有序
    矩阵的列数取决于步长序列，如果步长序列为{1,4,6,8},就代表依次分成8列、6列、4列、1列进行排序，不同的步长序列执行效率也不一样
    希尔本人给出的步长序列是n/(2^k),当n = 16时，步长序列为{1,2,4,8},依次分成8列、4列、2列、1列进行排序，
    排序是列与列进行比较排序的
 从8列到1列的划分排序过程中，逆序队的数量在逐渐减少，因此希尔排序底层一般使用插入排序对每一列进行排序
 所以很大资料认为希尔排序是插入排序的改进版
 假设有11个元素，步长序列为{1,2,5}
 11 10 9 8 7 6 5 4 3 2 1
 
 11 10 9 8 7        1  5  4  3  2
 6   5 4 3 2  ====> 6  10 9  8  7
 1                  11
 假设元素在第col列、第row行，步长(总列数)是step
 那么这个元素在数组中的索引是 col + row * step
 例如9在排序前是第2列、第0行，那么它排序前的索引是 2 + 0 *5 = 2
 例如4在排序前是第2列、第1行，那么它排序前的索引是 2 + 1 *5 = 7
 */
/// 希尔排序
-(void)sort_shell;




/********************************计数排序*******************************
 前面的冒泡、选择、插入、归并、快速、希尔、堆排序都是基于比较的排序，平均复杂度最低是O(nlogn)
 计数排序、桶排序、基数排序都不是基于比较的排序，他们是典型的空间换时间，在某些时候，平均时间复杂度可以比O(nlogn)更低
 计数排序适合对一定范围内的整数进行排序
 计数排序的核心：统计每个整数在序列中出现的次数，进而推导出每个整数在有序序列中的索引
 待排序序列 7  3  5  8  6  7  4  5
 索引     0  1  2  3  4  5  6  7  8
 出现次数           1  1  2  1  1  1
 排序后序列 3  4  5  5  6  7  8
 该版本排序缺点：
 无法对负数进行排序；
 及其浪费内存空间，因为要根据待排序的最大值来分配多少个下标的内存(例如最大是8，就要分配存放8个元素的下标)；
 是个不稳定的排序
 */
/// 计数排序
-(void)sort_count;




/********************************基数排序*******************************
 基数排序非常适合用于整数排序(尤其是非负整数)
 执行流程：依次对个位、十位、百位、千位、万位...进行排序(从低位到高位)
 126  69  593  23   6   89  54   8
 593  23   54  126  6   8   69   89
  6   8    23  126  54  69  89   593
  6   8    23   54  69  89  126  593
 个、十、百位的取值范围都是固定的0～9，所以可以用计数排序对它们进行排序
 */


/********************************桶排序*******************************
 基数排序非常适合用于整数排序(尤其是非负整数)
 1. 创建一定数量的桶(比如用数组、链表作为桶)
 2. 按照一定的规则(不同类型的数据，规则不同)，将序列中的元素均匀分配到对应的桶中
 3. 分别对每个桶进行单独排序
 4. 将所有非空桶的元素合并成有序序列
 */

@end

NS_ASSUME_NONNULL_END
